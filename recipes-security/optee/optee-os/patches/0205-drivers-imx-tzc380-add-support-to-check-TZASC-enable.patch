From: Marco Felsch <m.felsch@pengutronix.de>
Date: Tue, 17 Jun 2025 13:46:11 +0200
Subject: [PATCH] drivers: imx: tzc380: add support to check TZASC enable state

If OP-TEE is used the TZASC should be enabled to validate the memory
access. This adds the initial support for the i.MX6 and i.MX8M to check
if the TZASC is enabled and throw a panic if not.

Once all plattforms are covered this CFG_TZASC_CHECK_ENABLED should be
remvoed and the check should be done by default to enforce that the
TZASC is running.

Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
---
 core/arch/arm/plat-imx/conf.mk           |  9 +++
 core/arch/arm/plat-imx/registers/imx8m.h |  4 ++
 core/arch/arm/plat-imx/tzc380.c          | 97 ++++++++++++++++++++++++++++++++
 3 files changed, 110 insertions(+)

diff --git a/core/arch/arm/plat-imx/conf.mk b/core/arch/arm/plat-imx/conf.mk
index 33d329655342..018aad21b8ea 100644
--- a/core/arch/arm/plat-imx/conf.mk
+++ b/core/arch/arm/plat-imx/conf.mk
@@ -555,6 +555,15 @@ $(call force,CFG_TZASC_REGION0_SECURE,y)
 endif
 endif
 
+# We can't make it default since due to missing i.MX7 and i.MX9 support.
+# Once all plattforms are supported we can remove the CFG_TZASC_CHECK_ENABLED
+# and perform the check always.
+ifneq (,$(filter y, $(CFG_MX6) $(CFG_MX8M)))
+ifneq ($(CFG_INSECURE),y)
+$(call force,CFG_TZASC_CHECK_ENABLED,y)
+endif
+endif
+
 ifeq ($(filter y, $(CFG_PSCI_ARM32)), y)
 CFG_HWSUPP_MEM_PERM_WXN = n
 CFG_IMX_WDOG ?= y
diff --git a/core/arch/arm/plat-imx/registers/imx8m.h b/core/arch/arm/plat-imx/registers/imx8m.h
index 9bda805c12bd..ea1a92346aac 100644
--- a/core/arch/arm/plat-imx/registers/imx8m.h
+++ b/core/arch/arm/plat-imx/registers/imx8m.h
@@ -8,6 +8,8 @@
 
 #include <registers/imx8m-crm.h>
 
+#define IOMUXC_GPR_BASE	0x30340000
+#define IOMUXC_SIZE	0x10000
 #define GICD_BASE	0x38800000
 #define GICR_BASE	0x38880000
 #define UART1_BASE	0x30860000
@@ -64,4 +66,6 @@
 #define IOMUXC_I2C1_SDA_MUX_OFF	0x204
 #endif
 
+#define IOMUXC_GPR_GPR10_OFFSET		0x28
+
 #endif /* __IMX8M_H__ */
diff --git a/core/arch/arm/plat-imx/tzc380.c b/core/arch/arm/plat-imx/tzc380.c
index fd15c2b09081..0f2071532605 100644
--- a/core/arch/arm/plat-imx/tzc380.c
+++ b/core/arch/arm/plat-imx/tzc380.c
@@ -11,6 +11,7 @@
 #include <drivers/tzc380.h>
 #include <imx-regs.h>
 #include <initcall.h>
+#include <io.h>
 #include <kernel/panic.h>
 #include <kernel/pm.h>
 #include <mm/core_memprot.h>
@@ -29,6 +30,99 @@ register_phys_mem(MEM_AREA_IO_SEC, TZASC2_BASE, TZASC_SIZE);
 
 register_phys_mem(MEM_AREA_IO_SEC, TZASC_BASE, TZASC_SIZE);
 
+/*
+ * i.MX6 needs special handling due to the different GPR locations.
+ */
+#if defined(CFG_MX6)
+#if defined(CFG_MX6UL) || defined(CFG_MX6ULL) || defined (CFG_MX6SLL) || defined (CFG_MX6SX)
+register_phys_mem(MEM_AREA_IO_SEC, IOMUXC_GPR_BASE, IOMUXC_SIZE);
+#else
+register_phys_mem(MEM_AREA_IO_SEC, IOMUXC_BASE, IOMUXC_SIZE);
+#endif
+#elif defined(IOMUXC_GPR_BASE)
+register_phys_mem(MEM_AREA_IO_SEC, IOMUXC_GPR_BASE, IOMUXC_SIZE);
+#endif
+
+/* Not all platforms support the GPR offsets yet */
+#ifndef IOMUXC_GPR9_OFFSET
+#define IOMUXC_GPR9_OFFSET		0
+#endif
+
+#ifndef IOMUXC_GPR_GPR10_OFFSET
+#define IOMUXC_GPR_GPR10_OFFSET		0
+#endif
+
+#define IMX6_TZASC2_BYP			BIT(1)
+#define IMX6_TZASC1_BYP			BIT(0)
+
+#define IMX8M_LOCK_GPR_TZASC_EN		BIT(16)
+#define IMX8M_TZASC_ID_SWAP_BYPASS	BIT(1)
+#define IMX8M_TZASC_EN			BIT(1)
+
+static bool imx6_tzasc_is_enabled(void)
+{
+	uint32_t mask = 0;
+	vaddr_t addr = 0;
+	paddr_t base = 0;
+
+	assert(IOMUXC_GPR9_OFFSET != 0);
+
+	if (IS_ENABLED(CFG_MX6UL) || IS_ENABLED(CFG_MX6ULL) ||
+	    IS_ENABLED(CFG_MX6SLL) || IS_ENABLED(CFG_MX6SX))
+		base = IOMUXC_GPR_BASE;
+	else
+		base = IOMUXC_BASE;
+
+	addr = core_mmu_get_va(base, MEM_AREA_IO_SEC, IOMUXC_SIZE);
+	if (!addr) {
+		EMSG("Failed to get GPR");
+		return false;
+	}
+
+	mask = IMX6_TZASC1_BYP;
+	if (IS_ENABLED(CFG_MX6Q) || IS_ENABLED(CFG_MX6D) ||
+	    IS_ENABLED(CFG_MX6DL) || IS_ENABLED(CFG_MX6QP))
+		mask |= IMX6_TZASC2_BYP;
+
+	return (io_read32(addr + IOMUXC_GPR9_OFFSET) & mask) == mask;
+}
+
+static bool imx8m_tzasc_is_enabled(void)
+{
+	uint32_t mask = 0;
+	vaddr_t addr = 0;
+
+	assert(IOMUXC_GPR_GPR10_OFFSET != 0);
+
+	addr = core_mmu_get_va(IOMUXC_GPR_BASE, MEM_AREA_IO_SEC, IOMUXC_SIZE);
+	if (!addr) {
+		EMSG("Failed to get GPR");
+		return false;
+	}
+
+	mask = IMX8M_LOCK_GPR_TZASC_EN | IMX8M_TZASC_ID_SWAP_BYPASS |
+	       IMX8M_TZASC_EN;
+
+	return (io_read32(addr + IOMUXC_GPR_GPR10_OFFSET) & mask) == mask;
+}
+
+static bool imx_tzasc_is_enabled(void)
+{
+
+	if (!IS_ENABLED(CFG_TZASC_CHECK_ENABLED)) {
+		IMSG("CFG_TZASC_CHECK_ENABLED disabled, please enable");
+		return true;
+	}
+
+	if (IS_ENABLED(CFG_MX6))
+		return imx6_tzasc_is_enabled();
+	else if (IS_ENABLED(CFG_MX8M))
+		return imx8m_tzasc_is_enabled();
+
+	IMSG("Checking TZASC enable is not supported yet for this platform");
+	return false;
+}
+
 static int imx_tzc_auto_configure(vaddr_t addr, vaddr_t rsize, uint32_t attr,
 				  uint8_t region)
 {
@@ -53,6 +147,9 @@ static TEE_Result imx_configure_tzasc(void)
 	int end = 1;
 	int i = 0;
 
+	if (!imx_tzasc_is_enabled())
+		panic("TZC380 must be enabled before starting OP-TEE");
+
 	addr[0] = core_mmu_get_va(TZASC_BASE, MEM_AREA_IO_SEC, 1);
 
 	if (IS_ENABLED(CFG_MX6Q) || IS_ENABLED(CFG_MX6D) ||
