From 41b6e96e71675e00df3f657dc663e5b2d5c3c9be Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Fri, 30 Dec 2016 13:15:36 +0100
Subject: [PATCH 1/6] at91 skov v1.3

---
 Makefile                                          |   2 +-
 arch/arm/cpu/arm926ejs/at91/at91sam9263_devices.c |  21 +
 arch/arm/include/asm/arch-at91/at91sam9_pwm.h     |  39 ++
 arch/arm/include/asm/arch-at91/gpio.h             |  10 +-
 arch/arm/lib/board.c                              |  12 +
 board/skov/skov_cpu_module/Makefile               |  52 ++
 board/skov/skov_cpu_module/cmd_lcd.c              | 159 +++++
 board/skov/skov_cpu_module/lc7981.c               | 279 ++++++++
 board/skov/skov_cpu_module/led.c                  |  46 ++
 board/skov/skov_cpu_module/partition.c            |  36 ++
 board/skov/skov_cpu_module/skov_cpu_module.c      | 741 ++++++++++++++++++++++
 boards.cfg                                        |   1 +
 common/Makefile                                   |   3 +
 common/cmd_bootm.c                                |   9 +
 common/cmd_nand.c                                 |  21 +
 common/env_dataflash.c                            |  34 +-
 common/env_flash.c                                | 181 +++++-
 common/env_skov_compat.c                          |  89 +++
 common/flash.c                                    |   2 +
 common/lcd.c                                      | 212 ++++++-
 common/main.c                                     |  22 +
 drivers/bootcount/Makefile                        |   1 +
 drivers/mmc/gen_atmel_mci.c                       |  12 +
 drivers/mtd/cfi_flash.c                           |   9 +-
 drivers/mtd/dataflash.c                           |  29 +
 drivers/mtd/nand/atmel_nand.c                     |   7 +
 drivers/rtc/Makefile                              |   1 +
 drivers/rtc/ds1374.c                              |  70 ++
 drivers/rtc/m41t80.c                              | 208 ++++++
 include/atmel_mci.h                               |   7 +-
 include/configs/skov_cpu_module.h                 | 291 +++++++++
 include/dataflash.h                               |   1 +
 include/ds1374.h                                  |  30 +
 include/environment.h                             |  35 +-
 include/flash.h                                   |   3 +
 include/i2c.h                                     |  21 +-
 include/lc7981.h                                  |  18 +
 include/lcd.h                                     |   1 +
 include/m41t80.h                                  |  26 +
 tools/Makefile                                    |   1 -
 tools/envcrc.c                                    |   9 +
 41 files changed, 2667 insertions(+), 84 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-at91/at91sam9_pwm.h
 create mode 100644 board/skov/skov_cpu_module/Makefile
 create mode 100644 board/skov/skov_cpu_module/cmd_lcd.c
 create mode 100644 board/skov/skov_cpu_module/lc7981.c
 create mode 100644 board/skov/skov_cpu_module/led.c
 create mode 100644 board/skov/skov_cpu_module/partition.c
 create mode 100644 board/skov/skov_cpu_module/skov_cpu_module.c
 create mode 100644 common/env_skov_compat.c
 create mode 100644 drivers/rtc/m41t80.c
 create mode 100644 include/configs/skov_cpu_module.h
 create mode 100644 include/ds1374.h
 create mode 100644 include/lc7981.h
 create mode 100644 include/m41t80.h

diff --git a/Makefile b/Makefile
index 09456e0..35c138d 100644
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 2012
 PATCHLEVEL = 10
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = "Skov-Version-1.3"
 ifneq "$(SUBLEVEL)" ""
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 else
diff --git a/arch/arm/cpu/arm926ejs/at91/at91sam9263_devices.c b/arch/arm/cpu/arm926ejs/at91/at91sam9263_devices.c
index 7191db2..5901dfa 100644
--- a/arch/arm/cpu/arm926ejs/at91/at91sam9263_devices.c
+++ b/arch/arm/cpu/arm926ejs/at91/at91sam9263_devices.c
@@ -207,3 +207,24 @@ void at91_can_hw_init(void)
 	writel(1 << ATMEL_ID_CAN, &pmc->pcer);
 }
 #endif
+
+#if defined(CONFIG_GENERIC_ATMEL_MCI)
+void at91_mci_hw_init(void)
+{
+        at91_set_a_periph(AT91_PIO_PORTA, 8, 1);        /* MCCK */
+#if defined(CONFIG_ATMEL_MCI_PORTB)
+        at91_set_b_periph(AT91_PIO_PORTA, 1, 1);        /* MCCDB */
+        at91_set_b_periph(AT91_PIO_PORTA, 0, 1);        /* MCDB0 */
+        at91_set_b_periph(AT91_PIO_PORTA, 5, 1);        /* MCDB1 */
+        at91_set_b_periph(AT91_PIO_PORTA, 4, 1);        /* MCDB2 */
+        at91_set_b_periph(AT91_PIO_PORTA, 3, 1);        /* MCDB3 */
+#else
+        at91_set_a_periph(AT91_PIO_PORTA, 7, 1);        /* MCCDA */
+        at91_set_a_periph(AT91_PIO_PORTA, 6, 1);        /* MCDA0 */
+        at91_set_a_periph(AT91_PIO_PORTA, 9, 1);        /* MCDA1 */
+        at91_set_a_periph(AT91_PIO_PORTA, 10, 1);       /* MCDA2 */
+        at91_set_a_periph(AT91_PIO_PORTA, 11, 1);       /* MCDA3 */
+#endif
+}
+#endif
+
diff --git a/arch/arm/include/asm/arch-at91/at91sam9_pwm.h b/arch/arm/include/asm/arch-at91/at91sam9_pwm.h
new file mode 100644
index 0000000..cfd935e
--- /dev/null
+++ b/arch/arm/include/asm/arch-at91/at91sam9_pwm.h
@@ -0,0 +1,39 @@
+/**
+  * @file
+  * @author Søren Andersen <san@rosetechnology.dk>
+  * 
+  */
+#define AT91_PWM_ENA    0x4    /* (PWMC) PWMC Enable Register */
+#define AT91_PWM_DIS    0x8    /* PWMC Disable Register */
+
+#define AT91_PWM_CUPD       ((unsigned int) 0x0 <<  0)      /* (PWMC_CH) Channel Update */
+#define AT91_PWM_CHID1      ((unsigned int) 0x1 <<  1)      /* (PWMC) Channel ID 2 */
+#define AT91_PWM_CHID2      ((unsigned int) 0x1 <<  2)      /* (PWMC) Channel ID 2 */
+#define AT91_PWM_CHID3      ((unsigned int) 0x1 <<  3)      /* (PWMC) Channel ID 3 */
+#define AT91_ID_PWM         ((unsigned int) 20)             /* PWM Controller */
+#define AT91_PWM_CPOL       ((unsigned int) 0x1 <<  9)      /* (PWMC_CH) Channel Polarity */
+#define AT91_BASE_PWMC      0xFFFB8000
+#define AT91_PWM_CMR0       0x200
+#define AT91_PWM_CMR(n) (AT91_PWM_CMR0 + ((n) * 0x20))      /* PWM Channel Mode Register */
+#define AT91_PWM_CPRDR0     0x208
+#define AT91_PWM_CPRDR(n) (AT91_PWM_CPRDR0 + ((n) * 0x20))  /* Channel Period Register */
+#define AT91_PWM_CDTYR0     0x204
+#define AT91_PWM_CDTYR(n) (AT91_PWM_CDTYR0 + ((n) * 0x20))  /* Channel Duty Cycle Register */
+#define AT91_PWM_CUPDR0     0x210
+#define AT91_PWM_CUPDR(n) (AT91_PWM_CUPDR0 + ((n) * 0x20))  /* Channel Update Register */
+
+/* Channel pre scaler */
+#define AT91_PWM_CMR_MCK     (0x0 << 0)  /* MCK        */
+#define AT91_PWM_CMR_MCK2    (0x1 << 0)  /* MCK / 2    */
+#define AT91_PWM_CMR_MCK4    (0x2 << 0)  /* MCK / 4    */
+#define AT91_PWM_CMR_MCK8    (0x3 << 0)  /* MCK / 8    */
+#define AT91_PWM_CMR_MCK16   (0x4 << 0)  /* MCK / 16   */
+#define AT91_PWM_CMR_MCK32   (0x5 << 0)  /* MCK / 32   */
+#define AT91_PWM_CMR_MCK64   (0x6 << 0)  /* MCK / 64   */
+#define AT91_PWM_CMR_MCK128  (0x7 << 0)  /* MCK / 128  */ 
+#define AT91_PWM_CMR_MCK256  (0x8 << 0)  /* MCK / 256  */
+#define AT91_PWM_CMR_MCK512  (0x9 << 0)  /* MCK / 512  */
+#define AT91_PWM_CMR_MCK1024 (0xA << 0)  /* MCK / 1024 */
+#define AT91_PWM_CMR_CLKA    (0xB << 0)  /* CLKA       */
+#define AT91_PWM_CMR_CLKB    (0xC << 0)  /* CLKB       */
+  
diff --git a/arch/arm/include/asm/arch-at91/gpio.h b/arch/arm/include/asm/arch-at91/gpio.h
index 293d0bf..797a0dd 100644
--- a/arch/arm/include/asm/arch-at91/gpio.h
+++ b/arch/arm/include/asm/arch-at91/gpio.h
@@ -218,7 +218,7 @@ static inline unsigned pin_to_mask(unsigned pin)
 
 /* The following macros are need for backward compatibility */
 #define at91_set_GPIO_periph(x, y) \
-	at91_set_gpio_periph((x - PIN_BASE) / 32,(x % 32), y)
+	at91_set_pio_periph((x - PIN_BASE) / 32,(x % 32), y) /**< san call the right function */
 #define at91_set_A_periph(x, y) \
 	at91_set_a_periph((x - PIN_BASE) / 32,(x % 32), y)
 #define at91_set_B_periph(x, y) \
@@ -231,6 +231,14 @@ static inline unsigned pin_to_mask(unsigned pin)
 	at91_set_pio_value((x - PIN_BASE) / 32,(x % 32), y)
 #define at91_get_gpio_value(x) \
 	at91_get_pio_value((x - PIN_BASE) / 32,(x % 32))
+/**
+ * @author Søren Andersen <san@rosetechnology.dk> 
+ */
+#define at91_set_gpio_multi_drive(x, y) \
+	at91_set_pio_multi_drive((x - PIN_BASE) / 32,(x % 32), y)
+#define at91_set_gpio_deglitch(x, y) \
+        at91_set_pio_deglitch((x - PIN_BASE) / 32,(x % 32), y)
+/* End san */
 #else
 #define at91_set_gpio_value(x, y)	at91_set_pio_value(x, y)
 #define at91_get_gpio_value(x)		at91_get_pio_value(x)
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index 109a1ac..48cc4af 100644
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -71,6 +71,9 @@ ulong monitor_flash_len;
 #ifdef CONFIG_HAS_DATAFLASH
 extern int  AT91F_DataflashInit(void);
 extern void dataflash_print_info(void);
+#ifdef CONFIG_SKOV_CPU_MODULE 
+extern void check_240(void);
+#endif
 #endif
 
 #if defined(CONFIG_HARD_I2C) || \
@@ -78,6 +81,8 @@ extern void dataflash_print_info(void);
 #include <i2c.h>
 #endif
 
+//#define DEBUG
+
 /************************************************************************
  * Coloured LED functionality
  ************************************************************************
@@ -537,8 +542,11 @@ void board_init_r(gd_t *id, ulong dest_addr)
 		print_size(flash_size, "\n");
 # endif /* CONFIG_SYS_FLASH_CHECKSUM */
 	} else {
+	//
+#if !defined(CONFIG_SKOV_CPU_MODULE)
 		puts(failed);
 		hang();
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	}
 #endif
 
@@ -559,9 +567,13 @@ void board_init_r(gd_t *id, ulong dest_addr)
 #ifdef CONFIG_HAS_DATAFLASH
 	AT91F_DataflashInit();
 	dataflash_print_info();
+#ifdef CONFIG_SKOV_CPU_MODULE
+	check_240(); /**< Martin Bjærre Is the board running 240Mhz? */
+#endif
 #endif
 
 	/* initialize environment */
+	env_init(); /**< Martin Bjærre Re-init for dataflash */
 	env_relocate();
 
 #if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
diff --git a/board/skov/skov_cpu_module/Makefile b/board/skov/skov_cpu_module/Makefile
new file mode 100644
index 0000000..753441c
--- /dev/null
+++ b/board/skov/skov_cpu_module/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003-2008
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Stelian Pop <stelian@popies.net>
+# Lead Tech Design <www.leadtechdesign.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y += skov_cpu_module.o
+COBJS-y += lc7981.o
+COBJS-y += cmd_lcd.o
+COBJS-y += led.o
+COBJS-$(CONFIG_HAS_DATAFLASH) += partition.o
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/skov/skov_cpu_module/cmd_lcd.c b/board/skov/skov_cpu_module/cmd_lcd.c
new file mode 100644
index 0000000..9ab86b4
--- /dev/null
+++ b/board/skov/skov_cpu_module/cmd_lcd.c
@@ -0,0 +1,159 @@
+/*
+ * 2008
+ * Rose Technology <www.rosetechnology.dk>
+ * Martin Bjaerre <mab@rosetechnology.dk>
+ *
+ * Command file for new LCD commands, written for lc7981,
+ * but applicable for other drivers if implemented.
+ */
+
+/*
+ * BMP handling routines
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/byteorder.h>
+#include <malloc.h>
+
+static int lcd_size(char * width, char * height);
+static int lcd_contrast(char * contrast);
+static int lcd_bglight(char * bglight);
+static void lcd_get(void);
+
+#ifdef CONFIG_LC7981
+extern void lc7981_update_bglight(uint bglight);
+extern void lc7981_update_contrast(uint contrast);
+#endif
+
+
+/*
+ * Subroutine:  do_lcd
+ *
+ * Description: Handler for 'lcd' command..
+ *
+ * Inputs:	argv[1] contains the subcommand
+ *
+ * Return:      None
+ *
+ */
+int do_lcd(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	char *x, *y;
+	x = y = "";
+
+	switch (argc) {
+	case 3:		/* bglight/contrast */
+		x = argv[2];
+		break;
+	case 4:		/* size */
+	        x = argv[2];
+	        y = argv[3];
+	        break;
+	default:
+		break;
+	}
+
+	/* Allow for short names
+	 * Adjust length if more sub-commands get added
+	 */
+	if (strncmp(argv[1],"size",1) == 0) {
+		return (lcd_size(x,y));
+	} else if (strncmp(argv[1],"contrast",1) == 0) {
+	    return (lcd_contrast(x));
+	} else if (strncmp(argv[1],"bglight",1) == 0) {
+	    return (lcd_bglight(x));
+	} else if (strncmp(argv[1],"help",1) == 0) {
+		printf("Help:\n%s\n", cmdtp->help);
+		return 1;
+	} else if (strncmp(argv[1],"get",1) == 0) {
+		lcd_get();
+		return 1;
+	} else {
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+}
+
+U_BOOT_CMD(
+	lcd,	4,	1,	do_lcd,
+	"Set properties of display",
+	    "size [x y]         - Set size of display to x times y pixels\n"
+	"lcd contrast [x]       - Set contrast of display, values 0 - 100 accepted\n"
+	"lcd bglight [x]        - Set background light of display, value 0 - 100 accepted\n"
+	"lcd get                - Show lcd properties"
+);
+
+/*
+ * Subroutine:  lcd_size
+ *
+ * Description: Set the size of the LCD screen
+ *
+ * Inputs:	pixel width and height
+ *
+ * Return:      None
+ *
+ */
+static int lcd_size(char * width, char * height)
+{
+	if(simple_strtoul(width, NULL, 10) > 0 && simple_strtoul(height, NULL, 10) > 0){
+		setenv("lcd_width", width);
+		setenv("lcd_height", height);
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Subroutine:  lcd_contrast
+ *
+ * Description: Set the contrast of the LCD screen
+ *
+ * Inputs:	Contrast between 0 and 100
+ *
+ * Return:      None
+ *
+ */
+static int lcd_contrast(char * contrast)
+{
+	if(simple_strtoul(contrast, NULL, 10) >= 0 && simple_strtoul(contrast, NULL, 10) <= 100){
+		setenv("lcd_contrast", contrast);
+#ifdef CONFIG_LC7981
+		lc7981_update_contrast((uint)simple_strtoul(contrast, NULL, 10));
+#endif
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Subroutine:  lcd_bglight
+ *
+ * Description: Set the background light of the LCD screen
+ *
+ * Inputs:	background light between 0 and 100
+ *
+ * Return:      None
+ *
+ */
+static int lcd_bglight(char * bglight)
+{
+	if(simple_strtoul(bglight, NULL, 10) >= 0 && simple_strtoul(bglight, NULL, 10) <= 100){
+		setenv("lcd_bglight", bglight);
+#ifdef CONFIG_LC7981
+		lc7981_update_bglight((uint)simple_strtoul(bglight, NULL, 10));
+#endif
+		return 1;
+	}
+	return 0;
+}
+static void lcd_get(void)
+{
+	char *width, *height, *contrast, *bglight;
+	width = getenv("lcd_width");
+	height = getenv("lcd_height");
+	contrast = getenv("lcd_contrast");
+	bglight = getenv("lcd_bglight");
+	printf("width: %s\nheight: %s\ncontrast: %s\n"
+		"background light: %s\n", width, height, contrast, bglight);
+}
diff --git a/board/skov/skov_cpu_module/lc7981.c b/board/skov/skov_cpu_module/lc7981.c
new file mode 100644
index 0000000..b5ee052
--- /dev/null
+++ b/board/skov/skov_cpu_module/lc7981.c
@@ -0,0 +1,279 @@
+/**
+ * @file
+ * 2008
+ * Rose Technology <www.rosetechnology.dk>
+ * Martin Bjaerre <mab@rosetechnology.dk>
+ *
+ * Display driver for lcd displays on SKOV board.
+ * For displaying a startup image.
+ * 2010
+ * san@rosetechnology
+ * Ported driver to new uboot API
+ */
+ 
+#include <config.h>
+#include <common.h>
+#include <lcd.h>
+#include <lc7981.h>
+#include <asm/arch/at91sam9263.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91sam9_pwm.h>
+#include <asm/arch/gpio.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_LC7981
+
+#define EN      AT91_PIN_PE8
+#define RW      AT91_PIN_PE11
+#define RS      AT91_PIN_PE12
+#define CS      AT91_PIN_PE9
+#define RST     AT91_PIN_PE13
+#define B0      AT91_PIN_PE0
+#define B1      AT91_PIN_PE1
+#define B2      AT91_PIN_PE2
+#define B3      AT91_PIN_PE3
+#define B4      AT91_PIN_PE4
+#define B5      AT91_PIN_PE5
+#define B6      AT91_PIN_PE6
+#define B7      AT91_PIN_PE7
+
+
+#define MODE_REG	0
+#define PITCH_REG	0x01
+#define WIDTH_REG	0x02
+#define DUTY_REG	0x03
+#define CSIZE_REG	0x04
+#define ADDRSL_REG	0x08
+#define ADDRSH_REG	0x09
+#define ADDRL_REG	0x0A
+#define ADDRH_REG	0x0B
+#define WRITE_REG	0x0C
+#define READ_REG	0x0D
+
+#define WRITE(d)	lcd_write_bus(d)
+
+/*
+ * Write to a PWM register.
+ */
+static inline void at91_pwm_write( unsigned int reg, unsigned long value )
+{
+	void *addr = (void *)AT91_BASE_PWMC;
+	__raw_writel( value, addr + reg );
+}
+          
+/*
+ * Read from a PWM register.
+ */
+static inline unsigned long at91_pwm_read( unsigned int reg )
+{
+	void *addr = (void *)AT91_BASE_PWMC;	
+	return __raw_readl( addr + reg );
+} 
+
+//void *lcd_base;			/* Start of framebuffer memory	*/
+//void *lcd_console_address;		/* Start of console buffer	*/
+
+//static unsigned char lcd_read_bus(void);
+static void lcd_write_bus(unsigned char data);
+
+/*
+ulong calc_fbsize (void)
+{
+	return 0;
+}
+*/
+static void my_delay(unsigned int time)
+{
+	unsigned int i;
+	for( i = 0; i < (time*9); i++);
+}
+
+void lcd_write_reg(unsigned char reg, unsigned char data)
+{
+	at91_set_gpio_value( RS,1 ); at91_set_gpio_value( CS,0 ); at91_set_gpio_value( RW,0 ); 
+	my_delay(1);
+	WRITE(reg);
+	my_delay(1);
+	at91_set_gpio_value( EN,1 ); at91_set_gpio_value( EN,0 );
+	at91_set_gpio_value( RS,0 );
+	my_delay(1);
+	WRITE(data);
+	my_delay(1);
+	at91_set_gpio_value( EN,1 ); at91_set_gpio_value( EN,0 );
+	at91_set_gpio_value( CS,1 ); at91_set_gpio_value( RW,1 );	        
+	my_delay(1);	 
+}
+
+void lcd_set_addr(unsigned short addr)
+{
+	lcd_write_reg(ADDRL_REG, addr & 0xFF);
+	lcd_write_reg(ADDRH_REG, addr >> 8);
+}
+
+void lcd_write_data(unsigned char data )
+{
+	at91_set_gpio_value( RS,1 );
+	at91_set_gpio_value( CS,0 ); at91_set_gpio_value( RW,0 );
+	my_delay(1);
+	WRITE(WRITE_REG);
+	my_delay(1);
+	at91_set_gpio_value( EN,1 );
+	at91_set_gpio_value( EN,0 );
+	at91_set_gpio_value( RS,0 );
+	my_delay(1);
+	WRITE(data);
+	my_delay(1);
+	at91_set_gpio_value( EN,1 ); at91_set_gpio_value( EN,0 );
+	at91_set_gpio_value( CS,1 ); at91_set_gpio_value( RW,1 );
+	my_delay(1);
+		
+}	
+
+void lc7981_ctrl_init(void)
+{
+	at91_pmc_t      *pmc    = (at91_pmc_t *) ATMEL_BASE_PMC;
+	
+	at91_set_gpio_output( EN,0 ); at91_set_gpio_output( RW,0 ); at91_set_gpio_output( RS,0 );at91_set_gpio_output( RST,0 );
+	at91_set_gpio_output( CS,0 );
+	at91_set_gpio_output( B0,0 ); at91_set_gpio_output( B1,0 ); at91_set_gpio_output( B2,0 ); at91_set_gpio_output( B3,0 );
+	at91_set_gpio_output( B4,0 ); at91_set_gpio_output( B5,0 ); at91_set_gpio_output( B6,0 ); at91_set_gpio_output( B7,0 );
+	
+	at91_set_gpio_value( EN,0 ); at91_set_gpio_value( RW,0 );
+	at91_set_gpio_value( RS,1 ); at91_set_gpio_value( CS,1 ); at91_set_gpio_value( RST,1 );
+	at91_set_gpio_value( B0,0 ); at91_set_gpio_value( B1,0 ); at91_set_gpio_value( B2,0 ); at91_set_gpio_value( B3,0 ); 
+	at91_set_gpio_value( B4,0 ); at91_set_gpio_value( B5,0 ); at91_set_gpio_value( B6,0 ); at91_set_gpio_value( B7,0 );
+	at91_set_gpio_value( RST,0 ); 
+	my_delay(1);
+	at91_set_gpio_value( RST,1 );
+	
+	/* Set Display in Graphic mode , Master)*/
+	lcd_write_reg(MODE_REG, 0x32);
+	lcd_write_reg(PITCH_REG, 0x07);
+	lcd_write_reg(WIDTH_REG, (panel_info.vl_col/8)-1);
+	lcd_write_reg(DUTY_REG, panel_info.vl_row-1);
+	//lcd_write_reg(CSIZE_REG, 8);
+	
+	lcd_write_reg(ADDRSL_REG, 0);
+	lcd_write_reg(ADDRSH_REG, 0);
+
+	/* enable PWM */
+	writel(1<<AT91_ID_PWM, &pmc->pcer);
+	//at91_sys_write(AT91_PMC_PCER, 1<<AT91_ID_PWM );
+	at91_set_B_periph(AT91_PIN_PC29, 0);	
+	at91_set_B_periph(AT91_PIN_PE10, 0);
+
+	at91_pwm_write( AT91_PWM_CMR(2), AT91_PWM_CMR_MCK512 | AT91_PWM_CPOL );
+	
+	at91_pwm_write( AT91_PWM_CPRDR(2), 500 );
+
+	if(getenv("lcd_contrast") != NULL){
+		at91_pwm_write( AT91_PWM_CDTYR(2), 60+simple_strtoul(getenv("lcd_contrast"), NULL, 10) );	
+	}
+	else {
+		at91_pwm_write( AT91_PWM_CDTYR(2), 110 ); /* 50% */
+	}
+	at91_pwm_write( AT91_PWM_CUPDR(2), 110 );
+
+	at91_pwm_write( AT91_PWM_CMR(3), AT91_PWM_CMR_MCK64 | AT91_PWM_CPOL );
+
+	at91_pwm_write( AT91_PWM_CPRDR(3), 100 );
+
+	if(getenv("lcd_bglight") != NULL){
+		at91_pwm_write( AT91_PWM_CDTYR(3), simple_strtoul(getenv("lcd_bglight"), NULL, 10) );
+	}
+	else {
+		at91_pwm_write( AT91_PWM_CDTYR(3), 80 ); /* 80% */
+	}
+	at91_pwm_write( AT91_PWM_CUPDR(3), 80 );
+	at91_pwm_write( AT91_PWM_ENA, AT91_PWM_CHID3 );
+}
+
+void lc7981_update_contrast(uint contrast)
+{
+	at91_pwm_write( AT91_PWM_CUPDR(2), 60 + contrast );
+	at91_pwm_write( AT91_PWM_CMR(2), at91_pwm_read( AT91_PWM_CMR(2) ) | AT91_PWM_CUPD );
+}
+
+void lc7981_update_bglight(uint bglight)
+{
+	at91_pwm_write( AT91_PWM_CUPDR(3), 60 + bglight );
+	at91_pwm_write( AT91_PWM_CMR(3), at91_pwm_read( AT91_PWM_CMR(3) ) | AT91_PWM_CUPD );
+}
+
+void lc7981_clear(void)
+{
+	int row, col;
+	lcd_set_addr(0);
+	for(row = 0; row < 128; row++)
+	{
+		for(col = 0; col < 30; col++)
+		{
+			lcd_write_data(0x00);
+		}
+	}
+	lcd_set_addr(0);
+}
+void lc7981_enable(void)
+{
+	at91_pwm_write( AT91_PWM_ENA, AT91_PWM_CHID2 );
+}
+void lc7981_disable(void)
+{
+	at91_pwm_write( AT91_PWM_DIS, AT91_PWM_CHID2 );
+}
+
+/*
+static unsigned char lcd_read_bus(void)
+{
+	return 	AT91C_BASE_PIOE->PIO_PDSR & 0xFF;
+}
+*/
+/*
+static void lcd_write_bus(unsigned char data)
+{
+	AT91C_BASE_PIOE->PIO_CODR = (unsigned char)~data;
+	AT91C_BASE_PIOE->PIO_SODR = (unsigned char) data;
+}
+*/
+static void lcd_write_bus(unsigned char data)
+{
+	at91_set_gpio_value(B0, (unsigned char)data & 0x01);
+	
+	if (((unsigned char)data & 0x02) == 0x02 ) {
+		at91_set_gpio_value(B1, 1);
+	} else {
+		at91_set_gpio_value(B1, 0);
+	}
+	if (((unsigned char)data & 0x04) == 0x04 ) {
+		at91_set_gpio_value(B2, 1);
+	} else {
+		at91_set_gpio_value(B2, 0);
+	}
+	if (((unsigned char)data & 0x08) == 0x08 ) {
+		at91_set_gpio_value(B3, 1);	
+	} else {
+		at91_set_gpio_value(B3, 0);
+	}
+	if (((unsigned char)data & 0x10) == 0x10 ) {
+		at91_set_gpio_value(B4, 1);
+	} else {
+		at91_set_gpio_value(B4, 0);
+	}
+	if (((unsigned char)data & 0x20) == 0x20 ) {
+		at91_set_gpio_value(B5, 1);
+	} else {
+		at91_set_gpio_value(B5, 0);
+	}
+	if (((unsigned char)data & 0x40) == 0x40 ) {
+		at91_set_gpio_value(B6, 1);
+	} else {
+		at91_set_gpio_value(B6, 0);
+	}
+	if (((unsigned char)data & 0x80) == 0x80 ) {
+		at91_set_gpio_value(B7, 1);
+	} else {
+		at91_set_gpio_value(B7, 0);
+	}	
+}	
+
+#endif /* CONFIG_LC7981 */
diff --git a/board/skov/skov_cpu_module/led.c b/board/skov/skov_cpu_module/led.c
new file mode 100644
index 0000000..ce3cf09
--- /dev/null
+++ b/board/skov/skov_cpu_module/led.c
@@ -0,0 +1,46 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian@popies.net>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91sam9263.h>
+
+void coloured_LED_init(void)
+{
+	/* Enable clock */
+	at91_pmc_t *pmc = (at91_pmc_t *) ATMEL_BASE_PMC;
+
+	writel(1 << ATMEL_ID_PIOB | 1 << ATMEL_ID_PIOCDE,
+		&pmc->pcer);
+
+	at91_set_gpio_output(CONFIG_RED_LED, 1);
+	at91_set_gpio_output(CONFIG_GREEN_LED, 1);
+	at91_set_gpio_output(CONFIG_YELLOW_LED, 1);
+
+	at91_set_gpio_value(CONFIG_RED_LED, 0);
+	at91_set_gpio_value(CONFIG_GREEN_LED, 1);
+	at91_set_gpio_value(CONFIG_YELLOW_LED, 1);
+}
diff --git a/board/skov/skov_cpu_module/partition.c b/board/skov/skov_cpu_module/partition.c
new file mode 100644
index 0000000..7742d73
--- /dev/null
+++ b/board/skov/skov_cpu_module/partition.c
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2008
+ * Ulf Samuelsson <ulf@atmel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#include <common.h>
+#include <config.h>
+#include <asm/hardware.h>
+#include <dataflash.h>
+
+AT91S_DATAFLASH_INFO dataflash_info[CONFIG_SYS_MAX_DATAFLASH_BANKS];
+
+struct dataflash_addr cs[CONFIG_SYS_MAX_DATAFLASH_BANKS] = {
+	{CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS0, 0},	/* Logical adress, CS */
+};
+
+/*define the area offsets*/
+dataflash_protect_t area_list[NB_DATAFLASH_AREA] = {
+	{0x00000000, 0x0007FDFF, FLAG_PROTECT_CLEAR, 0, "Bootstrap + U-Boot"},
+	{0x0007FE00, 0x00083FFF, FLAG_PROTECT_CLEAR, 0, "Environment"},
+};
diff --git a/board/skov/skov_cpu_module/skov_cpu_module.c b/board/skov/skov_cpu_module/skov_cpu_module.c
new file mode 100644
index 0000000..3251ca1
--- /dev/null
+++ b/board/skov/skov_cpu_module/skov_cpu_module.c
@@ -0,0 +1,741 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian@popies.net>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/sizes.h>
+#include <asm/arch/at91sam9263.h>
+#include <asm/arch/at91sam9_smc.h>
+#include <asm/arch/at91sam9_pwm.h> /**< Rose: Add pwm support*/
+#include <asm/arch/at91_common.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91_rstc.h>
+#include <asm/arch/at91_matrix.h>
+#include <asm/arch/at91_pio.h>
+#include <asm/arch/gpio.h> /**< Rose: Add gpio support */
+#include <asm/arch/clk.h>
+#include <asm/io.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/hardware.h>
+#include <lcd.h>
+#include <atmel_lcdc.h>
+#if defined(CONFIG_RESET_PHY_R) && defined(CONFIG_MACB)
+#include <net.h>
+#endif
+#include <netdev.h>
+#ifdef CONFIG_GENERIC_ATMEL_MCI
+#include <mmc.h>          /**< Rose: We ned to add mmc support in this file */
+#include <atmel_mci.h>
+#endif
+/** 
+ * @author Soren Andersen <san@rosetechnology.dk> 
+ * 
+ * Revition I boards got an external I2C watchdog, because of the atmel
+ * CPU reset bug. 
+ */
+#include <asm/arch/at91_wdt.h>
+#include <i2c.h>
+#include <ds1374.h>
+#include <m41t80.h>
+int skov_with_ds1374 = 0;
+int skov_with_m41t82 = 0;
+int wd_init = 0;
+/* End san */
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+#ifdef CONFIG_LTTD800480070
+/**
+ * Write to a PWM register.
+ */
+static inline void at91_pwm_write( unsigned int reg, unsigned long value )
+{
+    void *addr = (void *)AT91_BASE_PWMC;
+    __raw_writel( value, addr + reg );
+}
+  		          
+/**
+ * Read from a PWM register.
+ */
+static inline unsigned long at91_pwm_read( unsigned int reg )
+{
+    void *addr = (void *)AT91_BASE_PWMC;	
+    return __raw_readl( addr + reg );
+}
+#endif /*CONFIG_LTTD800480070*/
+
+/**
+ * @author Søren Andersen <san@rosetechnology.dk> 
+ * Add MMC support
+ */
+#ifdef CONFIG_GENERIC_ATMEL_MCI
+/* this is a weak define that we are overriding */
+int board_mmc_init(bd_t *bd)
+{
+        at91_pmc_t    *pmc    = (at91_pmc_t *) ATMEL_BASE_PMC;
+        /* Enable clock */
+        writel(1 << ATMEL_ID_MCI0, &pmc->pcer); // enable MCI clock
+        writel(1 << ATMEL_ID_MCI1, &pmc->pcer);
+        writel(1 << ATMEL_ID_PIOA, &pmc->pcer);
+                  
+        at91_mci_hw_init();
+
+        /* This calls the atmel_mci_init in gen_atmel_mci.c */
+        return atmel_mci_init((void *)ATMEL_BASE_MCI1);
+}
+
+/* this is a weak define that we are overriding */
+int board_mmc_getcd(struct mmc *mmc)
+{
+        return !at91_get_gpio_value(CONFIG_SYS_MMC_CD_PIN);        
+}
+#endif
+
+#ifdef CONFIG_CMD_NAND
+static void at91sam9263ek_nand_hw_init(void)
+{
+	unsigned long csa;
+	at91_smc_t    *smc    = (at91_smc_t *) ATMEL_BASE_SMC0;
+	at91_matrix_t *matrix = (at91_matrix_t *) ATMEL_BASE_MATRIX;
+	at91_pmc_t    *pmc    = (at91_pmc_t *) ATMEL_BASE_PMC;
+
+	/* Enable CS3 */
+	csa = readl(&matrix->csa[0]) | AT91_MATRIX_CSA_EBI_CS3A;
+	writel(csa, &matrix->csa[0]);
+
+	/* Enable CS3 */
+
+	/* Configure SMC CS3 for NAND/SmartMedia */
+	writel(AT91_SMC_SETUP_NWE(1) | AT91_SMC_SETUP_NCS_WR(0) |
+		AT91_SMC_SETUP_NRD(1) | AT91_SMC_SETUP_NCS_RD(0),
+		&smc->cs[3].setup);
+
+	writel(AT91_SMC_PULSE_NWE(3) | AT91_SMC_PULSE_NCS_WR(3) |
+		AT91_SMC_PULSE_NRD(3) | AT91_SMC_PULSE_NCS_RD(3),
+		&smc->cs[3].pulse);
+
+	writel(AT91_SMC_CYCLE_NWE(5) | AT91_SMC_CYCLE_NRD(5),
+		&smc->cs[3].cycle);
+	writel(AT91_SMC_MODE_RM_NRD | AT91_SMC_MODE_WM_NWE |
+		AT91_SMC_MODE_EXNW_DISABLE |
+#ifdef CONFIG_SYS_NAND_DBW_16
+		       AT91_SMC_MODE_DBW_16 |
+#else /* CONFIG_SYS_NAND_DBW_8 */
+		       AT91_SMC_MODE_DBW_8 |
+#endif
+		       AT91_SMC_MODE_TDF_CYCLE(2),
+		&smc->cs[3].mode);
+
+	writel(1 << ATMEL_ID_PIOA | 1 << ATMEL_ID_PIOCDE,
+		&pmc->pcer);
+	
+	/* Rose/HBS: We have R/B on pioB */
+	writel(1 << ATMEL_ID_PIOA | 1 << ATMEL_ID_PIOB | 1 << ATMEL_ID_PIOCDE,
+			&pmc->pcer);		
+
+	/* Configure RDY/BSY */
+	at91_set_gpio_input(CONFIG_SYS_NAND_READY_PIN, 1);
+
+	/* Enable NandFlash */
+	//at91_set_gpio_output(CONFIG_SYS_NAND_ENABLE_PIN, 1);
+	at91_set_gpio_output(CONFIG_SYS_NAND_ENABLE_PIN, 0); /**< Rose/HBS: stygt hack */
+}
+#endif
+
+#ifdef CONFIG_MACB
+static void at91sam9263ek_macb_hw_init(void)
+{
+	unsigned long 	erstl;
+	at91_pmc_t	*pmc	= (at91_pmc_t *) ATMEL_BASE_PMC;
+	at91_pio_t	*pio	= (at91_pio_t *) ATMEL_BASE_PIO;
+	at91_rstc_t	*rstc	= (at91_rstc_t *) ATMEL_BASE_RSTC;
+	/* Enable clock */
+	writel(1 << ATMEL_ID_EMAC, &pmc->pcer);
+
+	/*
+	 * Disable pull-up on:
+	 *	RXDV (PC25) => PHY normal mode (not Test mode)
+	 * 	ERX0 (PE25) => PHY ADDR0
+	 *	ERX1 (PE26) => PHY ADDR1 => PHYADDR = 0x0
+	 *
+	 * PHY has internal pull-down
+	 */
+
+	writel(1 << 25, &pio->pioc.pudr);
+	writel((1 << 25) | (1 <<26), &pio->pioe.pudr);
+
+	//erstl = readl(&rstc->mr) & AT91_RSTC_MR_ERSTL_MASK;
+	erstl = 0x1; /**< Rose: erstl need be be 1, otherwise Reset/power on reset dont work */
+	
+	/**
+	 * @author Soren Andersen <san@rosetechnology.dk>
+	 * We only do the reset of the PHY operation if there are a power good 
+	 */
+	at91_set_GPIO_periph(AT91_PIN_PE14,1);
+	at91_set_gpio_input(AT91_PIN_PE14,1);	
+	at91_set_gpio_deglitch(AT91_PIN_PE14,1);
+	udelay(100000); //make dure the pin is set up correctly before reading it
+	if(at91_get_gpio_value(AT91_PIN_PE14) == 1) {
+	
+		/* Need to reset PHY -> 500ms reset */
+		writel(AT91_RSTC_KEY | AT91_RSTC_MR_ERSTL(0x0D) |
+			AT91_RSTC_MR_URSTEN, &rstc->mr);
+
+		writel(AT91_RSTC_KEY | AT91_RSTC_CR_EXTRST, &rstc->cr);
+		/* Wait for end hardware reset */
+		while (!(readl(&rstc->sr) & AT91_RSTC_SR_NRSTL))
+			;
+
+		/* Restore NRST value */
+		writel(AT91_RSTC_KEY | erstl | AT91_RSTC_MR_URSTEN, &rstc->mr);
+	} else {
+		printf("POWER FAIL doing PHY initialization\n"); 
+	}
+
+	/* Re-enable pull-up */
+	writel(1 << 25, &pio->pioc.puer);
+	writel((1 << 25) | (1 <<26), &pio->pioe.puer);
+
+	at91_macb_hw_init();
+}
+#endif
+
+#ifdef CONFIG_LCD
+#if defined(CONFIG_70WVW2AZ0) /**< Old Seiko display */
+vidinfo_t panel_info = {
+        vl_col:         800,
+        vl_row:         480,
+        vl_clk:         30000000,
+
+        vl_sync:        ATMEL_LCDC_INVLINE_INVERTED |
+                        ATMEL_LCDC_INVFRAME_INVERTED,
+
+        vl_bpix:        LCD_COLOR16,  
+        vl_tft:         1,  
+        vl_hsync_len:   3,  
+        vl_left_margin: 1,  
+        vl_right_margin:200,
+        vl_vsync_len:   3, 
+        vl_upper_margin:0, 
+        vl_lower_margin:10,
+        mmio:           ATMEL_BASE_LCDC,
+};
+#elif defined(CONFIG_TTFT1280120) /**< Truely horizontal display */ 
+vidinfo_t panel_info = {
+        vl_col:         1280,
+        vl_row:         120,
+        vl_clk:         11000000,
+        vl_sync:        ATMEL_LCDC_INVLINE_INVERTED  |
+                        ATMEL_LCDC_INVFRAME_INVERTED |
+                        ATMEL_LCDC_INVDVAL_INVERTED  |
+                        ATMEL_LCDC_INVCLK_INVERTED,
+        vl_bpix:        3, 
+        vl_tft:         1, 
+        vl_hsync_len:   3, 
+        vl_left_margin: 54,
+        vl_right_margin:54,
+        vl_vsync_len:   3,
+        vl_upper_margin:6,
+        vl_lower_margin:2,
+        mmio:           ATMEL_BASE_LCDC,
+};
+#elif defined(CONFIG_TX18D16VM1CBA) /**< TFT display */
+vidinfo_t panel_info = {
+	vl_col:         800,
+	vl_row:         480,
+	vl_clk:         30000000,
+	                        
+	vl_sync:        ATMEL_LCDC_INVLINE_INVERTED |
+	                ATMEL_LCDC_INVFRAME_INVERTED,
+	vl_bpix:        LCD_COLOR16,
+	vl_tft:         1,  
+	vl_hsync_len:   20,  
+	vl_left_margin: 7,  
+	vl_right_margin:40,
+	vl_vsync_len:   2, 
+	vl_upper_margin:4, 
+	vl_lower_margin:11,
+	mmio:           ATMEL_BASE_LCDC,
+};
+#else 
+vidinfo_t panel_info = {
+	vl_col:		240,
+	vl_row:		320,
+	vl_clk:		4965000,
+	vl_sync:	ATMEL_LCDC_INVLINE_INVERTED |
+			ATMEL_LCDC_INVFRAME_INVERTED,
+	vl_bpix:	3,
+	vl_tft:		1,
+	vl_hsync_len:	5,
+	vl_left_margin:	1,
+	vl_right_margin:33,
+	vl_vsync_len:	1,
+	vl_upper_margin:1,
+	vl_lower_margin:0,
+	mmio:		ATMEL_BASE_LCDC,
+};
+#endif
+
+#ifdef CONFIG_LTTD800480070
+vidinfo_t panel_info_logic = {
+        vl_col:         800,
+        vl_row:         480,
+        vl_clk:         30000000,
+
+        vl_sync:        ATMEL_LCDC_INVLINE_INVERTED |
+                        ATMEL_LCDC_INVFRAME_INVERTED,
+
+        vl_bpix:        LCD_COLOR16,  
+        vl_tft:         1,  
+        vl_hsync_len:   3,  //Atmel calculates: Total Length = Hsync + left marging + picture + right_margin+1 (3+85+800+0+1=889)
+        vl_left_margin: 85,  
+        vl_right_margin:1, 
+        vl_vsync_len:   3, //Atmel calculates: Total Length = upper marging + picture + lower_margin (32+480+1=513) (25MHz / ( 889 * 513 ) = 54,8Hz
+        vl_upper_margin:32, 
+        vl_lower_margin:1,
+        mmio:           ATMEL_BASE_LCDC,
+};
+
+vidinfo_t panel_info_logic_240 = {
+        vl_col:         800,
+        vl_row:         480,
+        vl_clk:         30000000,
+
+        vl_sync:        ATMEL_LCDC_INVLINE_INVERTED |
+                        ATMEL_LCDC_INVFRAME_INVERTED,
+
+        vl_bpix:        LCD_COLOR16,  
+        vl_tft:         1,  
+        vl_hsync_len:   3,  //Atmel calculates: Total Length = Hsync + left marging + picture + right_margin+1 (3+85+800+20+1=909)
+        vl_left_margin: 85,  
+        vl_right_margin:20, 
+        vl_vsync_len:   3, //Atmel calculates: Total Length = upper marging + picture + lower_margin (32+480+38=550) (30MHz / ( 909 * 550 ) = 60Hz
+        vl_upper_margin:32, 
+        vl_lower_margin:38,
+        mmio:           ATMEL_BASE_LCDC,
+};
+
+#endif
+/*
+#ifdef CONFIG_LC7981  
+vidinfo_t lc7981_panel_info = {
+	vl_col:         240,
+        vl_row:         128,
+        };
+#endif
+*/
+
+void lcd_enable(void)
+{
+	at91_set_pio_value(AT91_PIO_PORTA, 30, 1);  /* power up */
+}
+
+void lcd_disable(void)
+{
+	at91_set_pio_value(AT91_PIO_PORTA, 30, 0);  /* power down */
+}
+
+static void at91sam9263_lcd_hw_init(void)
+{
+	at91_pmc_t	*pmc	= (at91_pmc_t *) ATMEL_BASE_PMC;
+	
+	at91_set_a_periph(AT91_PIO_PORTC, 0, 0);     	/* LCDVSYNC */
+	at91_set_a_periph(AT91_PIO_PORTC, 1, 0);	/* LCDHSYNC */
+	at91_set_a_periph(AT91_PIO_PORTC, 2, 0);	/* LCDDOTCK */
+	at91_set_a_periph(AT91_PIO_PORTC, 3, 0);	/* LCDDEN */
+	at91_set_b_periph(AT91_PIO_PORTB, 9, 0);	/* LCDCC */
+	at91_set_a_periph(AT91_PIO_PORTC, 6, 0);	/* LCDD2 */
+	at91_set_a_periph(AT91_PIO_PORTC, 7, 0);	/* LCDD3 */
+	at91_set_a_periph(AT91_PIO_PORTC, 8, 0);	/* LCDD4 */
+	at91_set_a_periph(AT91_PIO_PORTC, 9, 0);	/* LCDD5 */
+	at91_set_a_periph(AT91_PIO_PORTC, 10, 0);	/* LCDD6 */
+	at91_set_a_periph(AT91_PIO_PORTC, 11, 0);	/* LCDD7 */
+	at91_set_a_periph(AT91_PIO_PORTC, 14, 0);	/* LCDD10 */
+	at91_set_a_periph(AT91_PIO_PORTC, 15, 0);	/* LCDD11 */
+	at91_set_a_periph(AT91_PIO_PORTC, 16, 0);	/* LCDD12 */
+	at91_set_b_periph(AT91_PIO_PORTC, 12, 0);	/* LCDD13 */
+	at91_set_a_periph(AT91_PIO_PORTC, 18, 0);	/* LCDD14 */
+	at91_set_a_periph(AT91_PIO_PORTC, 19, 0);	/* LCDD15 */
+	at91_set_a_periph(AT91_PIO_PORTC, 22, 0);	/* LCDD18 */
+	at91_set_a_periph(AT91_PIO_PORTC, 23, 0);	/* LCDD19 */
+	at91_set_a_periph(AT91_PIO_PORTC, 24, 0);	/* LCDD20 */
+	at91_set_b_periph(AT91_PIO_PORTC, 17, 0);	/* LCDD21 */
+	at91_set_a_periph(AT91_PIO_PORTC, 26, 0);	/* LCDD22 */
+	at91_set_a_periph(AT91_PIO_PORTC, 27, 0);	/* LCDD23 */
+
+	writel(1 << ATMEL_ID_LCDC, &pmc->pcer);
+	//gd->fb_base = ATMEL_BASE_SRAM0; /**< Søren Andersen : Too little space */
+        gd->fb_base = 0x23000000;	
+	/**
+	 * @author Martin Bjærre <mab@rosetechnology.dk>	
+         * Added check to see if rev 2 of interface board is used, thus using the Logic Technology display
+         */	
+#ifdef CONFIG_LTTD800480070	
+	at91_set_gpio_input( AT91_PIN_PD2, 1 );
+	udelay(100000); //make dure the pin is set up correctly before reading it
+	if (at91_get_gpio_value(AT91_PIN_PD2)) {
+		/**
+		 * This is the old interface board, as the pin is NC (using Seiko display)
+		 * Do nothing
+		 */
+	}
+	else {
+		/**
+		 * This is the new interface board, as the pin is pulled down (using Logic display)
+		 */
+		panel_info = panel_info_logic;
+		/* enable contrast PWM(1) */
+		writel(1<<AT91_ID_PWM, &pmc->pcer); 
+		at91_set_B_periph(AT91_PIN_PB8, 0);	
+		
+		/** 
+		 * 4.5V = 100% = (4.5-3.0)/ (5.3-3.0) = 65.2% dutycycle
+		 * 3,6V = 0% = (3.6-3.0)/(5.3-3.0) = 26.1% dutycycle
+		 * 65.2%-26.1%=39.1%
+		 * 100 / 0.391 = 256
+		 * 3.6V = 0.261 * 256 = 67
+		 * 4.5V = 0.652 * 256 = 167
+		 * Formula = 67 + contrast%
+		 * Frequency: 100MHz/(32*256)=12.2KHz 
+		 */
+		at91_pwm_write( AT91_PWM_CMR(1), AT91_PWM_CMR_MCK32 | AT91_PWM_CPOL);
+		at91_pwm_write( AT91_PWM_CPRDR(1),  256);
+		
+		if(getenv("tft_contrast") != NULL){
+			at91_pwm_write( AT91_PWM_CDTYR(1), 67 + simple_strtoul(getenv("tft_contrast"), NULL, 10) );	
+		}
+		else {
+			/* Default 3.7V = (3.7-3.0)/(5.3-3.0) = 30.4% = 256 * 0.304 = 78 */
+			at91_pwm_write( AT91_PWM_CDTYR(1), 78 );
+		}
+
+		at91_pwm_write( AT91_PWM_ENA, AT91_PWM_CHID1 );
+		
+	}
+#endif
+}
+
+#if defined(CONFIG_SKOV_CPU_MODULE)
+void check_240(void)
+{
+	if (do_we_have_dataflash())	{
+#ifdef CONFIG_LTTD800480070	
+		if (!at91_get_gpio_value(AT91_PIN_PD2)) {
+			panel_info = panel_info_logic_240;
+		}
+#endif
+	}
+}
+#endif
+
+
+#ifdef CONFIG_LCD_INFO
+#include <nand.h>
+#include <version.h>
+
+#ifndef CONFIG_SYS_NO_FLASH
+extern flash_info_t flash_info[];
+#endif
+
+void lcd_show_board_info(void)
+{
+	ulong dram_size, nand_size;
+#ifndef CONFIG_SYS_NO_FLASH
+	ulong flash_size;
+#endif
+	int i;
+	char temp[32];
+
+	lcd_printf ("%s\n", U_BOOT_VERSION);
+	lcd_printf ("SKOV CPU MODULE\n");
+	lcd_printf ("%s CPU at %s MHz\n",
+		ATMEL_CPU_NAME,
+		strmhz(temp, get_cpu_clk_rate()));
+
+	dram_size = 0;
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		dram_size += gd->bd->bi_dram[i].size;
+	nand_size = 0;
+#ifdef CONFIG_CMD_NAND
+	for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++)
+		nand_size += nand_info[i].size;
+#endif
+#ifndef CONFIG_SYS_NO_FLASH
+	flash_size = 0;
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++)
+		flash_size += flash_info[i].size;
+#endif
+	lcd_printf ("  %ld MB SDRAM, %ld MB NAND",
+		dram_size >> 20,
+		nand_size >> 20 );
+#ifndef CONFIG_SYS_NO_FLASH
+	lcd_printf (",\n  %ld MB NOR",
+		flash_size >> 20);
+#endif
+	lcd_puts ("\n");
+}
+#endif /* CONFIG_LCD_INFO */
+#endif
+
+int board_early_init_f(void)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+
+	/* Enable clocks for all PIOs */
+	writel((1 << ATMEL_ID_PIOA) | (1 << ATMEL_ID_PIOB) |
+		(1 << ATMEL_ID_PIOCDE),
+		&pmc->pcer);
+
+	at91_seriald_hw_init();
+	return 0;
+}
+
+int board_init(void)
+{ 
+	unsigned char i2c_tmp1 = 0, i2c_tmp2 = 0; /**< San Rose */
+	/* arch number of AT91SAM9263EK-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_AT91SAM9263EK;
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+#ifdef CONFIG_CMD_NAND
+	at91sam9263ek_nand_hw_init();
+#endif
+#ifdef CONFIG_HAS_DATAFLASH
+	at91_set_pio_output(AT91_PIO_PORTE, 20, 1);	/* select spi0 clock */
+	at91_spi0_hw_init(1 << 0);
+#endif
+#ifdef CONFIG_MACB
+	at91sam9263ek_macb_hw_init();
+#endif
+#ifdef CONFIG_USB_OHCI_NEW
+	at91_uhp_hw_init();
+#endif
+#ifdef CONFIG_LCD
+	at91sam9263_lcd_hw_init();
+#endif
+	/**
+	 * @author Søren Andersen <san@rosetechnology.dk>
+	 * Since the reads are being performed one byte at a time,
+	 * there is a chance that a carry will occur during the read.
+	 * To detect this, 2 reads are performed and compared.
+	 */                                            
+	at91sam9263_i2c_init();
+
+	/* find out if we hade a m41t82 or ds1374 rtc */
+	i2c_tmp1 = i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, 0x19, 0x45);
+	i2c_tmp2 = i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, 0x19, 0x45);
+	
+	if(i2c_tmp1 == 1 && i2c_tmp2 == 1) { //We dont have an m41t82
+		
+		i2c_tmp1 = i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, 0x07, 0);
+		i2c_tmp2 = i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, 0x07, 0);
+		
+		if(i2c_tmp1 == 0 || i2c_tmp2 == 0) // We have a ds1374
+		{
+			printf("WD: DS1374\n");
+			at91_wdt_t *wd  = (at91_wdt_t *) ATMEL_BASE_WDT;
+			skov_with_ds1374 = 1;	
+			timer_init();
+			//4096 for one secound
+			ds1374_wdt_settimeout(1048576); //->4 minuts
+			writel(AT91_WDT_WDDIS, &wd->mr); //Disable internal wdt
+			wd_init = 1;
+		} else {
+			//No external watchdog
+			skov_with_ds1374 = 0;
+		}
+	} else  {
+		printf("WD: M41T82\n");
+		at91_wdt_t *wd  = (at91_wdt_t *) ATMEL_BASE_WDT;
+		skov_with_m41t82 = 1;
+		timer_init();
+		m41t82_wdt_settimeout(32); //32 sek
+		writel(AT91_WDT_WDDIS, &wd->mr); //Disable internal wdt
+		wd_init = 1;
+	}
+    	if(wd_init == 0) {
+    	    printf("WD: AT91WDT\n");
+    	}
+    	/* End San */
+	return 0;
+}
+
+int dram_init(void)
+{
+	/* ROSE: We will configure the memory size accourding the two values written by the bootstrap */ 
+	volatile unsigned int *test_adr1=(unsigned int*)0x20000000, *test_adr2=(unsigned int*)0x21000000;
+	unsigned int test_val1=(unsigned int)0x534B4F56, test_val2=(unsigned int)0x564F4B53;
+		
+	if((*(test_adr1) == test_val1) && (*(test_adr2) == test_val2))
+	{  	
+		gd->ram_size = get_ram_size((void *)CONFIG_SYS_SDRAM_BASE, 0x08000000); /**< 128MB */
+	}
+	else if((*(test_adr1) == test_val2) && (*(test_adr2) == test_val1))
+	{
+	        gd->ram_size = get_ram_size((void *)CONFIG_SYS_SDRAM_BASE, 0x04000000); /**< 64MB */ 
+	}
+	else 
+	{
+		gd->ram_size = get_ram_size((void *)CONFIG_SYS_SDRAM_BASE, CONFIG_SYS_SDRAM_SIZE); /**< default */
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_RESET_PHY_R
+void reset_phy(void)
+{
+}
+#endif
+
+/**
+ * @author Søren Andersen
+ * Bitbang I2C pins 
+ */
+#define GPIO_I2C_SCL   AT91_PIN_PB5
+#define GPIO_I2C_SDA   AT91_PIN_PB4
+
+void at91sam9263_i2c_init(void)
+{
+        /*
+        at91_pmc_t      *pmc    = (at91_pmc_t *) ATMEL_BASE_PMC;
+        writel(1 << ATMEL_ID_PIOB, &pmc->pcer);
+        */                
+        at91_set_GPIO_periph(GPIO_I2C_SDA, 1); //use pull up
+        at91_set_gpio_multi_drive(GPIO_I2C_SDA, 1);
+                
+        at91_set_gpio_output( GPIO_I2C_SCL, 0 );
+        at91_set_gpio_multi_drive(GPIO_I2C_SCL, 1);
+        at91_set_GPIO_periph(GPIO_I2C_SCL, 1);
+}
+
+void at91sam9263_i2c_scl(unsigned long bit)
+{
+        if(bit) {
+        	at91_set_gpio_value(GPIO_I2C_SCL, 1);
+        }
+        else {
+        	at91_set_gpio_value(GPIO_I2C_SCL, 0);
+        }	
+}
+                                        
+void at91sam9263_i2c_sda(unsigned long bit)
+{
+        if(bit) {
+        	at91_set_gpio_value(GPIO_I2C_SDA, 1);
+        } 
+        else {
+  		at91_set_gpio_value(GPIO_I2C_SDA, 0);      		
+  	}	
+}
+
+int at91sam9263_i2c_read(void)
+{
+        return at91_get_gpio_value(GPIO_I2C_SDA);
+}
+
+void at91sam9263_i2c_active(void)
+{
+	at91_set_gpio_output( GPIO_I2C_SDA, 0 ); //gpio outout with value zero
+	at91_set_gpio_multi_drive( GPIO_I2C_SDA, 1 ); //enable multidrive
+	at91_set_GPIO_periph( GPIO_I2C_SDA, 1 ); //use pull up
+}
+                                                                
+void at91sam9263_i2c_tristate(void)
+{
+	at91_set_gpio_input( GPIO_I2C_SDA, 0 ); // set pin as input without pullup
+	at91_set_gpio_deglitch( GPIO_I2C_SDA, 1 ); // enable glitch filter
+}
+
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_MACB
+	rc = macb_eth_initialize(0, (void *) ATMEL_BASE_EMAC, 0x00);
+#endif
+	return rc;
+}
+
+/** 
+ * @author Søren Andersen <san@rosetechnology.dk> 
+ * Find the I2c chip which is mounted on the board
+ */
+void hw_watchdog_reset(void)
+{
+    //If we have an i2c watchdog -> Use this one
+    if(skov_with_ds1374 == 1 && wd_init == 1)
+    {
+        ds1374_hw_watchdog_reset();    	
+    }
+    else if(skov_with_m41t82 == 1 && wd_init == 1)
+    {
+        m41t82_hw_watchdog_reset();
+    }
+    else
+    {
+        at91_wdt_t *wd  = (at91_wdt_t *) ATMEL_BASE_WDT;
+        writel(AT91_WDT_CR_WDRSTT | AT91_WDT_CR_KEY, &wd->cr);   
+    }
+} 
+/* End San */  
+
+/** 
+ * @author Henrik Steffesen <hbs@rosetechnology.dk>
+ * SPI chip select control 
+ */
+#ifdef CONFIG_ATMEL_SPI
+#include <spi.h>
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return bus == 0 && cs < 1;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch(slave->cs) {
+		case 0:
+		default:
+			at91_set_gpio_output(AT91_PIN_PA5, 0);
+			break;
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch(slave->cs) {
+		case 0:
+		default:
+			at91_set_gpio_output(AT91_PIN_PA5, 1);
+		break;
+	}
+}
+
+#endif /* CONFIG_ATMEL_SPI */
+
diff --git a/boards.cfg b/boards.cfg
index 7c1fc74..eaa71a1 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -101,6 +101,7 @@ at91sam9x5ek_spiflash        arm         arm926ejs   at91sam9x5ek        atmel
 at91sam9xeek_dataflash_cs0   arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9XE,SYS_USE_DATAFLASH_CS0
 at91sam9xeek_dataflash_cs1   arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9XE,SYS_USE_DATAFLASH_CS1
 at91sam9xeek_nandflash       arm         arm926ejs   at91sam9260ek       atmel          at91        at91sam9260ek:AT91SAM9XE,SYS_USE_NANDFLASH
+skov_cpu_module		     arm         arm926ejs   skov_cpu_module	 skov           at91        skov_cpu_module:AT91SAM9263
 snapper9260                  arm         arm926ejs   -                   bluewater      at91        snapper9260:AT91SAM9260
 snapper9g20                  arm         arm926ejs   snapper9260         bluewater      at91        snapper9260:AT91SAM9G20
 vl_ma2sc                     arm         arm926ejs   vl_ma2sc            BuS            at91
diff --git a/common/Makefile b/common/Makefile
index 973f05a..d87e83c 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -61,6 +61,9 @@ COBJS-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
 COBJS-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
 COBJS-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
 
+# Skov environment
+COBJS-$(CONFIG_SKOV_CPU_MODULE) += env_skov_compat.o
+
 # command
 COBJS-$(CONFIG_CMD_AMBAPP) += cmd_ambapp.o
 COBJS-$(CONFIG_SOURCE) += cmd_source.o
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 83fa5d7..6944b5f 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -38,6 +38,10 @@
 #include <asm/byteorder.h>
 #include <linux/compiler.h>
 
+#ifdef CONFIG_RTC_DS1374_WATCHDOG
+#include <ds1374.h>
+#endif
+
 #if defined(CONFIG_CMD_USB)
 #include <usb.h>
 #endif
@@ -622,6 +626,11 @@ int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	if (bootm_start(cmdtp, flag, argc, argv))
 		return 1;
 
+/*PTA ROSE*/
+#ifdef CONFIG_RTC_DS1374_WATCHDOG
+	stop_kicking_the_dog(1);
+#endif
+/*END PTA*/
 	/*
 	 * We have reached the point of no return: we are going to
 	 * overwrite all exception vector code, so we cannot easily
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index e24ed7f..d107691 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -579,7 +579,16 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 			else if (getc() == 'y') {
 				puts("y");
 				if (getc() == '\r')
+					/**
+					 * @author Martin Bjærre <mab@rosetechnology.dk>
+					 * This functionality is removed as it endangers bad block information
+					 *
+					 */
+#ifdef CONFIG_SKOV_CPU_MODULE
+					printf("\n nand scrub functionality has been removed to protect bad block information on skov cpu__module\n");
+#else
 					opts.scrub = 1;
+#endif
 				else {
 					puts("scrub aborted\n");
 					return -1;
@@ -687,7 +696,19 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
 			if (read)
 				ret = nand->read_oob(nand, off, &ops);
 			else
+				/**
+                                 * @author Martin Bjærre <mab@rosetechnology.dk>
+                                 *
+                                 * This functionality is removed as it endangers bad block information
+                                 *
+                                 */
+#ifdef CONFIG_SKOV_CPU_MODULE
+				printf("\n nand write.oob functionality has been removed to protect bad block information.");
+				ret = -1;
+				size = 0;
+#else
 				ret = nand->write_oob(nand, off, &ops);
+#endif
 		} else if (raw) {
 			ret = raw_access(nand, addr, off, pagecount, read);
 		} else {
diff --git a/common/env_dataflash.c b/common/env_dataflash.c
index 3c5af37..a4ae9fd 100644
--- a/common/env_dataflash.c
+++ b/common/env_dataflash.c
@@ -27,11 +27,23 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+extern env_t *env_ptr;
+#else
 env_t *env_ptr;
+#endif
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+char * env_name_spec_dataflash = "dataflash";
+#else
 char *env_name_spec = "dataflash";
+#endif
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+uchar env_get_char_spec_dataflash (int index)
+#else
 uchar env_get_char_spec(int index)
+#endif
 {
 	uchar c;
 
@@ -39,8 +51,11 @@ uchar env_get_char_spec(int index)
 			1, (char *)&c);
 	return c;
 }
-
+#ifdef CONFIG_SKOV_CPU_MODULE
+void env_relocate_spec_dataflash (void)
+#else
 void env_relocate_spec(void)
+#endif
 {
 	char buf[CONFIG_ENV_SIZE];
 
@@ -53,7 +68,11 @@ void env_relocate_spec(void)
 #error No support for redundant environment on dataflash yet!
 #endif
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+int saveenv_dataflash(void)
+#else
 int saveenv(void)
+#endif
 {
 	env_t	env_new;
 	ssize_t	len;
@@ -78,7 +97,11 @@ int saveenv(void)
  * We are still running from ROM, so data use is limited.
  * Use a (moderately small) buffer on the stack
  */
+#ifdef CONFIG_SKOV_CPU_MODULE
+int env_init_dataflash(void)
+#else
 int env_init(void)
+#endif
 {
 	ulong crc, len = ENV_SIZE, new = 0;
 	unsigned off;
@@ -86,10 +109,15 @@ int env_init(void)
 
 	if (gd->env_valid)
 		return 0;
-
+/**
+ * @autor Søren Andersen
+ * The Bootstrap had already initialized the flash
+ */
+#if !defined(CONFIG_SKOV_CPU_MODULE)		
 	AT91F_DataflashInit();	/* prepare for DATAFLASH read/write */
-
+#endif
 	/* read old CRC */
+
 	read_dataflash(CONFIG_ENV_ADDR + offsetof(env_t, crc),
 		sizeof(ulong), (char *)&crc);
 
diff --git a/common/env_flash.c b/common/env_flash.c
index aa970d4..00c6844 100644
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -24,7 +24,7 @@
  * MA 02111-1307 USA
  */
 
-/* #define DEBUG */
+//#define DEBUG
 
 #include <common.h>
 #include <command.h>
@@ -40,30 +40,53 @@ DECLARE_GLOBAL_DATA_PTR;
 #define CMD_SAVEENV
 #elif defined(CONFIG_ENV_ADDR_REDUND)
 #error CONFIG_ENV_ADDR_REDUND must have CONFIG_CMD_SAVEENV & CONFIG_CMD_FLASH
-#endif
+#endif /* CONFIG_CMD_SAVEENV || CONFIG_CMD_FLASH */
 
 #if defined(CONFIG_ENV_SIZE_REDUND) &&	\
 	(CONFIG_ENV_SIZE_REDUND < CONFIG_ENV_SIZE)
 #error CONFIG_ENV_SIZE_REDUND should not be less then CONFIG_ENV_SIZE
-#endif
+#endif /* CONFIG_ENV_SIZE_REDUND */
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+char *env_name_spec_flash = "Flash";
+#else
 char *env_name_spec = "Flash";
+#endif  /* CONFIG_SKOV_CPU_MODULE */
 
 #ifdef ENV_IS_EMBEDDED
 env_t *env_ptr = &environment;
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+static env_t *flash_addr = (env_t *)CONFIG_ENV_ADDR_FLASH; /**< Martin Bjærre: Changed CONFIG_ENV_ADDR to CONFIG_ENV_ADDR_FLASH */
+#else
 static env_t *flash_addr = (env_t *)CONFIG_ENV_ADDR;
+#endif /* CONFIG_SKOV_CPU_MODULE */
 
 #else /* ! ENV_IS_EMBEDDED */
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+extern env_t *env_ptr; /**< Martin Bjærre: env_t is now located in env_skov_compat. */
+#else
 env_t *env_ptr = (env_t *)CONFIG_ENV_ADDR;
+#endif /* CONFIG_SKOV_CPU_MODULE */
+
+#ifdef CONFIG_SKOV_CPU_MODULE
+static env_t *flash_addr = (env_t *)CONFIG_ENV_ADDR_FLASH;
+#else
 static env_t *flash_addr = (env_t *)CONFIG_ENV_ADDR;
+#endif /* CONFIG_SKOV_CPU_MODULE */
+
 #endif /* ENV_IS_EMBEDDED */
 
 #if defined(CMD_SAVEENV) || defined(CONFIG_ENV_ADDR_REDUND)
+#ifdef CONFIG_SKOV_CPU_MODULE
+//Rose/Mab: Changed CONFIG_ENV_ADDR to CONFIG_ENV_ADDR_FLASH
+static ulong end_addr = CONFIG_ENV_ADDR_FLASH + CONFIG_ENV_SECT_SIZE_FLASH - 1;
+#else
 /* CONFIG_ENV_ADDR is supposed to be on sector boundary */
 static ulong end_addr = CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1;
-#endif
+#endif /* CONFIG_SKOV_CPU_MODULE */
+#endif /* CMD_SAVEENV || CONFIG_ENV_ADDR_REDUND */
 
 #ifdef CONFIG_ENV_ADDR_REDUND
 static env_t *flash_addr_new = (env_t *)CONFIG_ENV_ADDR_REDUND;
@@ -74,7 +97,11 @@ static ulong end_addr_new = CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SECT_SIZE - 1;
 
 
 #ifdef CONFIG_ENV_ADDR_REDUND
+#ifdef CONFIG_SKOV_CPU_MODULE
+int env_init_flash(void)
+#else
 int env_init(void)
+#endif /* CONFIG_SKOV_CPU_MODULE */
 {
 	int crc1_ok = 0, crc2_ok = 0;
 
@@ -85,10 +112,14 @@ int env_init(void)
 	ulong addr1 = (ulong)&(flash_addr->data);
 	ulong addr2 = (ulong)&(flash_addr_new->data);
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+	crc1_ok = (crc32(0, flash_addr->data, ENV_SIZE_FLASH) == flash_addr->crc);
+	crc2_ok = (crc32(0, flash_addr_new->data, ENV_SIZE_FLASH) == flash_addr_new->crc);
+#else
 	crc1_ok = crc32(0, flash_addr->data, ENV_SIZE) == flash_addr->crc;
 	crc2_ok =
 		crc32(0, flash_addr_new->data, ENV_SIZE) == flash_addr_new->crc;
-
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	if (crc1_ok && !crc2_ok) {
 		gd->env_addr	= addr1;
 		gd->env_valid	= 1;
@@ -119,17 +150,20 @@ int env_init(void)
 }
 
 #ifdef CMD_SAVEENV
+#ifdef CONFIG_SKOV_CPU_MODULE
+int saveenv_flash(void)
+#else
 int saveenv(void)
+#endif /* CONFIG_SKOV_CPU_MODULE */
 {
 	env_t	env_new;
 	ssize_t	len;
 	char	*res, *saved_data = NULL;
 	char	flag = OBSOLETE_FLAG, new_flag = ACTIVE_FLAG;
 	int	rc = 1;
-#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
-	ulong	up_data = 0;
-#endif
-
+#if defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) || !defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE_FLASH)
+        ulong   up_data = 0;
+#endif /* (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) */
 	debug("Protect off %08lX ... %08lX\n", (ulong)flash_addr, end_addr);
 
 	if (flash_sect_protect(0, (ulong)flash_addr, end_addr))
@@ -142,16 +176,28 @@ int saveenv(void)
 		goto done;
 
 	res = (char *)&env_new.data;
+#ifdef CONFIG_SKOV_CPU_MODULE
+        len = hexport_r(&env_htab, '\0', &res, ENV_SIZE_FLASH, 0, NULL);
+#else
 	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, 0, NULL);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	if (len < 0) {
 		error("Cannot export environment: errno = %d\n", errno);
 		goto done;
 	}
-	env_new.crc	= crc32(0, env_new.data, ENV_SIZE);
+#ifdef CONFIG_SKOV_CPU_MODULE
+	env_new.crc	= crc32(0, env_new.data, ENV_SIZE_FLASH);
+#else
+        env_new.crc     = crc32(0, env_new.data, ENV_SIZE);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	env_new.flags	= new_flag;
 
-#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+#if defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) || !defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE_FLASH)
+#ifdef CONFIG_SKOV_CPU_MODULE
+        up_data = end_addr_new + 1 - ((long)flash_addr_new + CONFIG_ENV_SIZE_FLASH);
+#else
 	up_data = end_addr_new + 1 - ((long)flash_addr_new + CONFIG_ENV_SIZE);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	debug("Data to save 0x%lX\n", up_data);
 	if (up_data) {
 		saved_data = malloc(up_data);
@@ -161,13 +207,22 @@ int saveenv(void)
 			goto done;
 		}
 		memcpy(saved_data,
+#ifdef CONFIG_SKOV_CPU_MODULE
+			(void *)((long)flash_addr_new + CONFIG_ENV_SIZE_FLASH), up_data);
+#else
 			(void *)((long)flash_addr_new + CONFIG_ENV_SIZE),
 			up_data);
+#endif /* CONFIG_SKOV_CPU_MODULE */			
 		debug("Data (start 0x%lX, len 0x%lX) saved at 0x%p\n",
+#ifdef CONFIG_SKOV_CPU_MODULE
+                        (long)flash_addr_new + CONFIG_ENV_SIZE_FLASH,
+                                                up_data, saved_data);
+#else
 			(long)flash_addr_new + CONFIG_ENV_SIZE,
 			up_data, saved_data);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	}
-#endif
+#endif /* (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) */
 	puts("Erasing Flash...");
 	debug(" %08lX ... %08lX ...", (ulong)flash_addr_new, end_addr_new);
 
@@ -188,16 +243,24 @@ int saveenv(void)
 	if (rc)
 		goto perror;
 
-#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+#if defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) || !defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE_FLASH)
 	if (up_data) { /* restore the rest of sector */
 		debug("Restoring the rest of data to 0x%lX len 0x%lX\n",
+#ifdef CONFIG_SKOV_CPU_MODULE
+                        (long)flash_addr_new + CONFIG_ENV_SIZE_FLASH, up_data);
+#else
 			(long)flash_addr_new + CONFIG_ENV_SIZE, up_data);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 		if (flash_write(saved_data,
-				(long)flash_addr_new + CONFIG_ENV_SIZE,
-				up_data))
+#ifdef CONFIG_SKOV_CPU_MODULE
+                                (long)flash_addr_new + CONFIG_ENV_SIZE_FLASH, up_data))
+#else				
+                                (long)flash_addr_new + CONFIG_ENV_SIZE,
+                                up_data))
+#endif /* CONFIG_SKOV_CPU_MODULE */
 			goto perror;
 	}
-#endif
+#endif /* (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) */
 	puts("done\n");
 
 	{
@@ -228,7 +291,11 @@ done:
 
 #else /* ! CONFIG_ENV_ADDR_REDUND */
 
+#ifdef CONFIG_SKOV_CPU_MODULE
+int env_init_flash(void)
+#else
 int env_init(void)
+#endif /* CONFIG_SKOV_CPU_MODULE */
 {
 	if (crc32(0, env_ptr->data, ENV_SIZE) == env_ptr->crc) {
 		gd->env_addr	= (ulong)&(env_ptr->data);
@@ -242,16 +309,23 @@ int env_init(void)
 }
 
 #ifdef CMD_SAVEENV
+#ifdef CONFIG_SKOV_CPU_MODULE
+int saveenv_flash(void)
+#else
 int saveenv(void)
+#endif /* CONFIG_SKOV_CPU_MODULE */
 {
 	env_t	env_new;
 	ssize_t	len;
 	int	rc = 1;
 	char	*res, *saved_data = NULL;
-#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+#if defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) || !defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE_FLASH)
 	ulong	up_data = 0;
-
+#ifdef CONFIG_SKOV_CPU_MODULE
+        up_data = end_addr + 1 - ((long)flash_addr + CONFIG_ENV_SIZE_FLASH);
+#else
 	up_data = end_addr + 1 - ((long)flash_addr + CONFIG_ENV_SIZE);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	debug("Data to save 0x%lx\n", up_data);
 	if (up_data) {
 		saved_data = malloc(up_data);
@@ -261,46 +335,76 @@ int saveenv(void)
 			goto done;
 		}
 		memcpy(saved_data,
+#ifdef CONFIG_SKOV_CPU_MODULE
+                        (void *)((long)flash_addr + CONFIG_ENV_SIZE_FLASH), up_data); 
+#else
 			(void *)((long)flash_addr + CONFIG_ENV_SIZE), up_data);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 		debug("Data (start 0x%lx, len 0x%lx) saved at 0x%lx\n",
-			(ulong)flash_addr + CONFIG_ENV_SIZE,
-			up_data,
-			(ulong)saved_data);
+#ifdef CONFIG_SKOV_CPU_MODULE
+                        (ulong)flash_addr + CONFIG_ENV_SIZE_FLASH, up_data, (ulong)saved_data);
+#else
+			(ulong)flash_addr + CONFIG_ENV_SIZE, up_data, (ulong)saved_data);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	}
-#endif	/* CONFIG_ENV_SECT_SIZE */
-
+#endif	/* (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) */
 	debug("Protect off %08lX ... %08lX\n", (ulong)flash_addr, end_addr);
 
-	if (flash_sect_protect(0, (long)flash_addr, end_addr))
+	if (flash_sect_protect(0, (long)flash_addr, end_addr)) {
 		goto done;
-
+	}	
 	res = (char *)&env_new.data;
+#ifdef CONFIG_SKOV_CPU_MODULE
+        len = hexport_r(&env_htab, '\0', &res, ENV_SIZE_FLASH, 0, NULL);
+#else
 	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, 0, NULL);
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	if (len < 0) {
 		error("Cannot export environment: errno = %d\n", errno);
 		goto done;
 	}
+#ifdef CONFIG_SKOV_CPU_MODULE
+        env_new.crc = crc32(0, env_new.data, ENV_SIZE_FLASH);
+#else
 	env_new.crc = crc32(0, env_new.data, ENV_SIZE);
-
+#endif /* CONFIG_SKOV_CPU_MODULE */
 	puts("Erasing Flash...");
+
 	if (flash_sect_erase((long)flash_addr, end_addr))
 		goto done;
 
 	puts("Writing to Flash... ");
+
+#ifdef CONFIG_SKOV_CPU_MODULE
+        rc = flash_write((char *)&env_new, (long)flash_addr, CONFIG_ENV_SIZE_FLASH);
+#else
 	rc = flash_write((char *)&env_new, (long)flash_addr, CONFIG_ENV_SIZE);
+#endif /* CONFIG_SKOV_CPU_MODULE */
+
 	if (rc != 0)
 		goto perror;
-
-#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+#if defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) || !defined(CONFIG_SKOV_CPU_MODULE) && (CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE_FLASH)
 	if (up_data) {	/* restore the rest of sector */
 		debug("Restoring the rest of data to 0x%lx len 0x%lx\n",
+#ifdef CONFIG_SKOV_CPU_MODULE
+                        (ulong)flash_addr + CONFIG_ENV_SIZE_FLASH, up_data);
+#else
 			(ulong)flash_addr + CONFIG_ENV_SIZE, up_data);
-		if (flash_write(saved_data,
-				(long)flash_addr + CONFIG_ENV_SIZE,
-				up_data))
-			goto perror;
-	}
-#endif
+#endif /* CONFIG_SKOV_CPU_MODULE */
+
+
+#ifdef CONFIG_SKOV_CPU_MODULE
+                if (flash_write(saved_data, (long)flash_addr + CONFIG_ENV_SIZE_FLASH, up_data)) {
+                        goto perror;
+                }
+#else
+		if (flash_write(saved_data, (long)flash_addr + CONFIG_ENV_SIZE, up_data)) {
+		        goto perror;
+		}
+#endif /* CONFIG_SKOV_CPU_MODULE */
+
+    	}
+#endif /* (CONFIG_ENV_SECT_SIZE_FLASH > CONFIG_ENV_SIZE_FLASH) */
 	puts("done\n");
 	rc = 0;
 	goto done;
@@ -316,8 +420,11 @@ done:
 #endif /* CMD_SAVEENV */
 
 #endif /* CONFIG_ENV_ADDR_REDUND */
-
+#ifdef CONFIG_SKOV_CPU_MODULE
+void env_relocate_spec_flash(void)
+#else
 void env_relocate_spec(void)
+#endif /* CONFIG_SKOV_CPU_MODULE */
 {
 #ifdef CONFIG_ENV_ADDR_REDUND
 	if (gd->env_addr != (ulong)&(flash_addr->data)) {
@@ -332,7 +439,11 @@ void env_relocate_spec(void)
 	}
 
 	if (flash_addr_new->flags != OBSOLETE_FLAG &&
+#ifdef CONFIG_SKOV_CPU_MODULE
+            crc32(0, flash_addr_new->data, ENV_SIZE_FLASH) == flash_addr_new->crc) {
+#else
 	    crc32(0, flash_addr_new->data, ENV_SIZE) == flash_addr_new->crc) {
+#endif /* CONFIG_SKOV_CPU_MODULE */
 		char flag = OBSOLETE_FLAG;
 
 		gd->env_valid = 2;
diff --git a/common/env_skov_compat.c b/common/env_skov_compat.c
new file mode 100644
index 0000000..8d988c3
--- /dev/null
+++ b/common/env_skov_compat.c
@@ -0,0 +1,89 @@
+/**
+ * @file
+ * @author Martin bjærre <mab@rosetechnology.dk>
+ */
+#include <common.h>
+#include <environment.h>
+
+
+static char has_dataflash = 0;
+extern char * env_name_spec_dataflash;
+extern char * env_name_spec_flash;
+
+
+char *env_name_spec;
+env_t *env_ptr = (env_t *)CONFIG_ENV_ADDR_FLASH;
+
+
+void set_has_dataflash(int found)
+{
+	if (found == 1)
+	{
+		has_dataflash = 1;
+		env_name_spec = env_name_spec_dataflash;
+	}
+	else
+	{
+		has_dataflash = 0;
+		env_name_spec = env_name_spec_flash;
+	}
+}
+
+int do_we_have_dataflash(void)
+{
+	return has_dataflash;
+}
+
+
+//extern uchar env_get_char_spec_flash (int index);
+extern uchar env_get_char_spec_dataflash (int index);
+uchar env_get_char_spec (int index)
+{
+	if (has_dataflash)
+	{
+		return env_get_char_spec_dataflash(index);
+	}
+}
+
+extern void env_relocate_spec_flash(void);
+extern void env_relocate_spec_dataflash(void);
+void env_relocate_spec (void)
+{
+	if (has_dataflash)
+	{
+		env_relocate_spec_dataflash();
+	}
+	else
+	{
+		env_relocate_spec_flash();
+	}
+}
+
+extern int saveenv_flash(void);
+extern int saveenv_dataflash(void);
+int saveenv(void)
+{
+	if (has_dataflash == 1)
+	{
+		return saveenv_dataflash();
+	}
+	else
+	{
+		return saveenv_flash();
+	}
+}
+
+extern int env_init_flash(void);
+extern int env_init_dataflash(void);
+int env_init(void)
+{
+	if (has_dataflash)
+	{
+		return env_init_dataflash();
+	}
+	else
+	{
+		return env_init_flash();
+	}
+}
+
diff --git a/common/flash.c b/common/flash.c
index 8244ba2..9a0a0d7 100644
--- a/common/flash.c
+++ b/common/flash.c
@@ -28,6 +28,7 @@
 
 #if !defined(CONFIG_SYS_NO_FLASH)
 #include <mtd/cfi_flash.h>
+#include <watchdog.h> /**< Søren Andersen <san@rosetechnology.dk> Add watchdog support */
 
 extern flash_info_t  flash_info[]; /* info for FLASH chips */
 
@@ -175,6 +176,7 @@ flash_write (char *src, ulong addr, ulong cnt)
 	for (info = info_first; info <= info_last && cnt>0; ++info) {
 		ulong len;
 
+		WATCHDOG_RESET(); /**< Søren Andersen: Watchdog should not reset doing writes, which takes more than 16 sek */
 		len = info->start[0] + info->size - addr;
 		if (len > cnt)
 			len = cnt;
diff --git a/common/lcd.c b/common/lcd.c
index b6be800..97eee0a 100644
--- a/common/lcd.c
+++ b/common/lcd.c
@@ -27,7 +27,8 @@
 /* ** HEADER FILES							*/
 /************************************************************************/
 
-/* #define DEBUG */
+//#define DEBUG 
+
 
 #include <config.h>
 #include <common.h>
@@ -40,6 +41,7 @@
 #endif
 #include <lcd.h>
 #include <watchdog.h>
+#include <lc7981.h> /**< Søren Andersen <san@rosetechnology.dk> */
 
 #if defined(CONFIG_CPU_PXA25X) || defined(CONFIG_CPU_PXA27X) || \
 	defined(CONFIG_CPU_MONAHANS)
@@ -330,7 +332,19 @@ int drv_lcd_init (void)
 {
 	struct stdio_dev lcddev;
 	int rc;
-
+/**
+ * @author Søren Andersen san@rosetechnology.dk> 
+ * Old matrax displays vary in size, The size is set in the enviroment variable
+ */
+#ifdef CONFIG_CMD_LCD
+        if(getenv("lcd_width") != NULL) {
+        	panel_info.vl_col = simple_strtoul(getenv("lcd_width"), NULL, 10);
+	}
+	if(getenv("lcd_height") != NULL) {
+		panel_info.vl_row = simple_strtoul(getenv("lcd_height"), NULL, 10);
+	}	
+#endif /* CONFIG_CMD_LCD */
+/* End San */
 	lcd_base = (void *)(gd->fb_base);
 
 	lcd_line_length = (panel_info.vl_col * NBITS (panel_info.vl_bpix)) / 8;
@@ -354,13 +368,21 @@ int drv_lcd_init (void)
 /*----------------------------------------------------------------------*/
 static
 int do_lcd_clear(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
-{
+{	
 	lcd_clear();
 	return 0;
 }
 
 void lcd_clear(void)
 {
+/** 
+ * @author Søren Andersen <san@rosetehnology.dk>
+ * Get the lcd type to evalute what action to take.
+ */	
+        char *lcdtype = NULL;
+	lcdtype = getenv("lcdtype");
+/* End San */
+	
 #if LCD_BPP == LCD_MONOCHROME
 	/* Setting the palette */
 	lcd_initcolregs();
@@ -387,13 +409,29 @@ void lcd_clear(void)
 #endif	/* CONFIG_SYS_WHITE_ON_BLACK */
 
 #ifdef	LCD_TEST_PATTERN
+#ifdef CONFIG_LC7981  
+        if(strncmp(lcdtype,"matrix",6) == 0) {
+        	//
+	} else {
+		test_pattern();
+	}
+#else
 	test_pattern();
+#endif /* CONFIG_LC7981 */	
+#else /* LCD_TEST_PATTERN */
+#ifdef CONFIG_LC7981
+	if(strncmp(lcdtype,"matrix",6) == 0) {
+		lc7981_clear();
+	} else {	
+		/* set framebuffer to background color */
+		memset((char *)lcd_base,
+		   COLOR_MASK(lcd_getbgcolor()),
+	 	   lcd_line_length*panel_info.vl_row);
+	}
 #else
-	/* set framebuffer to background color */
-	memset((char *)lcd_base,
-		COLOR_MASK(lcd_getbgcolor()),
-		lcd_line_length*panel_info.vl_row);
-#endif
+	memset((char *)lcd_base, COLOR_MASK(lcd_getbgcolor()), lcd_line_length*panel_info.vl_row);
+#endif /* CONFIG_LC7981 */
+#endif /* LCD_TEST_PATTERN */
 	/* Paint the logo and retrieve LCD base address */
 	debug("[LCD] Drawing the logo...\n");
 	lcd_console_address = lcd_logo ();
@@ -412,14 +450,30 @@ U_BOOT_CMD(
 
 static int lcd_init(void *lcdbase)
 {
+	char *lcdtype = NULL;
+	lcdtype = getenv("lcdtype"); /**< Søren Andersen zsan@rosetechnology.dk> */
 	/* Initialize the lcd controller */
 	debug("[LCD] Initializing LCD frambuffer at %p\n", lcdbase);
-
+#ifdef CONFIG_LC7981
+if(strncmp(lcdtype,"matrix",6) == 0) {
+		lc7981_ctrl_init ();
+        } else {
+		lcd_ctrl_init(lcdbase);
+	}
+#else
 	lcd_ctrl_init(lcdbase);
+#endif /* CONFIG_LC7981 */
 	lcd_is_enabled = 1;
 	lcd_clear();
+#ifdef CONFIG_LC7981
+	if(strncmp(lcdtype,"matrix",6) == 0) {
+		lc7981_enable ();
+	} else {
+		lcd_enable ();
+	}
+#else	
 	lcd_enable ();
-
+#endif /* CONFIG_LC7981 */
 	/* Initialize the console */
 	console_col = 0;
 #ifdef CONFIG_LCD_INFO_BELOW_LOGO
@@ -523,6 +577,7 @@ static inline ushort *configuration_get_cmap(void)
 #ifdef CONFIG_LCD_LOGO
 void bitmap_plot(int x, int y)
 {
+	char *lcdtype = NULL; /**< Søren Andersen <san@rosetechnology.dk> */
 #ifdef CONFIG_ATMEL_LCD
 	uint *cmap = (uint *)bmp_logo_palette;
 #else
@@ -536,7 +591,7 @@ void bitmap_plot(int x, int y)
 	immap_t *immr = (immap_t *) CONFIG_SYS_IMMR;
 	cpm8xx_t *cp = &(immr->im_cpm);
 #endif
-
+        lcdtype = getenv("lcdtype"); /**< Søren Andersen <san@rosetechnology.dk> */
 	debug("Logo: width %d  height %d  colors %d  cmap %d\n",
 		BMP_LOGO_WIDTH, BMP_LOGO_HEIGHT, BMP_LOGO_COLORS,
 		ARRAY_SIZE(bmp_logo_palette));
@@ -573,7 +628,7 @@ void bitmap_plot(int x, int y)
 			lut_entry = ((colreg & 0x000F) << 1) |
 					((colreg & 0x00F0) << 3) |
 					((colreg & 0x0F00) << 4);
-#endif
+#endif /* CONFIG_ATMEL_LCD_RGB565 */
 			*(cmap + BMP_LOGO_OFFSET) = lut_entry;
 			cmap++;
 #else /* !CONFIG_ATMEL_LCD */
@@ -588,9 +643,21 @@ void bitmap_plot(int x, int y)
 		WATCHDOG_RESET();
 
 		for (i = 0; i < BMP_LOGO_HEIGHT; ++i) {
+#ifdef CONFIG_LC7981
+                        if(strncmp(lcdtype,"matrix",6) == 0) {
+                        	lcd_set_addr(i*panel_info.vl_col/8);
+                                for(j = 0; j < BMP_LOGO_WIDTH/8; j++) {
+                                	lcd_write_data(bmap[j]);
+                                }
+                        } else { 
+                        	memcpy (fb, bmap, BMP_LOGO_WIDTH);
+                        	fb   += panel_info.vl_col;
+                        }
+#else                                                                                                                                                                                                                                			
 			memcpy(fb, bmap, BMP_LOGO_WIDTH);
-			bmap += BMP_LOGO_WIDTH;
 			fb   += panel_info.vl_col;
+#endif /* CONFIG_LC7981 */
+			bmap += BMP_LOGO_WIDTH;
 		}
 	}
 	else { /* true color mode */
@@ -599,13 +666,33 @@ void bitmap_plot(int x, int y)
 		for (i = 0; i < BMP_LOGO_HEIGHT; ++i) {
 			for (j = 0; j < BMP_LOGO_WIDTH; j++) {
 				col16 = bmp_logo_palette[(bmap[j]-16)];
+
+#ifdef CONFIG_ATMEL_LCD_BGR555
+				fb16[j] =
+					((col16 & 0x000F) << 11) |
+					((col16 & 0x00F0) <<  2) |
+					((col16 & 0x0F00) >>  7);
+#else
+
 				fb16[j] =
 					((col16 & 0x000F) << 1) |
 					((col16 & 0x00F0) << 3) |
 					((col16 & 0x0F00) << 4);
+#endif /* CONFIG_ATMEL_LCD_BGR555 */
 				}
-			bmap += BMP_LOGO_WIDTH;
+#ifdef CONFIG_LC7981
+			if(strncmp(lcdtype,"matrix",6) == 0) {
+				lcd_set_addr(i*panel_info.vl_col/8);
+				for(j = 0; j < BMP_LOGO_WIDTH/8; j++) {
+				        lcd_write_data(bmap[j]);
+				}
+			} else {
+				fb16 += panel_info.vl_col;
+			}
+#else
 			fb16 += panel_info.vl_col;
+#endif /* CONFIG_LC7981*/	
+			bmap += BMP_LOGO_WIDTH;
 		}
 	}
 
@@ -667,6 +754,11 @@ static inline void fb_put_word(uchar **fb, uchar **from)
 
 int lcd_display_bitmap(ulong bmp_image, int x, int y)
 {
+	char *lcdtype = NULL; /**< Søren Andersen */
+#ifdef CONFIG_LC7981
+	short k, l;
+#endif
+
 #if !defined(CONFIG_MCC200)
 	ushort *cmap = NULL;
 #endif
@@ -693,23 +785,37 @@ int lcd_display_bitmap(ulong bmp_image, int x, int y)
 	colors = 1 << bmp_bpix;
 
 	bpix = NBITS(panel_info.vl_bpix);
+	
+	lcdtype = getenv("lcdtype"); /**< The picture for lc7981 expect 1 pixel, but the system want 16 bit pixel */
+#ifdef CONFIG_LC7981
+	if(strncmp(lcdtype,"matrix",6) == 0) {
+	} else {
+#endif
+		if ((bpix != 1) && (bpix != 8) && (bpix != 16) && (bpix != 32)) {
+			printf ("Error: %d bit/pixel mode, but BMP has %d bit/pixel\n",
+				bpix, bmp_bpix);
 
-	if ((bpix != 1) && (bpix != 8) && (bpix != 16) && (bpix != 32)) {
-		printf ("Error: %d bit/pixel mode, but BMP has %d bit/pixel\n",
-			bpix, bmp_bpix);
-
-		return 1;
+			return 1;
+		}
+#ifdef CONFIG_LC7981
 	}
+#endif	
 
 	/* We support displaying 8bpp BMPs on 16bpp LCDs */
-	if (bpix != bmp_bpix && (bmp_bpix != 8 || bpix != 16 || bpix != 32)) {
-		printf ("Error: %d bit/pixel mode, but BMP has %d bit/pixel\n",
-			bpix,
-			le16_to_cpu(bmp->header.bit_count));
-
-		return 1;
-	}
-
+#ifdef CONFIG_LC7981
+	if(strncmp(lcdtype,"matrix",6) == 0) {
+        } else {
+#endif 
+		if (bpix != bmp_bpix && (bmp_bpix != 8 || bpix != 16 || bpix != 32)) {
+			printf ("Error: %d bit/pixel mode, but BMP has %d bit/pixel\n",
+				bpix,
+				le16_to_cpu(bmp->header.bit_count));
+
+			return 1;
+		}
+#ifdef CONFIG_LC7981
+	}	
+#endif
 	debug("Display-bmp: %d x %d  with %d colors\n",
 		(int)width, (int)height, (int)colors);
 
@@ -761,7 +867,14 @@ int lcd_display_bitmap(ulong bmp_image, int x, int y)
 		pwidth= ((pwidth + 7) & ~7) >> 3;
 	}
 #endif
-
+/* San Rose */
+#ifdef CONFIG_LC7981
+        if(strncmp(lcdtype,"matrix",6) == 0) {	
+        	width = ((width + 7) & ~7) >> 3;
+                x     = ((x + 7) & ~7) >> 3;
+                pwidth= ((pwidth + 7) & ~7) >> 3;
+        }        
+#endif
 	padded_line = (width&0x3) ? ((width&~0x3)+4) : (width);
 
 #ifdef CONFIG_SPLASH_SCREEN_ALIGN
@@ -780,6 +893,37 @@ int lcd_display_bitmap(ulong bmp_image, int x, int y)
 
 	switch (bmp_bpix) {
 	case 1: /* pass through */
+#ifdef CONFIG_LC7981
+        if(strncmp(lcdtype,"matrix",6) == 0) {
+        	lc7981_clear();
+        	/* We are swapping the byte because this display expect the byte order to be different from normal */
+        	//debug("h w col row %i %i %i %i\n", height, width, panel_info.vl_col, panel_info.vl_row);
+        	if (height != le32_to_cpu (bmp->header.height)){
+			bmap += (le32_to_cpu (bmp->header.height) - height) * (le32_to_cpu (bmp->header.width))/8;
+		}
+		for (l = height -1; l >= 0; l--) {
+			WATCHDOG_RESET();
+			lcd_set_addr((l+y)*panel_info.vl_col/8 + x);
+			for (k = 0; k < width; k++) {
+                		uchar temp = *(bmap++);
+                		temp = (temp & 0x55) << 1 | (temp & 0xAA) >> 1;
+                		temp = (temp & 0x33) << 2 | (temp & 0xCC) >> 2;
+                		temp = (temp & 0x0F) << 4 | (temp & 0xF0) >> 4;
+                		/* If first pixel is zero-> the image is inverted bit wise*/  
+                		if(bmp->color_table[0].blue == 0) {
+                        		lcd_write_data(~temp);   
+				} else {
+                        		lcd_write_data(temp);
+				}
+			}
+			bmap += (le32_to_cpu (bmp->header.width))/8 - width;
+			if((le32_to_cpu(bmp->header.width)/8)%4 != 0) {
+                		bmap += (4 - (le32_to_cpu(bmp->header.width)/8)%4);
+			}
+		}
+        }
+        break;                                                                                                                                                                                                                                                                                                                                                                                                                          
+#endif
 	case 8:
 		if (bpix != 16)
 			byte_width = width;
@@ -803,11 +947,19 @@ int lcd_display_bitmap(ulong bmp_image, int x, int y)
 
 #if defined(CONFIG_BMP_16BPP)
 	case 16:
+		/*debug("h w col row lmargin rmargin umargin lmargin hsync vsync %i %i %i %i %i %i %i %i %i %i\n", height, width, panel_info.vl_col, panel_info.vl_row, panel_info.vl_left_margin, panel_info.vl_right_margin,
+		panel_info.vl_upper_margin, panel_info.vl_lower_margin, panel_info.vl_hsync_len ,panel_info.vl_vsync_len); */
 		for (i = 0; i < height; ++i) {
 			WATCHDOG_RESET();
-			for (j = 0; j < width; j++)
+			for (j = 0; j < width; j++) {
+#if defined(CONFIG_ATMEL_LCD_BGR555)
+				*(fb++) = (bmap[0] & 0xe0) | ((bmap[1] & 0x7c) >> 2);
+				*(fb++) = ((bmap[0] & 0x1f) << 2) | (bmap[1] & 0x03);
+				bmap += 2;
+#else
 				fb_put_word(&fb, &bmap);
-
+#endif //defined(CONFIG_ATMEL_LCD_BGR555)			
+			}
 			bmap += (padded_line - width) * 2;
 			fb   -= (width * 2 + lcd_line_length);
 		}
diff --git a/common/main.c b/common/main.c
index 9507cec..e204e09 100644
--- a/common/main.c
+++ b/common/main.c
@@ -40,6 +40,14 @@
 #include <hush.h>
 #endif
 
+/**
+ * @author Martin Bjærre <mab@rosetechnology.dk>
+ * Rose add:
+ */
+#ifdef SKOV_CPU_MODULE
+extern int do_we_have_dataflash(void);
+#endif
+
 #include <post.h>
 #include <linux/ctype.h>
 #include <menu.h>
@@ -218,6 +226,20 @@ static inline
 int abortboot(int bootdelay)
 {
 	int abort = 0;
+/**
+ * @author Martin Bjærre <mab@rosetechnology.dk>
+ * Set env variable if we have nand
+ */
+#ifdef CONFIG_SKOV_CPU_MODULE
+	if (do_we_have_dataflash() == 1)
+	{
+		setenv("hasnand", "true");
+	}
+	else
+	{
+		setenv("hasnand", "false");
+	}
+#endif
 
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
diff --git a/drivers/bootcount/Makefile b/drivers/bootcount/Makefile
index a8d0ac7..8dc3037 100644
--- a/drivers/bootcount/Makefile
+++ b/drivers/bootcount/Makefile
@@ -27,6 +27,7 @@ COBJS-$(CONFIG_AT91SAM9XE)	+= bootcount_at91.o
 COBJS-$(CONFIG_BLACKFIN)	+= bootcount_blackfin.o
 COBJS-$(CONFIG_SOC_DA8XX)	+= bootcount_davinci.o
 COBJS-$(CONFIG_BOOTCOUNT_RAM)	+= bootcount_ram.o
+COBJS-$(CONFIG_SKOV_CPU_MODULE)	+= bootcount_at91.o
 
 COBJS	:= $(COBJS-y)
 SRCS 	:= $(COBJS:.o=.c)
diff --git a/drivers/mmc/gen_atmel_mci.c b/drivers/mmc/gen_atmel_mci.c
index 4968c5e..40c384c 100644
--- a/drivers/mmc/gen_atmel_mci.c
+++ b/drivers/mmc/gen_atmel_mci.c
@@ -48,6 +48,7 @@
 # define MCI_BUS 0
 #endif
 
+//#define DEBUG
 static int initialized = 0;
 
 /*
@@ -87,6 +88,11 @@ static void mci_set_mode(struct mmc *mmc, u32 hz, u32 blklen)
 		 | MMCI_BF(BLKLEN, blklen)
 		 | MMCI_BIT(RDPROOF)
 		 | MMCI_BIT(WRPROOF)), &mci->mr);
+	/*
+	 * On some new platforms BLKLEN in mci->mr is ignored.
+	 * Should use the BLKLEN in the block register.
+	 */
+	writel(MMCI_BF(BLKLEN, blklen), &mci->blkr);
 	initialized = 1;
 }
 
@@ -182,6 +188,12 @@ mci_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 
 	/* Figure out the transfer arguments */
 	cmdr = mci_encode_cmd(cmd, data, &error_flags);
+	
+	/* For multi blocks read/write, set the block register */
+	if ((cmd->cmdidx == MMC_CMD_READ_MULTIPLE_BLOCK)
+			|| (cmd->cmdidx == MMC_CMD_WRITE_MULTIPLE_BLOCK))
+	writel(data->blocks | MMCI_BF(BLKLEN, mmc->read_bl_len),
+			&mci->blkr);
 
 	/* Send the command */
 	writel(cmd->cmdarg, &mci->argr);
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 43140f3..714a148 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -41,7 +41,7 @@
 #include <environment.h>
 #include <mtd/cfi_flash.h>
 #include <watchdog.h>
-
+#include <flash.h> /**< Søren Andersen <san@rosetechnology.dk> */
 /*
  * This file implements a Common Flash Interface (CFI) driver for
  * U-Boot.
@@ -2247,11 +2247,16 @@ void flash_protect_default(void)
 	/* Environment protection ON by default */
 #ifdef CONFIG_ENV_IS_IN_FLASH
 	flash_protect(FLAG_PROTECT_SET,
+#if CONFIG_SKOV_CPU_MODULE
+                       CONFIG_ENV_ADDR_FLASH,
+                       CONFIG_ENV_ADDR_FLASH + CONFIG_ENV_SECT_SIZE_FLASH - 1,
+                       flash_get_info(CONFIG_ENV_ADDR_FLASH));
+#else
 		       CONFIG_ENV_ADDR,
 		       CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
 		       flash_get_info(CONFIG_ENV_ADDR));
 #endif
-
+#endif
 	/* Redundant environment protection ON by default */
 #ifdef CONFIG_ENV_ADDR_REDUND
 	flash_protect(FLAG_PROTECT_SET,
diff --git a/drivers/mtd/dataflash.c b/drivers/mtd/dataflash.c
index 981ccd5..c29e6d0 100644
--- a/drivers/mtd/dataflash.c
+++ b/drivers/mtd/dataflash.c
@@ -42,6 +42,7 @@ int AT91F_DataflashInit (void)
 	int found[CONFIG_SYS_MAX_DATAFLASH_BANKS];
 	unsigned char protected;
 
+//	printf("Looking for Dataflash\n"); /**< Martin Bjærre <mab@rosetechnology.dk> */
 	AT91F_SpiInit ();
 
 	for (i = 0; i < CONFIG_SYS_MAX_DATAFLASH_BANKS; i++) {
@@ -65,6 +66,21 @@ int AT91F_DataflashInit (void)
 			found[i] += dfcode;;
 			break;
 
+		case AT45DB041:
+			dataflash_info[i].Device.pages_number = 2048;
+			dataflash_info[i].Device.pages_size = 264;
+			dataflash_info[i].Device.page_offset = 9;
+			dataflash_info[i].Device.byte_mask = 0x300;
+			dataflash_info[i].Device.cs = cs[i].cs;
+			dataflash_info[i].Desc.DataFlash_state = IDLE;
+			dataflash_info[i].logical_address = cs[i].addr;
+			dataflash_info[i].id = dfcode;
+			found[i] += dfcode;;
+			#if defined(CONFIG_SKOV_CPU_MODULE)
+			set_has_dataflash(1); /**< Martin Bjærre: used to determine if env is in nor or dataflash */
+			#endif
+			break;	
+
 		case AT45DB081:
 			dataflash_info[i].Device.pages_number = 4096;
 			dataflash_info[i].Device.pages_size = 264;
@@ -126,7 +142,11 @@ int AT91F_DataflashInit (void)
 			break;
 
 		default:
+			printf("Dataflash not recon... (dfcode=%xh)\n",dfcode);
 			dfcode = 0;
+			#if defined(CONFIG_SKOV_CPU_MODULE)
+			set_has_dataflash(0); /**< Martin Bjærre: used to determine if env is in nor or dataflash */
+			#endif
 			break;
 		}
 		/* set the last area end to the dataflash size*/
@@ -201,6 +221,14 @@ void dataflash_print_info (void)
 			case AT45DB021:
 				printf("AT45DB021\n");
 				break;
+
+			case AT45DB041:
+				printf("AT45DB041\n");
+				break;
+
+			case AT45DB081:
+				printf("AT45DB081\n");
+
 			case AT45DB161:
 				printf("AT45DB161\n");
 				break;
@@ -212,6 +240,7 @@ void dataflash_print_info (void)
 			case AT45DB642:
 				printf("AT45DB642\n");
 				break;
+
 			case AT45DB128:
 				printf("AT45DB128\n");
 				break;
diff --git a/drivers/mtd/nand/atmel_nand.c b/drivers/mtd/nand/atmel_nand.c
index 994dd9f..3f2c52c 100644
--- a/drivers/mtd/nand/atmel_nand.c
+++ b/drivers/mtd/nand/atmel_nand.c
@@ -1014,6 +1014,13 @@ int atmel_nand_chip_init(int devnum, ulong base_addr)
 #ifdef CONFIG_SYS_NAND_DBW_16
 	nand->options = NAND_BUSWIDTH_16;
 #endif
+/** 
+  * @author Martin Bjærre <mab@rosetechnology.dk>
+  * Bad Block table should be physically on the NAND flash 
+  */
+#ifdef CONFIG_SYS_NAND_USE_FLASH_BBT 
+        nand->options     |= NAND_USE_FLASH_BBT;
+#endif
 	nand->cmd_ctrl = at91_nand_hwcontrol;
 #ifdef CONFIG_SYS_NAND_READY_PIN
 	nand->dev_ready = at91_nand_ready;
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 8316e8f..ca42fc1 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -49,6 +49,7 @@ COBJS-$(CONFIG_RTC_ISL1208) += isl1208.o
 COBJS-$(CONFIG_RTC_M41T11) += m41t11.o
 COBJS-$(CONFIG_RTC_M41T60) += m41t60.o
 COBJS-$(CONFIG_RTC_M41T62) += m41t62.o
+COBJS-$(CONFIG_RTC_M41T80) += m41t80.o # San Rose
 COBJS-$(CONFIG_RTC_M41T94) += m41t94.o
 COBJS-$(CONFIG_RTC_M48T35A) += m48t35ax.o
 COBJS-$(CONFIG_RTC_MAX6900) += max6900.o
diff --git a/drivers/rtc/ds1374.c b/drivers/rtc/ds1374.c
index d61a228..e88a87b 100644
--- a/drivers/rtc/ds1374.c
+++ b/drivers/rtc/ds1374.c
@@ -56,6 +56,16 @@
 # error The DS1374 is specified up to 400kHz in fast mode!
 #endif
 
+/* PTA ROSE */
+#ifdef CONFIG_RTC_DS1374_WATCHDOG
+/* San Rose */
+#include <ds1374.h>
+int g_timeout = 0;
+/* End san */
+static unsigned char kick_the_dog_is_disabled = 0;
+#endif
+/* END PTA */
+
 /*
  * RTC register addresses
  */
@@ -258,3 +268,63 @@ static void rtc_write_raw (uchar reg, uchar val)
 		i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, reg, val);
 }
 #endif
+
+/**
+ * @author Søren Andersen <san@rosetechnology.dk>
+ * Add watchdog functionality
+ */
+#if defined(CONFIG_RTC_DS1374_WATCHDOG)
+void ds1374_wdt_settimeout(unsigned int timeout)
+{
+   unsigned char t0, t1, t2;
+   t0 = (timeout & 0xff);   
+   t1 = ((timeout >> 8) & 0xff);
+   t2 = ((timeout >> 16) & 0xff);
+   i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, RTC_CTL_ADDR, 0x00);
+   i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, RTC_WD_ALM_CNT_BYTE0_ADDR, t0);
+   i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, RTC_WD_ALM_CNT_BYTE1_ADDR, t1);
+   i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, RTC_WD_ALM_CNT_BYTE2_ADDR, t2);
+   i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, RTC_CTL_ADDR, 0x60);
+   //We had been here
+   g_timeout = timeout;
+}
+
+/* PTA ROSE */
+void stop_kicking_the_dog(unsigned char status)
+{
+    kick_the_dog_is_disabled = status;
+}
+/* END PTA */
+ 
+void ds1374_hw_watchdog_reset(void)
+{
+   unsigned char val;
+   static int mutex = 0;
+   unsigned static long long last = 0;
+   unsigned long long now;    
+   if(g_timeout == 0 || kick_the_dog_is_disabled ) {   /* PTA ROSE: added check for kick_the_dog_is_disabled flag */    
+     return;
+   }
+   mutex++;
+   if(mutex > 1) {
+     mutex--;
+     return; 
+   }
+   now = get_ticks();
+   //Piiv = Mck/16   
+   if((now - last) > 1e6)
+   {  
+       //wd_time_tick = 0;
+       val = i2c_reg_read (CONFIG_SYS_I2C_RTC_ADDR, RTC_WD_ALM_CNT_BYTE2_ADDR);
+       last = now;
+   }
+   mutex--;
+}
+/*
+void hw_watchdog_init(void)
+{
+   //time out value is 4096 per secound so we set it to 32 secounds
+   ds1374_wdt_settimeout(131072);
+}
+*/
+#endif
diff --git a/drivers/rtc/m41t80.c b/drivers/rtc/m41t80.c
new file mode 100644
index 0000000..23c6aff
--- /dev/null
+++ b/drivers/rtc/m41t80.c
@@ -0,0 +1,208 @@
+/*
+ * (C) Copyright 2008
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
+ *
+ * based on a the Linux rtc-m41t80.c driver which is:
+ *   Alexander Bigga <ab@mycable.de>, 2006 (c) mycable GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Date & Time support for STMicroelectronics M41T80
+ */
+
+/* #define	DEBUG	*/
+
+#include <common.h>
+#include <command.h>
+#include <rtc.h>
+#include <i2c.h>
+
+
+#define M41T80_REG_SSEC	0
+#define M41T80_REG_SEC	1
+#define M41T80_REG_MIN	2
+#define M41T80_REG_HOUR	3
+#define M41T80_REG_WDAY	4
+#define M41T80_REG_DAY	5
+#define M41T80_REG_MON	6
+#define M41T80_REG_YEAR	7
+/* San Rose */
+#define M41T80_REG_WATCHDOG 	0x09
+/* End san */
+#define M41T80_REG_ALARM_MON	0xa
+#define M41T80_REG_ALARM_DAY	0xb
+#define M41T80_REG_ALARM_HOUR	0xc
+#define M41T80_REG_ALARM_MIN	0xd
+#define M41T80_REG_ALARM_SEC	0xe
+#define M41T80_REG_FLAGS	0xf
+
+#define M41T80_DATETIME_REG_SIZE	(M41T80_REG_YEAR + 1)
+#define M41T80_ALARM_REG_SIZE	\
+	(M41T80_REG_ALARM_SEC + 1 - M41T80_REG_ALARM_MON)
+
+#define M41T80_SEC_ST		(1 << 7)	/* ST: Stop Bit */
+#define M41T80_ALMON_AFE	(1 << 7)	/* AFE: AF Enable Bit */
+#define M41T80_ALMON_SQWE	(1 << 6)	/* SQWE: SQW Enable Bit */
+#define M41T80_ALHOUR_HT	(1 << 6)	/* HT: Halt Update Bit */
+#define M41T80_FLAGS_AF		(1 << 6)	/* AF: Alarm Flag Bit */
+#define M41T80_FLAGS_BATT_LOW	(1 << 4)	/* BL: Battery Low Bit */
+#define M41T80_WATCHDOG_RB2     (1 << 7)        /* RB: Watchdog resolution */
+#define M41T80_WATCHDOG_RB1     (1 << 1)        /* RB: Watchdog resolution */
+#define M41T80_WATCHDOG_RB0     (1 << 0)        /* RB: Watchdog resolution */
+
+#define M41T80_FEATURE_HT	(1 << 0)	/* Halt feature */
+#define M41T80_FEATURE_BL	(1 << 1)	/* Battery low indicator */
+#define M41T80_FEATURE_WD       (1 << 3)        /* Extra watchdog resolution */
+
+/* San Rose */
+#include <m41t80.h>
+int m41t83_g_timeout = 0;
+/* End san */
+
+#if defined(CONFIG_CMD_DATE)
+#if 0
+int rtc_get(struct rtc_time *tm)
+{
+	u8 buf[M41T80_DATETIME_REG_SIZE];
+
+	i2c_read(CONFIG_SYS_I2C_RTC_ADDR, 0, 1, buf, M41T80_DATETIME_REG_SIZE);
+
+	debug("%s: raw read data - sec=%02x, min=%02x, hr=%02x, "
+	      "mday=%02x, mon=%02x, year=%02x, wday=%02x, y2k=%02x\n",
+	      __FUNCTION__,
+	      buf[0], buf[1], buf[2], buf[3],
+	      buf[4], buf[5], buf[6], buf[7]);
+
+	tm->tm_sec = bcd2bin(buf[M41T80_REG_SEC] & 0x7f);
+	tm->tm_min = bcd2bin(buf[M41T80_REG_MIN] & 0x7f);
+	tm->tm_hour = bcd2bin(buf[M41T80_REG_HOUR] & 0x3f);
+	tm->tm_mday = bcd2bin(buf[M41T80_REG_DAY] & 0x3f);
+	tm->tm_wday = buf[M41T80_REG_WDAY] & 0x07;
+	tm->tm_mon = bcd2bin(buf[M41T80_REG_MON] & 0x1f);
+
+	/* assume 20YY not 19YY, and ignore the Century Bit */
+	/* U-Boot needs to add 1900 here */
+	tm->tm_year = bcd2bin(buf[M41T80_REG_YEAR]) + 100 + 1900;
+
+	debug("%s: tm is secs=%d, mins=%d, hours=%d, "
+	      "mday=%d, mon=%d, year=%d, wday=%d\n",
+	      __FUNCTION__,
+	      tm->tm_sec, tm->tm_min, tm->tm_hour,
+	      tm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);
+
+	return 0;
+}
+
+int rtc_set(struct rtc_time *tm)
+{
+	u8 buf[M41T80_DATETIME_REG_SIZE];
+
+	debug("Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+	      tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_wday,
+	      tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	i2c_read(CONFIG_SYS_I2C_RTC_ADDR, 0, 1, buf, M41T80_DATETIME_REG_SIZE);
+
+	/* Merge time-data and register flags into buf[0..7] */
+	buf[M41T80_REG_SSEC] = 0;
+	buf[M41T80_REG_SEC] =
+		bin2bcd(tm->tm_sec) | (buf[M41T80_REG_SEC] & ~0x7f);
+	buf[M41T80_REG_MIN] =
+		bin2bcd(tm->tm_min) | (buf[M41T80_REG_MIN] & ~0x7f);
+	buf[M41T80_REG_HOUR] =
+		bin2bcd(tm->tm_hour) | (buf[M41T80_REG_HOUR] & ~0x3f) ;
+	buf[M41T80_REG_WDAY] =
+		(tm->tm_wday & 0x07) | (buf[M41T80_REG_WDAY] & ~0x07);
+	buf[M41T80_REG_DAY] =
+		bin2bcd(tm->tm_mday) | (buf[M41T80_REG_DAY] & ~0x3f);
+	buf[M41T80_REG_MON] =
+		bin2bcd(tm->tm_mon) | (buf[M41T80_REG_MON] & ~0x1f);
+	/* assume 20YY not 19YY */
+	buf[M41T80_REG_YEAR] = bin2bcd(tm->tm_year % 100);
+
+	if (i2c_write(CONFIG_SYS_I2C_RTC_ADDR, 0, 1, buf, M41T80_DATETIME_REG_SIZE)) {
+		printf("I2C write failed in %s()\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+void rtc_reset(void)
+{
+	/*
+	 * Nothing to do
+	 */
+}
+#endif
+#endif
+
+/**
+ * @author Søren Andersen <san@rosetechnology.dk>
+ * Watchdog functionality
+ */
+#if defined(CONFIG_RTC_M41T82_WATCHDOG)
+void m41t82_wdt_settimeout(unsigned int timeout)
+{
+   unsigned char reg_val;
+   if (timeout > 31) {
+        reg_val = (timeout & 0xFC) | 0x83; /* resolution = 4s */
+   }
+   else {
+        /*
+         * WDS = 1 (0x80), mulitplier = WD_TIMO, resolution = 1s (0x02)
+         */
+        reg_val = timeout<<2 | 0x82;
+   }
+   
+   i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, M41T80_REG_WATCHDOG, reg_val);   
+   m41t83_g_timeout = timeout;
+}
+                                  
+void m41t82_hw_watchdog_reset(void)
+{
+   unsigned char reg_val;
+   static int mutex = 0;
+   unsigned static long long last = 0;
+   unsigned long long now;    
+   if(m41t83_g_timeout == 0) {       
+         return;
+   }
+   mutex++;
+   if(mutex > 1) {
+         mutex--;
+         return; 
+   }
+   now = get_ticks();
+   
+   //Piiv = Mck/16   
+   if((now - last) > 1e6) {  
+       if (m41t83_g_timeout > 31) {
+            reg_val = (m41t83_g_timeout & 0xFC) | 0x83; /* resolution = 4s */
+       }
+       else {
+            reg_val = m41t83_g_timeout<<2 | 0x82;
+       }
+       i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, M41T80_REG_WATCHDOG, reg_val);
+       //val = i2c_reg_read (CONFIG_SYS_I2C_RTC_ADDR, M41T80_REG_WATCHDOG);
+       last = now;
+   }
+   mutex--;
+}
+#endif
+                                                                                                                         
diff --git a/include/atmel_mci.h b/include/atmel_mci.h
index 3dd5d67..194a664 100644
--- a/include/atmel_mci.h
+++ b/include/atmel_mci.h
@@ -38,7 +38,7 @@ typedef struct atmel_mci {
 	u32	sdcr;	/* 0x0c */
 	u32	argr;	/* 0x10 */
 	u32	cmdr;	/* 0x14 */
-	u32	_18;	/* 0x18 */
+	u32	blkr;	/* 0x18 */
 	u32	_1c;	/* 0x1c */
 	u32	rspr;	/* 0x20 */
 	u32	rspr1;	/* 0x24 */
@@ -118,6 +118,11 @@ typedef struct atmel_mci {
 #define MMCI_TRTYP_OFFSET			19
 #define MMCI_TRTYP_SIZE				2
 
+/* Bitfields in BLKR */
+/* MMCI_BLKLEN_OFFSET/SIZE already defined in MR */
+#define MMCI_BCNT_OFFSET			0
+#define MMCI_BCNT_SIZE				16
+
 /* Bitfields in RSPRx */
 #define MMCI_RSP_OFFSET				0
 #define MMCI_RSP_SIZE				32
diff --git a/include/configs/skov_cpu_module.h b/include/configs/skov_cpu_module.h
new file mode 100644
index 0000000..e389c19
--- /dev/null
+++ b/include/configs/skov_cpu_module.h
@@ -0,0 +1,291 @@
+/**
+ * @file
+ * @author Søren Andersen <san@rosetechnology.dk>
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_AT91_LEGACY
+/*
+ * SoC must be defined first, before hardware.h is included.
+ * In this case SoC is defined in boards.cfg.
+ */
+#include <asm/hardware.h>
+
+#ifndef CONFIG_SYS_USE_BOOT_NORFLASH
+#define CONFIG_SYS_TEXT_BASE		0x23800000 /*San Rose: start up at 48MB memory level */
+#else
+#define CONFIG_SYS_TEXT_BASE		0x0000000
+#endif
+
+/* SD/MMC card */
+#define CONFIG_MMC                      1
+#define CONFIG_GENERIC_MMC              1
+#define CONFIG_GENERIC_ATMEL_MCI        1
+#define CONFIG_SYS_MMC_CD_PIN           AT91_PIN_PE18
+#define CONFIG_CMD_MMC                  1
+//#define CONFIG_SYS_MMC_MAX_BLK_COUNT 	1 // Use single transfers, as multi-transfers hang
+//#define CONFIG_MMC_TRACE		1
+//#define CONFIG_SYS_MMC_CLK_SKOV		1 /**< Søren Andersen try to set a lower mmc clock */
+
+/* ARM asynchronous clock */
+#define CONFIG_SYS_AT91_MAIN_CLOCK	16000000 /* 16.000 MHz crystal */
+#define CONFIG_SYS_AT91_SLOW_CLOCK	32768
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_SKOV_CPU_MODULE	1	/* It's a Skov CPU Board */
+
+#define CONFIG_ARCH_CPU_INIT
+
+#define CONFIG_CMDLINE_TAG	1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	1
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#define CONFIG_DISPLAY_CPUINFO
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_ATMEL_LEGACY
+#define CONFIG_AT91_GPIO		1
+#define CONFIG_AT91_GPIO_PULLUP		1
+
+/* serial console */
+#define CONFIG_ATMEL_USART
+#define CONFIG_USART_BASE		ATMEL_BASE_DBGU
+#define CONFIG_USART_ID			ATMEL_ID_SYS
+#define CONFIG_BAUDRATE			115200
+
+/* LCD */
+#define CONFIG_LCD			1
+#define CONFIG_CMD_LCD			1
+#define CONFIG_CMD_BMP      		1
+/* Verical Display */
+//#define CONFIG_TTFT1280120		1 //Treco vertical
+/* Skov Current Displays */
+#define CONFIG_70WVW2AZ0                1 //Old display on skov boards
+#define CONFIG_LTTD800480070            1 //New display on skov boards
+/* Skov old Display */
+//#define CONFIG_TX18D16VM1CBA		1 //Demo display on skov boards
+#define CONFIG_LC7981			1
+#define LCD_BPP				LCD_COLOR16
+#define CONFIG_BMP_16BPP            	1
+#define CONFIG_LCD_LOGO			1
+#undef LCD_TEST_PATTERN
+#define CONFIG_LCD_INFO			1
+#define CONFIG_LCD_INFO_BELOW_LOGO	1
+#define CONFIG_SYS_WHITE_ON_BLACK	1
+#define CONFIG_ATMEL_LCD		1
+//#define CONFIG_SYS_INVERT_COLORS        1
+#define CONFIG_ATMEL_LCD_BGR555		1
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	1
+
+/* LED */
+#define CONFIG_AT91_LED
+#define	CONFIG_RED_LED		AT91_PIN_PD0	/* the user0 led */
+#define	CONFIG_GREEN_LED	AT91_PIN_PD1	/* the user1 led */
+#define	CONFIG_YELLOW_LED	AT91_PIN_PD7	/* the user2 led */
+
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE	1
+#define CONFIG_BOOTP_BOOTPATH		1
+#define CONFIG_BOOTP_GATEWAY		1
+#define CONFIG_BOOTP_HOSTNAME		1
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_SOURCE
+
+#define CONFIG_CMD_PING		1
+#define CONFIG_CMD_DHCP		1
+#define CONFIG_CMD_NAND		1
+#define CONFIG_CMD_USB		1
+
+/** 
+ * @author Søren Andersen <san@rosetechnology.dk>
+ * I2C 
+ */
+   
+#define CONFIG_CMD_I2C          1
+#define CONFIG_SYS_I2C_SPEED    100000
+#define CONFIG_SOFT_I2C         1
+#define I2C_DELAY               udelay(2)
+#define CONFIG_I2C_SLAVE        0   
+#define I2C_ACTIVE              at91sam9263_i2c_active()
+#define I2C_TRISTATE            at91sam9263_i2c_tristate()
+#define I2C_INIT                at91sam9263_i2c_init()
+#define I2C_SCL(bit)            at91sam9263_i2c_scl(bit)
+#define I2C_SDA(bit)            at91sam9263_i2c_sda(bit)
+#define I2C_READ                at91sam9263_i2c_read()
+/* Watchdog */
+#define CONFIG_RTC_M41T82_WATCHDOG      1
+#define CONFIG_RTC_DS1374_WATCHDOG      1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x68
+#define CONFIG_HW_WATCHDOG              1
+/* End San */
+
+
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		ATMEL_BASE_CS1
+#define CONFIG_SYS_SDRAM_SIZE		0x04000000
+
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(ATMEL_BASE_SRAM1 + 0x1000 - GENERATED_GBL_DATA_SIZE)
+
+/* DataFlash */
+#define CONFIG_ATMEL_DATAFLASH_SPI
+#define CONFIG_HAS_DATAFLASH		1
+#define CONFIG_SYS_SPI_WRITE_TOUT		(5*CONFIG_SYS_HZ)
+#define CONFIG_SYS_MAX_DATAFLASH_BANKS		1
+#define CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS0	0xC0000000	/* CS0 */
+
+#define AT91_SPI_CLK			15000000
+#define DATAFLASH_TCSS			(0x1a << 16)
+#define DATAFLASH_TCHS			(0x1 << 24)
+
+/* NOR flash, if populated */
+#define CONFIG_SYS_FLASH_CFI			1
+#define CONFIG_FLASH_CFI_DRIVER			1
+#define CONFIG_FLASH_CFI_MTD			1
+#define PHYS_FLASH_1				0x10000000
+#define CONFIG_SYS_FLASH_BASE			PHYS_FLASH_1
+#define CONFIG_SYS_MAX_FLASH_SECT		512
+#define CONFIG_SYS_MAX_FLASH_BANKS		1
+
+#define CONFIG_SYS_MONITOR_SEC	1:0-3
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_MONITOR_LEN	(256 << 10)
+
+#define CONFIG_ENV_IS_IN_DATAFLASH
+
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_SIZE                         0x000004200
+#define CONFIG_ENV_ADDR                         (CONFIG_SYS_DATAFLASH_LOGIC_ADDR_CS0 + 0x0007FE00)
+/* Address and size of Primary Environment Sector */
+#define CONFIG_ENV_SIZE_FLASH			0x000004200 /**< Must be smaller that 64KB otherwise h_export fails*/
+#define CONFIG_ENV_ADDR_FLASH                   (CONFIG_SYS_FLASH_BASE + 0x00080000)
+#define CONFIG_ENV_SECT_SIZE_FLASH		0x00020000 /**< One sector is 128KB in Nor flash*/
+#define CONFIG_ENV_OVERWRITE			1 /**< San Rose It Shall be possible to change eth addr */
+
+#define MTDIDS_DEFAULT                  "nor0=physmap-flash.0"
+
+#define xstr(s)   str(s)
+#define str(s)	#s
+
+#define CONFIG_BOOTCOUNT_LIMIT  		1 /**< San Rose do something else if it is not possible to boot default partiton */ 
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"monitor_base=" xstr(CONFIG_SYS_MONITOR_BASE) "\0" \
+	"update=" \
+        "p0active=true\0" \
+        "altbootcmd=run bootcmd\0" \
+	"bootargs_common=console=ttyS0,115200 init=/bin/init.skov\0" \
+	"bootdelay=1\0" \
+        "bootlimit=3\0" \
+	"layout_nor=physmap-flash.0:512k(u-boot),128k(Env),2688k(Linux),-(Rootfs1)\0" \
+        "boot_flash=run flash_env_nor; run flash_exec\0" \
+        "flash_env_nor=echo \"NOR BOOT\"; set rootfs Rootfs1; run flash_bootargs_nor; set mtdids nor0=physmap-flash.0; set mtdparts mtdparts=$layout_nor\0" \
+        "flash_bootargs_nor=set bootargs $bootargs_common mtdparts=$layout_nor rw ubi.mtd=3 root=ubi0:Rootfs1 rootfstype=ubifs boot_flash mem_nor quiet\0" \
+	"flash_exec=bootm 100A0000\0" \
+	"flash_test=set bootcmd \"run boot_usb\"; save; run boot_flash;21000000\0" \
+	"boot_net=echo \"TFTP/NFS BOOT (NOR)\"; run net_bootargs_nor; run net_exec\0" \
+	"net_bootargs_nor=set bootargs \"$bootargs_common mtdparts=$layout_nor root=/dev/nfs rw nfsroot=$serverip ip=$ipaddr:$serverip:$gatewayip:$netmask boot_net mem_nor\"\0" \
+	"net_exec=tftp 21000000 SKOV/armkernel; bootm 21000000\0" \
+	"boot_usb=echo \"USB BOOT (NOR)\"; run usb_bootargs_nor; run usb_exec\0"\
+        "usb_bootargs_nor=set bootargs \"$bootargs_common mtdparts=$layout_nor root=/dev/ram0 rw ramdisk_size=30720 boot_usb mem_nor\"\0" \
+        "usb_exec=usb start; fatload usb 0:1 21000000 packk; fatload usb 0:1 21800000 packd; bootm 0x21000000 0x21800000\0" \
+        "ethaddr=MM:MM:MM:MM:MM:MM\0" \
+        "ipaddr=iii.iii.iii.iii\0" \
+        "netmask=mmm.mmm.mmm.mmm\0" \
+        "gatewayip=ggg.ggg.ggg.ggg\0" \
+        "serverip=sss.sss.sss.sss\0" \
+        "bootcmd=run boot_flash\0" \
+        "ipscheme=DHCP"
+/* NAND flash */
+#ifdef CONFIG_CMD_NAND
+#define CONFIG_CMD_UBI
+#define CONFIG_CMD_UBIFS
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_RBTREE
+#define CONFIG_LZO
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_NAND_ATMEL
+#define CONFIG_SYS_MAX_NAND_DEVICE		1
+#define CONFIG_SYS_NAND_BASE			ATMEL_BASE_CS3
+#define CONFIG_SYS_NAND_DBW_8			1
+/* our ALE is AD21 */
+#define CONFIG_SYS_NAND_MASK_ALE		(1 << 21)
+/* our CLE is AD22 */
+#define CONFIG_SYS_NAND_MASK_CLE		(1 << 22)
+#define CONFIG_SYS_NAND_ENABLE_PIN		AT91_PIN_PD15
+#define CONFIG_SYS_NAND_READY_PIN		AT91_PIN_PB10
+#define CONFIG_MTD_NAND_VERIFY_WRITE 		1		/* MAB: Extra safety */
+#define CONFIG_SYS_NAND_USE_FLASH_BBT 		1		/* MAB: added to save bbt to flash, and also ensure that 2 pages are scanned for bad block marker */
+#define CONFIG_SYS_64BIT_VSPRINTF		1		/* needed for nand_util.c */
+#endif
+
+/* Ethernet */
+#define CONFIG_MACB			1
+#define CONFIG_RMII			1
+#define CONFIG_NET_MULTI                1
+#define CONFIG_NET_RETRY_COUNT		20
+#define CONFIG_RESET_PHY_R		1
+#define CONFIG_MACB_SEARCH_PHY          1
+#define CONFIG_PHY_RESET_DELAY          1000
+
+/* Real time clock */
+#define CONFIG_CMD_DATE
+#define CONFIG_RTC_DS1374
+#define CONFIG_RTC_M41T80
+
+/* USB */
+#define CONFIG_USB_ATMEL
+#define CONFIG_USB_OHCI_NEW		1
+#define CONFIG_DOS_PARTITION		1
+#define CONFIG_SYS_USB_OHCI_CPU_INIT		1
+#define CONFIG_SYS_USB_OHCI_REGS_BASE		0x00a00000	/* AT91SAM9263_UHP_BASE */
+#define CONFIG_SYS_USB_OHCI_SLOT_NAME		"at91sam9263"
+#define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	2
+#define CONFIG_USB_STORAGE		1
+#define CONFIG_CMD_FAT			1
+#define CONFIG_CMD_EXT2                 1
+#define CONFIG_CMD_EXT4                 1
+
+#define CONFIG_SYS_LOAD_ADDR			0x22000000	/* load address */
+
+#define CONFIG_SYS_MEMTEST_START		CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END			0x23800000
+
+
+#define CONFIG_SYS_PROMPT		"SKOV A/S> "
+#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_MAXARGS		16
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_LONGHELP		1
+#define CONFIG_CMDLINE_EDITING		1
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_CRC32_VERIFY		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		0x800000  /**< Søren Andersen: Increase thise, because of UBI support and journal handling by startup*/
+
+#endif
diff --git a/include/dataflash.h b/include/dataflash.h
index 94f86b3..e9f205d 100644
--- a/include/dataflash.h
+++ b/include/dataflash.h
@@ -136,6 +136,7 @@ struct dataflash_addr {
 /*-------------------------------------------------------------------------------------------------*/
 #define AT45DB161	0x2c
 #define AT45DB021	0x14
+#define AT45DB041	0x1c
 #define AT45DB081	0x24
 #define AT45DB321	0x34
 #define AT45DB642	0x3c
diff --git a/include/ds1374.h b/include/ds1374.h
new file mode 100644
index 0000000..6b22843
--- /dev/null
+++ b/include/ds1374.h
@@ -0,0 +1,30 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _DS1374_H_
+#define _DS1374_H_
+
+/* PTA ROSE */
+void stop_kicking_the_dog(unsigned char status);
+/* END PTA */ 
+
+void ds1374_hw_watchdog_reset(void);
+void ds1374_wdt_settimeout(unsigned int timeout);
+#endif /* _DS1374_H_ */
diff --git a/include/environment.h b/include/environment.h
index e8ab703..19e0727 100644
--- a/include/environment.h
+++ b/include/environment.h
@@ -38,26 +38,48 @@
  */
 
 #if defined(CONFIG_ENV_IS_IN_FLASH)
-# ifndef	CONFIG_ENV_ADDR
-#  define	CONFIG_ENV_ADDR	(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+#if CONFIG_SKOV_MODULE
+# ifndef	CONFIG_ENV_ADDR_FLASH
+#  define	CONFIG_ENV_ADDR_FLASH	(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET_FLASH)
 # endif
-# ifndef	CONFIG_ENV_OFFSET
-#  define	CONFIG_ENV_OFFSET (CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)
+# ifndef	CONFIG_ENV_OFFSET_FLASH
+#  define	CONFIG_ENV_OFFSET_FLASH (CONFIG_ENV_ADDR_FLASH - CONFIG_SYS_FLASH_BASE_FLASH)
 # endif
+#else /* CONFIG_SKOV_MODULE */
+# ifndef        CONFIG_ENV_ADDR
+#  define       CONFIG_ENV_ADDR (CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+# endif
+# ifndef        CONFIG_ENV_OFFSET
+#  define       CONFIG_ENV_OFFSET (CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)
+# endif
+#endif /* CONFIG_SKOV_MODULE */
 # if !defined(CONFIG_ENV_ADDR_REDUND) && defined(CONFIG_ENV_OFFSET_REDUND)
 #  define	CONFIG_ENV_ADDR_REDUND	\
 		(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET_REDUND)
 # endif
 # if defined(CONFIG_ENV_SECT_SIZE) || defined(CONFIG_ENV_SIZE)
 #  ifndef	CONFIG_ENV_SECT_SIZE
-#   define	CONFIG_ENV_SECT_SIZE	CONFIG_ENV_SIZE
+#    define	CONFIG_ENV_SECT_SIZE	CONFIG_ENV_SIZE
 #  endif
 #  ifndef	CONFIG_ENV_SIZE
 #   define	CONFIG_ENV_SIZE	CONFIG_ENV_SECT_SIZE
 #  endif
 # else
-#  error "Both CONFIG_ENV_SECT_SIZE and CONFIG_ENV_SIZE undefined"
+#  error "Both CONFIG_ENV_SECT_SIZE and CONFIG_ENV_SIZE_FLASH undefined"
+# endif
+
+# if defined(CONFIG_ENV_SECT_SIZE_FLASH) || defined(CONFIG_ENV_SIZE_FLASH)
+#  ifndef       CONFIG_ENV_SECT_SIZE_FLASH
+#    define     CONFIG_ENV_SECT_SIZE_FLASH    CONFIG_ENV_SIZE_FLASH
+#  endif
+#  ifndef       CONFIG_ENV_SIZE_FLASH
+#   define      CONFIG_ENV_SIZE_FLASH CONFIG_ENV_SECT_SIZE_FLASH
+#  endif
+# else  
+#  error "Both CONFIG_ENV_SECT_SIZE and CONFIG_ENV_SIZE_FLASH undefined"
 # endif
+
+
 # if defined(CONFIG_ENV_ADDR_REDUND) && !defined(CONFIG_ENV_SIZE_REDUND)
 #  define CONFIG_ENV_SIZE_REDUND	CONFIG_ENV_SIZE
 # endif
@@ -138,6 +160,7 @@ extern unsigned long nand_env_oob_offset;
 extern char *env_name_spec;
 #endif
 
+#define ENV_SIZE_FLASH (CONFIG_ENV_SIZE_FLASH - ENV_HEADER_SIZE) /**< Martin bjærre <mab@rosetechnology.dk> */
 #define ENV_SIZE (CONFIG_ENV_SIZE - ENV_HEADER_SIZE)
 
 typedef struct environment_s {
diff --git a/include/flash.h b/include/flash.h
index 6d70bdd..b87837e 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -260,6 +260,7 @@ extern flash_info_t *flash_get_info(ulong base);
 #define AMD_ID_GL128N_2	0x22212221	/* 2nd ID word for S29GL128N */
 #define AMD_ID_GL128N_3	0x22012201	/* 3rd ID word for S29GL128N */
 
+#define AMD_ID_GL512    0x227E2201      /* ID word for S29GL512P */
 
 #define AMD_ID_LV320B_2 0x221A221A	/* 2d ID word for AM29LV320MB at 0x38 */
 #define AMD_ID_LV320B_3 0x22002200	/* 3d ID word for AM29LV320MB at 0x3c */
@@ -473,6 +474,8 @@ extern flash_info_t *flash_get_info(ulong base);
 #define FLASH_MT28S4M16LC 0x00E1	/* Micron MT28S4M16LC			*/
 #define FLASH_S29GL064M 0x00F0		/* Spansion S29GL064M-R6		*/
 #define FLASH_S29GL128N 0x00F1		/* Spansion S29GL128N			*/
+#define FLASH_S29GL256P 0x00F2          /* Spansion S29GL256P                   */
+#define FLASH_S29GL512P 0x00F3          /* Spansion S29GL512P                   */
 
 #define FLASH_UNKNOWN	0xFFFF		/* unknown flash type			*/
 
diff --git a/include/i2c.h b/include/i2c.h
index 16f099d..6953d51 100644
--- a/include/i2c.h
+++ b/include/i2c.h
@@ -171,12 +171,13 @@ static inline u8 i2c_reg_read(u8 addr, u8 reg)
 	printf("%s: addr=0x%02x, reg=0x%02x\n", __func__, addr, reg);
 #endif
 
-	i2c_read(addr, reg, 1, &buf, 1);
-
+ 	if ( i2c_read(addr, reg, 1, &buf, 1) ) {
+ 		return 0; /**< Martin Bjærre: This indicates an error */
+ 	}
 	return buf;
 }
 
-static inline void i2c_reg_write(u8 addr, u8 reg, u8 val)
+static inline u8 i2c_reg_write(u8 addr, u8 reg, u8 val) /**< Add return val */
 {
 #ifdef CONFIG_8xx
 	/* MPC8xx needs this.  Maybe one day we can get rid of it. */
@@ -188,7 +189,7 @@ static inline void i2c_reg_write(u8 addr, u8 reg, u8 val)
 	       __func__, addr, reg, val);
 #endif
 
-	i2c_write(addr, reg, 1, &val, 1);
+	return i2c_write(addr, reg, 1, &val, 1); /**< Martin Bjærre: Added return to indicate success or failure. */
 }
 
 /*
@@ -262,4 +263,16 @@ extern int get_multi_scl_pin(void);
 extern int get_multi_sda_pin(void);
 extern int multi_i2c_init(void);
 #endif
+
+/**
+ * @author Søren Andersen <san@rosetechnology.dk>
+ * Hardware functions for the AT91sam9263 CPU
+ */
+void at91sam9263_i2c_init(void);
+void at91sam9263_i2c_scl(unsigned long bit);
+void at91sam9263_i2c_sda(unsigned long bit);
+int at91sam9263_i2c_read(void);
+void at91sam9263_i2c_active(void);
+void at91sam9263_i2c_tristate(void);
+
 #endif	/* _I2C_H_ */
diff --git a/include/lc7981.h b/include/lc7981.h
new file mode 100644
index 0000000..59d4830
--- /dev/null
+++ b/include/lc7981.h
@@ -0,0 +1,18 @@
+/**
+ * @file
+ * 2008
+ * Rose Technology <www.rosetechnology.dk>
+ * @author: Martin Bjaerre <mab@rosetechnology.dk>
+ *
+ * Display driver for LC7981 displays on SKOV board.
+ * For displaying a startup image.
+ */
+#ifndef LC7981_H
+#define LC7981_H
+
+
+void lc7981_init(void);
+void lc7981_ctrl_init(void);
+void lc7981_enable(void);
+
+#endif
diff --git a/include/lcd.h b/include/lcd.h
index 42070d7..bed8d1e 100644
--- a/include/lcd.h
+++ b/include/lcd.h
@@ -44,6 +44,7 @@ extern void *lcd_console_address;	/* Start of console buffer	*/
 extern short console_col;
 extern short console_row;
 extern struct vidinfo panel_info;
+extern struct vidinfo lc7981_panel_info; /**< Søren Andersen <san@rosetechnology.dk> Configuration of LC7981 */
 
 extern void lcd_ctrl_init (void *lcdbase);
 extern void lcd_enable (void);
diff --git a/include/m41t80.h b/include/m41t80.h
new file mode 100644
index 0000000..4394656
--- /dev/null
+++ b/include/m41t80.h
@@ -0,0 +1,26 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _M41T80_H_
+#define _M41T80_H_
+
+void m41t82_hw_watchdog_reset(void);
+void m41t82_wdt_settimeout(unsigned int timeout);
+#endif /* _M41T80_H_ */
diff --git a/tools/Makefile b/tools/Makefile
index c31437e..fb6f88f 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -147,7 +147,6 @@ endif
 ifeq ($(VENDOR),intercontrol)
 LOGO_BMP= logos/intercontrol.bmp
 endif
-
 # now $(obj) is defined
 HOSTSRCS += $(addprefix $(SRCTREE)/,$(EXT_OBJ_FILES-y:.o=.c))
 HOSTSRCS += $(addprefix $(SRCTREE)/tools/,$(OBJ_FILES-y:.o=.c))
diff --git a/tools/envcrc.c b/tools/envcrc.c
index 08d2a8f..22e47f1 100644
--- a/tools/envcrc.c
+++ b/tools/envcrc.c
@@ -36,12 +36,21 @@
 #undef	__ASSEMBLY__
 
 #if defined(CONFIG_ENV_IS_IN_FLASH)
+#ifdef SKOV_CPU_MODULE
+# ifndef  CONFIG_ENV_ADDR_FLASH
+#  define CONFIG_ENV_ADDR_FLASH       (CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+# endif
+# ifndef  CONFIG_ENV_OFFSET_FLASH
+#  define CONFIG_ENV_OFFSET_FLASH (CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)
+# endif
+#else
 # ifndef  CONFIG_ENV_ADDR
 #  define CONFIG_ENV_ADDR	(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
 # endif
 # ifndef  CONFIG_ENV_OFFSET
 #  define CONFIG_ENV_OFFSET (CONFIG_ENV_ADDR - CONFIG_SYS_FLASH_BASE)
 # endif
+#endif /* SKOV_CPU_MODULE */
 # if !defined(CONFIG_ENV_ADDR_REDUND) && defined(CONFIG_ENV_OFFSET_REDUND)
 #  define CONFIG_ENV_ADDR_REDUND	(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET_REDUND)
 # endif
-- 
1.8.3.1

