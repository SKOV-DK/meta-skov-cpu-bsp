From 7fb02897d7e713d1204078d02580388bc2a00c13 Mon Sep 17 00:00:00 2001
From: Juergen Borleis <jbe@pengutronix.de>
Date: Tue, 8 Dec 2015 09:59:19 +0100
Subject: [PATCH 08/14] Skov: add base platform support.

The Skov platform consists of many variants of CPUs (i.MX6S/DL and i.MX6d/Q),
NAND memories (size differs from 256 MiB to 8 GiB) and populated SDRAM (256 MiB
up to 2 GiB).

All these variants share one PCB and should also share one single Barebox
binary. To distinguish the variant at runtime, some bootstrap resitors are
provided which decodes the variant.

Signed-off-by: Juergen Borleis <jbe@pengutronix.de>
---
 arch/arm/boards/Makefile                           |   1 +
 arch/arm/boards/skov-dol63x/Makefile               |   2 +
 arch/arm/boards/skov-dol63x/board.c                |  30 +
 .../flash-header-mx6-skol-dol63x.imxcfg            |   3 +
 arch/arm/boards/skov-dol63x/lowlevel.c             | 908 +++++++++++++++++++++
 arch/arm/dts/Makefile                              |   1 +
 arch/arm/dts/imx6dl-skov-dol63x.dts                |  24 +
 arch/arm/dts/imx6q-skov-dol63x.dts                 |  24 +
 arch/arm/dts/imx6qdl-skov-dol63x.dtsi              | 276 +++++++
 arch/arm/mach-imx/Kconfig                          |   5 +
 images/Makefile.imx                                |   5 +
 11 files changed, 1279 insertions(+)
 create mode 100644 arch/arm/boards/skov-dol63x/Makefile
 create mode 100644 arch/arm/boards/skov-dol63x/board.c
 create mode 100644 arch/arm/boards/skov-dol63x/flash-header-mx6-skol-dol63x.imxcfg
 create mode 100644 arch/arm/boards/skov-dol63x/lowlevel.c
 create mode 100644 arch/arm/dts/imx6dl-skov-dol63x.dts
 create mode 100644 arch/arm/dts/imx6q-skov-dol63x.dts
 create mode 100644 arch/arm/dts/imx6qdl-skov-dol63x.dtsi

diff --git a/arch/arm/boards/Makefile b/arch/arm/boards/Makefile
index 2229817dba73..6d996c5313d2 100644
--- a/arch/arm/boards/Makefile
+++ b/arch/arm/boards/Makefile
@@ -98,6 +98,7 @@ obj-$(CONFIG_MACH_REALQ7)			+= datamodul-edm-qmx6/
 obj-$(CONFIG_MACH_RPI)				+= raspberry-pi/
 obj-$(CONFIG_MACH_SABRELITE)			+= freescale-mx6-sabrelite/
 obj-$(CONFIG_MACH_SABRESD)			+= freescale-mx6-sabresd/
+obj-$(CONFIG_MACH_SKOV_DOL63X)			+= skov-dol63x/
 obj-$(CONFIG_MACH_FREESCALE_IMX6SX_SABRESDB)	+= freescale-mx6sx-sabresdb/
 obj-$(CONFIG_MACH_SAMA5D3XEK)			+= sama5d3xek/
 obj-$(CONFIG_MACH_SAMA5D3_XPLAINED)		+= sama5d3_xplained/
diff --git a/arch/arm/boards/skov-dol63x/Makefile b/arch/arm/boards/skov-dol63x/Makefile
new file mode 100644
index 000000000000..01c7a259e9a5
--- /dev/null
+++ b/arch/arm/boards/skov-dol63x/Makefile
@@ -0,0 +1,2 @@
+obj-y += board.o
+lwl-y += lowlevel.o
diff --git a/arch/arm/boards/skov-dol63x/board.c b/arch/arm/boards/skov-dol63x/board.c
new file mode 100644
index 000000000000..051366992708
--- /dev/null
+++ b/arch/arm/boards/skov-dol63x/board.c
@@ -0,0 +1,30 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Based on code marked with:
+ * Copyright (C) 2015 Sascha Hauer, Pengutronix
+ */
+
+#include <common.h>
+#include <init.h>
+#include <mach/bbu.h>
+
+static int skov_dol63x_devices_init(void)
+{
+	if (!of_machine_is_compatible("skov,dol63x"))
+		return 0;
+
+	imx6_bbu_internal_spi_i2c_register_handler("spiflash", "/dev/m25p0",
+		BBU_HANDLER_FLAG_DEFAULT);
+
+	return 0;
+}
+coredevice_initcall(skov_dol63x_devices_init);
diff --git a/arch/arm/boards/skov-dol63x/flash-header-mx6-skol-dol63x.imxcfg b/arch/arm/boards/skov-dol63x/flash-header-mx6-skol-dol63x.imxcfg
new file mode 100644
index 000000000000..400a87015425
--- /dev/null
+++ b/arch/arm/boards/skov-dol63x/flash-header-mx6-skol-dol63x.imxcfg
@@ -0,0 +1,3 @@
+soc imx6
+loadaddr 0x00907000
+dcdofs 0x400
diff --git a/arch/arm/boards/skov-dol63x/lowlevel.c b/arch/arm/boards/skov-dol63x/lowlevel.c
new file mode 100644
index 000000000000..1e2d7f8b0b39
--- /dev/null
+++ b/arch/arm/boards/skov-dol63x/lowlevel.c
@@ -0,0 +1,908 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Partially based on code of:
+ * Copyright (C) 2014, Rose Technology <san@rosetechnology.dk>
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+#define pr_fmt(fmt) "skov-dol63x: " fmt
+
+#include <common.h>
+#include <mach/generic.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <debug_ll.h>
+#include <io.h>
+#include <mach/imx6-mmdc.h>
+#include <mach/imx6-ddr-regs.h>
+#include <mach/imx6.h>
+#include <mach/xload.h>
+#include <mach/esdctl.h>
+#include <serial/imx-uart.h>
+#include <mach/iomux-mx6.h>
+
+#define SKOV_DOL63X_SDHC_CHANNEL 2 /* SDHC #3 */
+#define SKOV_DOL63X_NOR_CHANNEL 0 /* SPI master #1 */
+
+static void __udelay(int us)
+{
+	volatile int i;
+
+	for (i = 0; i < us * 4; i++);
+}
+
+/* ------------------------------------------------------------------------ */
+
+#if 0
+/* 1066mhz_4x256mx16 -> 2 GiB */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E7974
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x43040319
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x03040279
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x43040321
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x03030251
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4d434248
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x42413c4d
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x34424543
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x49324933
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001a0017
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x00170027
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x000a001f
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
+#endif
+
+/*
+ * Micron MT41K256M16HA-125 IT:E ->  4 GBit = 32 Meg x 16 x 8 banks
+ *
+ * Speed Grade   Data Rate (MT/s)  tRCD-tRP-CL   tRCD(ns)  tRP(ns)  CL(ns)
+ *    -125          1600            11-11-11      13.75     13.75   13.75
+ *               (=800 MHz)
+ *
+ * Memory configuration used by variant:
+ * - "Max Performance", 64 bit data bus, 1066 MHz, 2 GiB memory
+ */
+static const struct mx6_ddr3_cfg skov_dol63x_cfg_4x256Mb_1066MHz = {
+	.mem_speed = 1066,
+	.density = 4, /* GiBit */
+	.width = 16, /* 16 bit data per device */
+	.banks = 8,
+	.rowaddr = 15, /* 32 k */
+	.coladdr = 10, /* 1 k */
+	.pagesz = 2, /* [kiB] */
+	.trcd = 1375, /* 13.75 ns = 11 clocks @ 1.6 GHz */
+	.trcmin = 4875, /* 48.75 ns = 39 clocks @ 1.6 GHz */
+	.trasmin = 3500, /* 35 ns = 28 clocks @ 1.6 GHz */
+	.SRT = 0,
+};
+
+static const struct mx6_ddr_sysinfo skov_dol63x_sysinfo_4x256Mb_1066MHz = {
+	.dsize = 2, /* 64 bit wide = 4 devices, 16 bit each */
+	.cs_density = 16, /* four 4 GBit devices connected */
+	.ncs = 1, /* one CS line for all devices */
+	.cs1_mirror = 1, /* TODO */
+	.bi_on = 1, /* TODO */
+	.rtt_nom = 1, /* MX6_MMDC_P0_MPODTCTRL -> 0x00022227 */
+	.rtt_wr = 0, /* is LW_EN is 0 in their code */
+	.ralat = 5, /* TODO */
+	.walat = 1, /* TODO */
+	.mif3_mode = 3, /* TODO */
+	.rst_to_cke = 0x23, /* used in their code as well */
+	.sde_to_rst = 0x10, /* used in their code as well */
+	.pd_fast_exit = 0, /* TODO */
+};
+
+static const struct mx6_mmdc_calibration skov_dol63x_calib_4x256Mb_1066MHz = {
+	.p0_mpwldectrl0 = 0x001a0017,
+	.p0_mpwldectrl1 = 0x001F001F,
+	.p0_mpdgctrl0 = 0x43040319,
+	.p0_mpdgctrl1 = 0x03040279,
+	.p0_mprddlctl = 0x4d434248,
+	.p0_mpwrdlctl = 0x34424543,
+
+	.p1_mpwldectrl0 = 0x00170027,
+	.p1_mpwldectrl1 = 0x000a001f,
+	.p1_mpdgctrl0 = 0x43040321,
+	.p1_mpdgctrl1 = 0x03030251,
+	.p1_mprddlctl = 0x42413c4d,
+	.p1_mpwrdlctl = 0x49324933,
+};
+
+/* ------------------------------------------------------------------------ */
+
+#if 0
+/* 1066mhz_4x128mx16 -> 1 GiB */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x555A7974
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x005A1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
+DATA 4, MX6_MMDC_P0_MDCTL, 0x831A0000
+DATA 4, MX6_MMDC_P0_MDSCR,     0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42720306
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x026F0266
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x4273030A
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02740240
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x45393B3E
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x403A3747
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x40434541
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x473E4A3B
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0011000E
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x000E001B
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x00190015
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00070018
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
+#endif
+
+/*
+ * Micron MT41K128M16JT-125 IT:K ->  2 GBit = 16 Meg x 16 x 8 banks
+ *
+ * Speed Grade   Data Rate (MT/s)  tRCD-tRP-CL   tRCD(ns)  tRP(ns)  CL(ns)
+ *    -125 ¹²       1600            11-11-11      13.75     13.75   13.75
+ *               (=800 MHz)
+ *
+ * ¹ Backward compatible to 1066 (=533 MHz), CL = 7
+ * ² Backward compatible to 1333 (=667 MHz), CL = 9
+ *
+ * Memory configuration used by variant
+ * - "High Performance", 64 bit data bus, 1066 MHz, 1 GiB memory
+ */
+static const struct mx6_ddr3_cfg skov_dol63x_cfg_4x128Mb_1066MHz = {
+	.mem_speed = 1066,
+	.density = 2, /* GiBit */
+	.width = 16, /* 16 bit data per device */
+	.banks = 8,
+	.rowaddr = 14, /* 16 k */
+	.coladdr = 10, /* 1 k */
+	.pagesz = 2, /* [kiB] */
+	.trcd = 1375, /* 13.75 ns = 11 clocks @ 1.6 GHz */
+	.trcmin = 4875, /* 48.75 ns = 39 clocks @ 1.6 GHz */
+	.trasmin = 3500, /* 35 ns = 28 clocks @ 1.6 GHz */
+	.SRT = 0,
+};
+
+static const struct mx6_ddr_sysinfo skov_dol63x_sysinfo_4x128Mb_1066MHz = {
+	.dsize = 2, /* 64 bit wide = 4 devices, 16 bit each */
+	.cs_density = 8, /* four 2 GBit devices connected */
+	.ncs = 1, /* one CS line for all devices */
+	.cs1_mirror = 1, /* TODO */
+	.bi_on = 1, /* TODO */
+	.rtt_nom = 1, /* MX6_MMDC_P0_MPODTCTRL -> 0x00022227 */
+	.rtt_wr = 0, /* is LW_EN is 0 in their code */
+	.ralat = 5, /* TODO */
+	.walat = 1, /* TODO */
+	.mif3_mode = 3, /* TODO */
+	.rst_to_cke = 0x23, /* used in their code as well */
+	.sde_to_rst = 0x10, /* used in their code as well */
+	.pd_fast_exit = 0, /* TODO */
+};
+
+/* calibration info for the "max performance" and "high performance" */
+static const struct mx6_mmdc_calibration skov_dol63x_calib_4x128Mb_1066MHz = {
+	.p0_mpwldectrl0 = 0x0011000E,
+	.p0_mpwldectrl1 = 0x000E001B,
+	.p0_mpdgctrl0 = 0x42720306,
+	.p0_mpdgctrl1 = 0x026F0266,
+	.p0_mprddlctl = 0x45393B3E,
+	.p0_mpwrdlctl = 0x40434541,
+
+	.p1_mpwldectrl0 = 0x00190015,
+	.p1_mpwldectrl1 = 0x00070018,
+	.p1_mpdgctrl0 = 0x4273030A,
+	.p1_mpdgctrl1 = 0x02740240,
+	.p1_mprddlctl = 0x403A3747,
+	.p1_mpwrdlctl = 0x473E4A3B,
+};
+
+/* ------------------------------------------------------------------------ */
+
+static struct mx6dq_iomux_ddr_regs ddr_iomux_q = {
+	.dram_sdqs0 = 0x00000030,
+	.dram_sdqs1 = 0x00000030,
+	.dram_sdqs2 = 0x00000030,
+	.dram_sdqs3 = 0x00000030,
+	.dram_sdqs4 = 0x00000030,
+	.dram_sdqs5 = 0x00000030,
+	.dram_sdqs6 = 0x00000030,
+	.dram_sdqs7 = 0x00000030,
+	.dram_dqm0 = 0x00020030,
+	.dram_dqm1 = 0x00020030,
+	.dram_dqm2 = 0x00020030,
+	.dram_dqm3 = 0x00020030,
+	.dram_dqm4 = 0x00020030,
+	.dram_dqm5 = 0x00020030,
+	.dram_dqm6 = 0x00020030,
+	.dram_dqm7 = 0x00020030,
+	.dram_cas = 0x00020030,
+	.dram_ras = 0x00020030,
+	.dram_sdclk_0 = 0x00020030,
+	.dram_sdclk_1 = 0x00020030,
+	.dram_sdcke0 = 0x00003000,
+	.dram_sdcke1 = 0x00003000,
+	.dram_reset = 0x00020030,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = 0x00003030,
+	.dram_sdodt1 = 0x00003030,
+};
+
+static struct mx6dq_iomux_grp_regs grp_iomux_q = {
+	.grp_b0ds = 0x00000030,
+	.grp_b1ds = 0x00000030,
+	.grp_b2ds = 0x00000030,
+	.grp_b3ds = 0x00000030,
+	.grp_b4ds = 0x00000030,
+	.grp_b5ds = 0x00000030,
+	.grp_b6ds = 0x00000030,
+	.grp_b7ds = 0x00000030,
+	.grp_addds = 0x00000030,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_ctlds = 0x00000030,
+	.grp_ddr_type = 0x000C0000,
+};
+
+static void spl_imx6q_dram_init(const struct mx6_ddr_sysinfo *si,
+				const struct mx6_mmdc_calibration *cb,
+				const struct mx6_ddr3_cfg *cfg)
+{
+	mx6dq_dram_iocfg(64, &ddr_iomux_q, &grp_iomux_q);
+	mx6_dram_cfg(si, cb, cfg);
+	__udelay(100);
+}
+
+/* ------------------------------------------------------------------------ */
+
+#if 0
+/* 800mhz_2x128mx16 */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x40435323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000017
+DATA 4, MX6_MMDC_P0_MDCTL, 0x83190000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
+#endif
+
+#if 0
+/* 800mhz_4x128mx16 */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x40435323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
+DATA 4, MX6_MMDC_P0_MDCTL, 0x831A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x420F020F
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x01760175
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x41640171
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x015E0160
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x45464B4A
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x49484A46
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x40402E32
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3A3A3231
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x003A003A
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0030002F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x002F0038
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00270039
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
+#endif
+
+#if 0
+/* 800mhz_4x256mx16 */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x696C5323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x006C1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
+#endif
+
+/* ------------------------------------------------------------------------ */
+
+#if 0
+/* 800mhz_2x256mx16 */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x696C5323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x006C1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
+DATA 4, MX6_MMDC_P0_MDCTL, 0x84190000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42350231
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x021A0218
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x4B4B4E49
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x3F3F3035
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
+#endif
+
+/*
+ * Device Information: Varies per DDR3 part number and speed grade
+ * Note: this SDRAM type is used on the "Low Cost" variant
+ *
+ * Micron MT41K128M16JT-125 IT:K ->  2 GBit = 16 Meg x 16 x 8 banks
+ *
+ * Speed Grade   Data Rate (MT/s)  tRCD-tRP-CL   tRCD(ns)  tRP(ns)  CL(ns)
+ *    -125 ¹²       1600            11-11-11      13.75     13.75   13.75
+ *               (=800 MHz)
+ *
+ * ¹ Backward compatible to 1066 (=533 MHz), CL = 7
+ * ² Backward compatible to 1333 (=667 MHz), CL = 9
+ *
+ * Memory configuration used by variant
+ * - "Low Cost", 32 bit data bus, 800 MHz, 512 MiB memory
+ */
+static const struct mx6_ddr3_cfg skov_dol63x_cfg_2x128Mb_800MHz = {
+	.mem_speed = 800,
+	.density = 2, /* GiBit */
+	.width = 16, /* 16 bit data per device */
+	.banks = 8,
+	.rowaddr = 14, /* 16 k */
+	.coladdr = 10, /* 1 k */
+	.pagesz = 2, /* [kiB] */
+	.trcd = 1375, /* 13.75 ns = 11 clocks @ 1.6 GHz */
+	.trcmin = 4875, /* 48.75 ns = 39 clocks @ 1.6 GHz */
+	.trasmin = 3500, /* 35 ns = 28 clocks @ 1.6 GHz */
+	.SRT = 0,
+};
+
+static const struct mx6_ddr_sysinfo skov_dol63x_sysinfo_2x128Mb_800MHz = {
+	.dsize = 1, /* 32 bit wide = 2 devices, 16 bit each */
+	.cs_density = 4, /* two 2 GBit devices connected */
+	.ncs = 1, /* one CS line for all devices */
+	.cs1_mirror = 1, /* TODO */
+	.bi_on = 1, /* TODO */
+	.rtt_nom = 1, /* MX6_MMDC_P0_MPODTCTRL -> 0x00022227 */
+	.rtt_wr = 0, /* is LW_EN is 0 in their code */
+	.ralat = 5, /* TODO */
+	.walat = 1, /* TODO */
+	.mif3_mode = 3, /* TODO */
+	.rst_to_cke = 0x23, /* used in their code as well */
+	.sde_to_rst = 0x10, /* used in their code as well */
+	.pd_fast_exit = 0, /* TODO */
+};
+
+static const struct mx6_mmdc_calibration skov_dol63x_calib_2x128Mb_800MHz = {
+	.p0_mpwldectrl0 = 0x0040003C,
+	.p0_mpwldectrl1 = 0x0032003E,
+	.p0_mpdgctrl0 = 0x42350231,
+	.p0_mpdgctrl1 = 0x021A0218,
+	.p0_mprddlctl = 0x4B4B4E49,
+	.p0_mpwrdlctl = 0x3F3F3035,
+};
+
+/* ------------------------------------------------------------------------ */
+
+static const struct mx6sdl_iomux_ddr_regs ddr_iomux_s = {
+	.dram_sdqs0 = 0x00000030,
+	.dram_sdqs1 = 0x00000030,
+	.dram_sdqs2 = 0x00000030,
+	.dram_sdqs3 = 0x00000030,
+	.dram_sdqs4 = 0x00000030,
+	.dram_sdqs5 = 0x00000030,
+	.dram_sdqs6 = 0x00000030,
+	.dram_sdqs7 = 0x00000030,
+	.dram_dqm0 = 0x00020030,
+	.dram_dqm1 = 0x00020030,
+	.dram_dqm2 = 0x00020030,
+	.dram_dqm3 = 0x00020030,
+	.dram_dqm4 = 0x00020030,
+	.dram_dqm5 = 0x00020030,
+	.dram_dqm6 = 0x00020030,
+	.dram_dqm7 = 0x00020030,
+	.dram_cas = 0x00020030,
+	.dram_ras = 0x00020030,
+	.dram_sdclk_0 = 0x00020030,
+	.dram_sdclk_1 = 0x00020030,
+	.dram_sdcke0 = 0x00003000,
+	.dram_sdcke1 = 0x00003000,
+	.dram_reset = 0x00020030,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = 0x00003030,
+	.dram_sdodt1 = 0x00003030,
+};
+
+static const struct mx6sdl_iomux_grp_regs grp_iomux_s = { /* TODO */
+	.grp_b0ds = 0x00000030,
+	.grp_b1ds = 0x00000030,
+	.grp_b2ds = 0x00000030,
+	.grp_b3ds = 0x00000030,
+	.grp_b4ds = 0x00000030,
+	.grp_b5ds = 0x00000030,
+	.grp_b6ds = 0x00000030,
+	.grp_b7ds = 0x00000030,
+	.grp_addds = 0x00000030,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_ctlds = 0x00000030,
+	.grp_ddr_type = 0x000C0000,
+};
+
+static void spl_imx6sdl_dram_init(const struct mx6_ddr_sysinfo *si,
+				const struct mx6_mmdc_calibration *cb,
+				const struct mx6_ddr3_cfg *cfg)
+{
+	mx6sdl_dram_iocfg(64, &ddr_iomux_s, &grp_iomux_s);
+	mx6_dram_cfg(si, cb, cfg);
+	__udelay(100);
+}
+
+/* ------------------------------------------------------------------------ */
+
+#define LED_PAD_CTRL MX6_PAD_CTL_SPEED_LOW | MX6_PAD_CTL_DSE_240ohm | MX6_PAD_CTL_SRE_SLOW
+
+static inline void setup_leds(int cpu_type)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *gpiobase = IOMEM(MX6_GPIO1_BASE_ADDR);
+	unsigned reg;
+
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(0x05, iomuxbase + 0x20C); /* LED1 (GPIO0) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5DC);
+		writel(0x05, iomuxbase + 0x224); /* LED2 (GPIO2) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5F4);
+		writel(0x05, iomuxbase + 0x22C); /* LED3 (GPIO4) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5FC);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(0x05, iomuxbase + 0x220); /* LED1 (GPIO0) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5f0);
+		writel(0x05, iomuxbase + 0x234); /* LED2 (GPIO2) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x604);
+		writel(0x05, iomuxbase + 0x238); /* LED3 (GPIO4) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x608);
+		break;
+	}
+
+	/* Turn off all LEDS */
+	reg = readl(gpiobase + 0x00);
+	reg &= ~(1 | 4 | 16);
+	writel(reg, gpiobase + 0x00);
+
+	/* make them output */
+	reg = readl(gpiobase + 0x04);
+	reg |= 1 | 4 | 16;
+	writel(reg, gpiobase + 0x04);
+}
+
+static inline void setup_uart(int cpu_type)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+
+	/* UART TxD output is pin EIM/D26, e.g. UART is in DTE mode */
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(0x0, iomuxbase + 0x904); /*  IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT */
+		writel(0x4, iomuxbase + 0x16c); /*  IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26 */
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(0x0, iomuxbase + 0x928); /*  IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT */
+		writel(0x4, iomuxbase + 0x0bc); /*  IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26 */
+		break;
+	}
+
+	imx6_ungate_all_peripherals();
+	imx6_uart_setup(IOMEM(MX6_UART2_BASE_ADDR));
+	pbl_set_putc(imx_uart_putc, IOMEM(MX6_UART2_BASE_ADDR));
+
+	pr_debug("\n");
+}
+
+#define V_PAD_CTRL MX6_PAD_CTL_PUS_100K_UP | MX6_PAD_CTL_PUE | MX6_PAD_CTL_SPEED_LOW | MX6_PAD_CTL_DSE_DISABLE | MX6_PAD_CTL_SRE_SLOW
+
+static inline unsigned skov_dol63x_get_version(int cpu_type)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *gpiobase = IOMEM(MX6_GPIO2_BASE_ADDR);
+	unsigned reg;
+	unsigned var = 0;
+
+	/* mux pins as GPIOs */
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(0x05, iomuxbase + 0x348); /* VERSION_0, GPIO2/10 */
+		writel(V_PAD_CTRL, iomuxbase + 0x730);
+		writel(0x05, iomuxbase + 0x35c); /* VERSION_1, GPIO2/15 */
+		writel(V_PAD_CTRL, iomuxbase + 0x744);
+		writel(0x05, iomuxbase + 0x340); /* VERSION_2, GPIO2/8 */
+		writel(V_PAD_CTRL, iomuxbase + 0x728);
+		writel(0x05, iomuxbase + 0x344); /* VERSION_3, GPIO2/9 */
+		writel(V_PAD_CTRL, iomuxbase + 0x72C);
+		writel(0x05, iomuxbase + 0x350); /* VERSION_4, GPIO2/12 */
+		writel(V_PAD_CTRL, iomuxbase + 0x738);
+		writel(0x05, iomuxbase + 0x358); /* VERSION_5, GPIO2/14 */
+		writel(V_PAD_CTRL, iomuxbase + 0x740);
+		writel(0x05, iomuxbase + 0x34c); /* VERSION_6, GPIO2/11 */
+		writel(V_PAD_CTRL, iomuxbase + 0x734);
+		writel(0x05, iomuxbase + 0x354); /* VERSION_7, GPIO2/13 */
+		writel(V_PAD_CTRL, iomuxbase + 0x73C);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(0x05, iomuxbase + 0x324); /* VERSION_0, GPIO2/10 */
+		writel(V_PAD_CTRL, iomuxbase + 0x70c);
+		writel(0x05, iomuxbase + 0x338); /* VERSION_1, GPIO2/15 */
+		writel(V_PAD_CTRL, iomuxbase + 0x720);
+		writel(0x05, iomuxbase + 0x31c); /* VERSION_2, GPIO2/8 */
+		writel(V_PAD_CTRL, iomuxbase + 0x704);
+		writel(0x05, iomuxbase + 0x320); /* VERSION_3, GPIO2/9 */
+		writel(V_PAD_CTRL, iomuxbase + 0x708);
+		writel(0x05, iomuxbase + 0x32c); /* VERSION_4, GPIO2/12 */
+		writel(V_PAD_CTRL, iomuxbase + 0x714);
+		writel(0x05, iomuxbase + 0x334); /* VERSION_5, GPIO2/14 */
+		writel(V_PAD_CTRL, iomuxbase + 0x71c);
+		writel(0x05, iomuxbase + 0x328); /* VERSION_6, GPIO2/11 */
+		writel(V_PAD_CTRL, iomuxbase + 0x710);
+		writel(0x05, iomuxbase + 0x330); /* VERSION_7, GPIO2/13 */
+		writel(V_PAD_CTRL, iomuxbase + 0x718);
+		break;
+	default:
+		pr_err("Invalid SoC! i.MX6S/DL or i.MX6Q expected (found %d)\n", cpu_type);
+		return -1;
+	}
+
+	/* force all to be inputs */
+	reg = readl(gpiobase + 0x04);
+	reg &= ~(0xff00);
+	writel(reg, gpiobase + 0x04);
+
+	reg = readl(gpiobase + 0x00);
+	var |= !!(reg & (1 << 13));
+	var <<= 1;
+	var |= !!(reg & (1 << 11));
+	var <<= 1;
+	var |= !!(reg & (1 << 14));
+	var <<= 1;
+	var |= !!(reg & (1 << 12));
+	var <<= 1;
+	var |= !!(reg & (1 << 9));
+	var <<= 1;
+	var |= !!(reg & (1 << 8));
+	var <<= 1;
+	var |= !!(reg & (1 << 15));
+	var <<= 1;
+	var |= !!(reg & (1 << 10));
+
+	return (~var) & 0xff;
+}
+
+/*
+ * Hardware marked board revisions and deployments
+ *
+ *   count      board    ram       flash       CPU
+ *               rev.
+ * 00000000       A    1024 MiB   1024 MiB     i.MX6Q
+ * 00000001       A     512 MiB    256 MiB     i.MX6S
+ * 00000010       A    1024 MiB    512 MiB     i.MX6Q
+ * 00000011       ---- not defined ----
+ * 00000100       A     512 MiB    256 MiB     i.MX6S
+ * 00000101       ---- not defined ----
+ * 00000110       ---- not defined ----
+ * 00000111       ---- not defined ----
+ * 00001000       A    1024 MiB    512 MiB     i.MX6Q
+ * 00001001       B     256 MiB     16 MiB     i.MX6S
+ * 00001010       B     256 MiB    256 MiB     i.MX6S
+ * 00001011	  B    1024 MiB    256 MiB     i.MX6Q
+ * 00001100       B    2048 MiB      8 GiB     i.MX6Q
+ * 00001101       C     256 MiB    256 MiB     i.MX6S
+ * 00001110       C    1024 MiB    256 MiB     i.MX6Q
+ * 00001111       C     512 MiB    256 MiB     i.MX6S
+ *
+ * This routine does not return if starting the image from SD card or NOR
+ * was successfull. It restarts skov_dol63x_start() instead
+ */
+static void skov_dol63x_init(int cpu_type)
+{
+	unsigned board_rev;
+
+	board_rev = skov_dol63x_get_version(cpu_type);
+	switch (board_rev) {
+	case 1: /* P1 i.MX6S, low cost, old count */
+	case 4: /* P1 i.MX6S, low cost, new count */
+		if (cpu_type != IMX6_CPUTYPE_IMX6S) {
+			pr_err("Invalid SoC! i.MX6S expected\n");
+			return;
+		}
+		pr_debug("Initializing a P1 low cost system...\n");
+		spl_imx6sdl_dram_init(&skov_dol63x_sysinfo_2x128Mb_800MHz,
+					&skov_dol63x_calib_2x128Mb_800MHz,
+					&skov_dol63x_cfg_2x128Mb_800MHz);
+		break;
+	case 0: /* P1 i.MX6Q, high performance */
+	case 2: /* P1 i.MX6Q, high performance, old count */
+	case 8: /* P1 i.MX6Q, high performance, new count */
+		if (cpu_type != IMX6_CPUTYPE_IMX6Q) {
+			pr_err("Invalid SoC! i.MX6Q expected\n");
+			return;
+		}
+		pr_debug("Initializing a P1 high performance system...\n");
+		spl_imx6q_dram_init(&skov_dol63x_sysinfo_4x128Mb_1066MHz,
+					&skov_dol63x_calib_4x128Mb_1066MHz,
+					&skov_dol63x_cfg_4x128Mb_1066MHz);
+		break;
+	case 9: /* P2 i.MX6S, minimum cost */
+		if (cpu_type != IMX6_CPUTYPE_IMX6S) {
+			pr_err("Invalid SoC! i.MX6S expected\n");
+			return;
+		}
+		pr_debug("Initializing a P2 minimum cost system...\n");
+#if 0
+		/* TODO */
+		spl_imx6sdl_dram_init(&skov_dol63x_sysinfo_2x64Mb_800MHz,
+					&skov_dol63x_calib_2x64Mb_800MHz,
+					&skov_dol63x_cfg_2x64Mb_800MHz);
+#endif
+		break;
+	case 10: /* P2 i.MX6S, low cost */
+		if (cpu_type != IMX6_CPUTYPE_IMX6S) {
+			pr_err("Invalid SoC! i.MX6S expected\n");
+			return;
+		}
+		pr_debug("Initializing a P2 low cost system...\n");
+#if 0
+		/* TODO */
+		spl_imx6sdl_dram_init(&skov_dol63x_sysinfo_2x64Mb_800MHz,
+					&skov_dol63x_calib_2x64Mb_800MHz,
+					&skov_dol63x_cfg_2x64Mb_800MHz);
+#endif
+		break;
+	case 11: /* P1 i.MX6S, high performance */
+		if (cpu_type != IMX6_CPUTYPE_IMX6Q) {
+			pr_err("Invalid SoC! i.MX6Q expected\n");
+			return;
+		}
+		pr_debug("Initializing a P2 high performance system...\n");
+		spl_imx6q_dram_init(&skov_dol63x_sysinfo_4x128Mb_1066MHz,
+					&skov_dol63x_calib_4x128Mb_1066MHz,
+					&skov_dol63x_cfg_4x128Mb_1066MHz);
+		break;
+	case 12:/* P2 i.MX6Q, max performance */
+		if (cpu_type != IMX6_CPUTYPE_IMX6Q) {
+			pr_err("Invalid SoC! i.MX6Q expected\n");
+			return;
+		}
+		pr_debug("Initializing a P2 max performance system...\n");
+		spl_imx6q_dram_init(&skov_dol63x_sysinfo_4x256Mb_1066MHz,
+					&skov_dol63x_calib_4x256Mb_1066MHz,
+					&skov_dol63x_cfg_4x256Mb_1066MHz);
+		break;
+	case 13:	/* P3 i.MX6S, low cost  */
+		if (cpu_type != IMX6_CPUTYPE_IMX6S) {
+			pr_err("Invalid SoC! i.MX6S expected\n");
+			return;
+		}
+		pr_debug("Initializing a P3 low cost system...\n");
+		spl_imx6sdl_dram_init(&skov_dol63x_sysinfo_2x128Mb_800MHz,
+					&skov_dol63x_calib_2x128Mb_800MHz,
+					&skov_dol63x_cfg_2x128Mb_800MHz);
+		break;
+	case 14:	/* P3 i.MX6Q, high performance */
+		if (cpu_type != IMX6_CPUTYPE_IMX6Q) {
+			pr_err("Invalid SoC! i.MX6Q expected\n");
+			return;
+		}
+		pr_debug("Initializing a P3 high performance system...\n");
+		spl_imx6q_dram_init(&skov_dol63x_sysinfo_4x128Mb_1066MHz,
+					&skov_dol63x_calib_4x128Mb_1066MHz,
+					&skov_dol63x_cfg_4x128Mb_1066MHz);
+		break;
+	case 15: /* P3 i.MX6S, middle performance */
+		if (cpu_type != IMX6_CPUTYPE_IMX6S) {
+			pr_err("Invalid SoC! i.MX6S expected\n");
+			return;
+		}
+		pr_debug("Initializing a P3 middle performance system...\n");
+		spl_imx6sdl_dram_init(&skov_dol63x_sysinfo_2x128Mb_800MHz,
+					&skov_dol63x_calib_2x128Mb_800MHz,
+					&skov_dol63x_cfg_2x128Mb_800MHz);
+		break;
+	default:
+		pr_err("Unsupported board revision: 0x%x\n", board_rev);
+		/* FIXME don't continue */
+		break;
+	}
+
+	pr_info("Loading bootloader image from SD card...");
+	imx6_esdhc_start_image(SKOV_DOL63X_SDHC_CHANNEL);
+	pr_info("failed\nLoading bootloader image from SPI flash...");
+	imx6_spi_start_image(SKOV_DOL63X_NOR_CHANNEL);
+	pr_info("failed. No valid boot source found. Giving up\n");
+}
+
+extern char __dtb_z_imx6q_skov_dol63x_start[];
+extern char __dtb_z_imx6dl_skov_dol63x_start[];
+
+/* called twice: once for SDRAM setup only, second for devicetree setup */
+static noinline void skov_dol63x_start(void)
+{
+	int cpu_type = __imx6_cpu_type();
+
+	if (get_pc() <= MX6_MMDC_PORT0_BASE_ADDR) {
+		/* first call: do the lowlevel things first */
+		setup_leds(cpu_type);
+		setup_uart(cpu_type);
+		pr_info("Starting to init DOL63x system...\n");
+		skov_dol63x_init(cpu_type);
+		pr_err("Unable to start bootloader\n");
+		while(1)
+			;
+	}
+
+	/* boot this platform (second call) */
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		pr_debug("Startup i.MX6S/DL based system...\n");
+		imx6q_barebox_entry(__dtb_z_imx6dl_skov_dol63x_start);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		pr_debug("Startup i.MX6Q based system...\n");
+		imx6q_barebox_entry(__dtb_z_imx6q_skov_dol63x_start);
+		break;
+	}
+}
+
+ENTRY_FUNCTION(start_imx6_skov_dol63x, r0, r1, r2)
+{
+	arm_cpu_lowlevel_init();
+
+	relocate_to_current_adr();
+	setup_c();
+	barrier();
+
+	skov_dol63x_start();
+}
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index c87bd936604e..d6c17fb500bb 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -46,6 +46,7 @@ pbl-dtb-$(CONFIG_MACH_RADXA_ROCK) += rk3188-radxarock.dtb.o
 pbl-dtb-$(CONFIG_MACH_REALQ7) += imx6q-dmo-edmqmx6.dtb.o
 pbl-dtb-$(CONFIG_MACH_SABRELITE) += imx6q-sabrelite.dtb.o imx6dl-sabrelite.dtb.o
 pbl-dtb-$(CONFIG_MACH_SABRESD) += imx6q-sabresd.dtb.o
+pbl-dtb-$(CONFIG_MACH_SKOV_DOL63X) += imx6dl-skov-dol63x.dtb.o imx6q-skov-dol63x.dtb.o
 pbl-dtb-$(CONFIG_MACH_FREESCALE_IMX6SX_SABRESDB) += imx6sx-sdb.dtb.o
 pbl-dtb-$(CONFIG_MACH_SOCFPGA_ALTERA_SOCDK) += socfpga_cyclone5_socdk.dtb.o
 pbl-dtb-$(CONFIG_MACH_SOCFPGA_EBV_SOCRATES) += socfpga_cyclone5_socrates.dtb.o
diff --git a/arch/arm/dts/imx6dl-skov-dol63x.dts b/arch/arm/dts/imx6dl-skov-dol63x.dts
new file mode 100644
index 000000000000..c3944efb3d25
--- /dev/null
+++ b/arch/arm/dts/imx6dl-skov-dol63x.dts
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2015 Juergen Borleis, Pengutronix <kernel@pengutronix.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include <arm/imx6dl.dtsi>
+#include "imx6qdl-skov-dol63x.dtsi"
+
+/ {
+	model = "Skov DOL63x";
+	compatible = "skov,dol63x", "fsl,imx6dl";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+};
diff --git a/arch/arm/dts/imx6q-skov-dol63x.dts b/arch/arm/dts/imx6q-skov-dol63x.dts
new file mode 100644
index 000000000000..d0c72b70e290
--- /dev/null
+++ b/arch/arm/dts/imx6q-skov-dol63x.dts
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2015 Juergen Borleis, Pengutronix <kernel@pengutronix.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6q.dtsi"
+#include <arm/imx6q.dtsi>
+#include "imx6qdl-skov-dol63x.dtsi"
+
+/ {
+	model = "Skov DOL63x";
+	compatible = "skov,dol63x", "fsl,imx6q";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+};
diff --git a/arch/arm/dts/imx6qdl-skov-dol63x.dtsi b/arch/arm/dts/imx6qdl-skov-dol63x.dtsi
new file mode 100644
index 000000000000..8b6ccf87e6a7
--- /dev/null
+++ b/arch/arm/dts/imx6qdl-skov-dol63x.dtsi
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2015 Juergen Borleis, Pengutronix <kernel@pengutronix.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/ {
+	barebox_environment {
+		compatible = "barebox,environment";
+		device-path = &barebox_env;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led0: D1 {
+			label = "D1";
+			gpios = <&gpio1 2 0>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+
+		led1: D2 {
+			label = "D2";
+			gpios = <&gpio1 0 0>; 
+			default-state = "off";
+		};
+
+		led2: D3 {
+			label = "D3";
+			gpios = <&gpio1 4 0>;
+			default-state = "on";
+		};
+	};
+
+	skov_version {
+		compatible = "skov-version";
+		v0-gpio = <&gpio2 10 0>;
+		v1-gpio = <&gpio2 15 0>;
+		v2-gpio = <&gpio2 8 0>; 
+		v3-gpio = <&gpio2 9 0>; 
+		v4-gpio = <&gpio2 12 0>;
+		v5-gpio = <&gpio2 14 0>;
+		v6-gpio = <&gpio2 11 0>;
+		v7-gpio = <&gpio2 13 0>;
+	};	
+
+	/* State: immutable part */
+	bootstate: bootstate {
+		compatible = "barebox,bootstate";
+		backend-type = "state";
+		backend = <&state>;
+
+		system0 { /* the node's name here must match the subnode's name in the 'state' node */
+			default_attempts = <3>;
+			boot = "/dev/nand0.ubi.system0"; /* must be in conjunction with the runtime path */
+		};
+
+		system1 { /* the node's name here must match the subnode's name in the 'state' node */
+			default_attempts = <3>;
+			boot = "/dev/nand0.ubi.system1"; /* must be in conjunction with the runtime path */
+		};
+	};
+
+	/* State: mutable part */
+	state: state {
+		magic = <0x4d433230>;
+		compatible = "barebox,state";
+		backend-type = "raw";
+		backend = <&state_storage>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		bootstate {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			system0 { /* the node's name here must match the subnode's name in the 'bootstate' node */
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				remaining_attempts {
+					reg = <0x0 0x4>;
+					type = "uint32";
+				};
+				priority {
+					reg = <0x4 0x4>;
+					type = "uint32";
+				};
+				ok {
+					reg = <0x8 0x4>;
+					type = "uint32";
+				};
+			};
+
+			system1 { /* the node's name here must match the subnode's name in the 'bootstate' node */
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				remaining_attempts {
+					reg = <0x10 0x4>;
+					type = "uint32";
+				};
+				priority {
+					reg = <0x14 0x4>;
+					type = "uint32";
+				};
+				ok {
+					reg = <0x18 0x4>;
+					type = "uint32";
+				};
+			};
+
+			watchdog_timeout {
+				reg = <0x20 0x4>;
+				type = "uint32";
+				default = <60>;
+			};
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
+			MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
+		>;
+	};
+
+	pinctrl_ecspi1: ecspi1grp {
+		fsl,pins = <
+			MX6QDL_PAD_EIM_D17__ECSPI1_MISO 0x100b1
+			MX6QDL_PAD_EIM_D18__ECSPI1_MOSI 0x100b1
+			MX6QDL_PAD_EIM_D16__ECSPI1_SCLK 0x100b1
+			MX6QDL_PAD_EIM_D24__GPIO3_IO24 0x100b1 /* CS# signal */
+		>;
+	};
+
+	/* pins for eth0 */
+	pinctrl_enet: enetgrp {
+		fsl,pins = <
+			MX6QDL_PAD_ENET_MDIO__ENET_MDIO 0x100b0
+			MX6QDL_PAD_ENET_MDC__ENET_MDC 0x100b0
+			MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN 0x100b0
+			MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN 0x100b0
+			MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0 0x100b0
+			MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1 0x100b0
+			MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0 0x100b0
+			MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1 0x100b0
+			MX6QDL_PAD_GPIO_16__ENET_REF_CLK 0x400000c0
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX6QDL_PAD_SD3_CMD__SD3_CMD 0x17059
+			MX6QDL_PAD_SD3_CLK__SD3_CLK 0x10059
+			MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
+			MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
+			MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
+			MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
+			MX6QDL_PAD_SD3_DAT4__GPIO7_IO01 0x17059 /* WP */
+			MX6QDL_PAD_SD3_DAT5__GPIO7_IO00 0x1b0b0 /* CD */
+		>;
+	};
+
+	pinctrl_gpmi_nand: gpminandgrp {
+		fsl,pins = <
+			MX6QDL_PAD_NANDF_CLE__NAND_CLE 0xb0b1
+			MX6QDL_PAD_NANDF_ALE__NAND_ALE 0xb0b1
+			MX6QDL_PAD_NANDF_RB0__NAND_READY_B 0xb000
+			MX6QDL_PAD_NANDF_CS0__NAND_CE0_B 0xb0b1
+			MX6QDL_PAD_NANDF_CS1__NAND_CE1_B 0xb0b1
+			MX6QDL_PAD_SD4_CMD__NAND_RE_B 0xb0b1
+			MX6QDL_PAD_SD4_CLK__NAND_WE_B 0xb0b1
+			MX6QDL_PAD_NANDF_D0__NAND_DATA00 0xb0b1
+			MX6QDL_PAD_NANDF_D1__NAND_DATA01 0xb0b1
+			MX6QDL_PAD_NANDF_D2__NAND_DATA02 0xb0b1
+			MX6QDL_PAD_NANDF_D3__NAND_DATA03 0xb0b1
+			MX6QDL_PAD_NANDF_D4__NAND_DATA04 0xb0b1
+			MX6QDL_PAD_NANDF_D5__NAND_DATA05 0xb0b1
+			MX6QDL_PAD_NANDF_D6__NAND_DATA06 0xb0b1
+			MX6QDL_PAD_NANDF_D7__NAND_DATA07 0xb0b1
+		>;
+	};
+};
+
+/* console */
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+/* spi */
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 24 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "okay";
+
+	norflash: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,n25q064", "st,m25p";
+		spi-max-frequency = <54000000>;
+		reg = <0>;
+	};
+};
+
+/* eth0 */
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rmii";
+	status = "okay";
+	phy-reset-gpios = <&gpio1 5 0>;
+	phy-reset-duration = "100";
+	#address-cells = <0>;
+	#size-cells = <1>;
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&wdog1 {
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	wp-gpios = <&gpio7 1 0>;
+	cd-gpios = <&gpio7 0 0>;
+	status = "okay";
+	fsl,delay-line;
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand>;
+	nand-on-flash-bbt;
+	status = "okay";
+};
+
+/* define the SPI based 8 MiB NOR flash layout */
+&norflash {
+	partition@0 {
+		label = "barebox";
+		reg = <0x0 0x100000>;
+	};
+
+	/* space left to let barebox grow */
+
+	/* placed near the end of the NOR memory */
+	barebox_env: partition@780000 {
+		label = "barebox-environment";
+		reg = <0x780000 0x40000>;
+	};
+
+	/* placed at the end of the NOR memory */
+	state_storage: partition@7C0000 {
+		label = "barebox-state";
+		reg = <0x7C0000 0x40000>; /* four times mirrored */
+	};
+};
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index 0a7b517b4c5f..1bc7b6ec5217 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -359,6 +359,11 @@ config MACH_CM_FX6
 	bool "CM FX6"
 	select ARCH_IMX6
 
+config MACH_SKOV_DOL63X
+	bool "Skov DOL63x"
+	select ARCH_IMX6
+	select ARM_USE_COMPRESSED_DTB
+
 endif
 
 # ----------------------------------------------------------
diff --git a/images/Makefile.imx b/images/Makefile.imx
index a09afd695bee..466f9b4f3cdb 100644
--- a/images/Makefile.imx
+++ b/images/Makefile.imx
@@ -282,6 +282,11 @@ CFG_start_phytec_pbaa03_2gib.pblx.imximg = $(board)/phytec-phycard-imx6/flash-he
 FILE_barebox-phytec-pbaa03-2gib.img = start_phytec_pbaa03_2gib.pblx.imximg
 image-$(CONFIG_MACH_PCAAXL3) += barebox-phytec-pbaa03-2gib.img
 
+pblx-$(CONFIG_MACH_SKOV_DOL63X) += start_imx6_skov_dol63x
+CFG_start_imx6_skov_dol63x.imx-sram-img = $(board)/skov-dol63x/flash-header-mx6-skol-dol63x.imxcfg
+FILE_barebox-skov-dol63x.img = start_imx6_skov_dol63x.imx-sram-img
+image-$(CONFIG_MACH_SKOV_DOL63X) += barebox-skov-dol63x.img
+
 pblx-$(CONFIG_MACH_GW_VENTANA) += start_imx6q_gw54xx_1gx64
 CFG_start_imx6q_gw54xx_1gx64.pblx.imximg = $(board)/gateworks-ventana/flash-header-ventana-quad-1gx64.imxcfg
 FILE_barebox-gateworks-imx6q-ventana-1gx64.img = start_imx6q_gw54xx_1gx64.pblx.imximg
-- 
2.1.4

