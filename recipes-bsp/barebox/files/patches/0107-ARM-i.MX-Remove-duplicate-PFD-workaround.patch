From: Sascha Hauer <s.hauer@pengutronix.de>
Date: Tue, 8 Mar 2022 12:20:04 +0100
Subject: [PATCH] ARM: i.MX: Remove duplicate PFD workaround

The i.MX6Q and i.MX6D SoC variants need a workaround for broken PFDs.
That was added to the architecture code in f1f6d76 ("ARM: i.MX6: correct
work flow of PFDs from uboot-sources") and then added again in b534f79
("clk: imx6: Fix procedure to switch the parent of LDB_DI_CLK"). We only
need this once, so remove the workaround in the architecture code.

Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
---
 arch/arm/mach-imx/imx6.c | 43 -------------------------------------------
 1 file changed, 43 deletions(-)

diff --git a/arch/arm/mach-imx/imx6.c b/arch/arm/mach-imx/imx6.c
index 92d3e14ba1c5..32aac3a90fa1 100644
--- a/arch/arm/mach-imx/imx6.c
+++ b/arch/arm/mach-imx/imx6.c
@@ -35,13 +35,6 @@ static void imx6_init_lowlevel(void)
 {
 	void __iomem *aips1 = (void *)MX6_AIPS1_ON_BASE_ADDR;
 	void __iomem *aips2 = (void *)MX6_AIPS2_ON_BASE_ADDR;
-	bool is_imx6q = __imx6_cpu_type() == IMX6_CPUTYPE_IMX6Q;
-	bool is_imx6d = __imx6_cpu_type() == IMX6_CPUTYPE_IMX6D;
-	uint32_t val_480;
-	uint32_t val_528;
-	uint32_t periph_sel_1;
-	uint32_t periph_sel_2;
-	uint32_t reg;
 
 	/*
 	 * Before reset the controller imx6_boot_save_loc() must be called to
@@ -70,42 +63,6 @@ static void imx6_init_lowlevel(void)
 	writel(0, aips2 + 0x48);
 	writel(0, aips2 + 0x4c);
 	writel(0, aips2 + 0x50);
-
-	/* Due to hardware limitation, on MX6Q we need to gate/ungate all PFDs
-	 * to make sure PFD is working right, otherwise, PFDs may
-	 * not output clock after reset, MX6DL and MX6SL have added 396M pfd
-	 * workaround in ROM code, as bus clock need it.
-	 * Don't reset PLL2 PFD0 / PLL2 PFD2 if is's used by periph_clk.
-	 */
-	if (is_imx6q || is_imx6d) {
-		val_480 = BM_ANADIG_PFD_480_PFD3_CLKGATE |
-			   BM_ANADIG_PFD_480_PFD2_CLKGATE |
-			   BM_ANADIG_PFD_480_PFD1_CLKGATE |
-			   BM_ANADIG_PFD_480_PFD0_CLKGATE;
-
-		val_528 = BM_ANADIG_PFD_528_PFD3_CLKGATE |
-			   BM_ANADIG_PFD_528_PFD1_CLKGATE;
-
-		reg = readl(MXC_CCM_CBCMR);
-		periph_sel_1 = (reg & MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_MASK)
-			>> MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_OFFSET;
-
-		periph_sel_2 = (reg & MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_MASK)
-			>> MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_OFFSET;
-
-		if ((periph_sel_1 != 0x2) && (periph_sel_2 != 0x2))
-			val_528 |= BM_ANADIG_PFD_528_PFD0_CLKGATE;
-
-		if ((periph_sel_1 != 0x1) && (periph_sel_2 != 0x1)
-		    && (periph_sel_1 != 0x3) && (periph_sel_2 != 0x3))
-			val_528 |= BM_ANADIG_PFD_528_PFD2_CLKGATE;
-
-		writel(val_480, MX6_ANATOP_BASE_ADDR + HW_ANADIG_PFD_480_SET);
-		writel(val_528, MX6_ANATOP_BASE_ADDR + HW_ANADIG_PFD_528_SET);
-
-		writel(val_480, MX6_ANATOP_BASE_ADDR + HW_ANADIG_PFD_480_CLR);
-		writel(val_528, MX6_ANATOP_BASE_ADDR + HW_ANADIG_PFD_528_CLR);
-	}
 }
 
 static bool imx6_has_ipu(void)
