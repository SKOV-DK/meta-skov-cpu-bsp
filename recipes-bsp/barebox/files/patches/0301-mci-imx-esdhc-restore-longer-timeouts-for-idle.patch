From: Ahmad Fatoum <a.fatoum@pengutronix.de>
Date: Wed, 2 Jul 2025 12:59:46 +0200
Subject: [PATCH] mci: imx-esdhc: restore longer timeouts for idle

Commit 02986964885c ("mci: imx-esdhc: implement esdhc_poll using
sdhci_read32_poll_timeout") introduces sdhci_compute_timeout() which
takes a default timeout, but that default timeout is ignored in the
function.

Commit bbecd0b7bb7e ("mci: sdhci: add support for struct mci_data::timeout_ns")
then makes use of this function and with this breaks the polling for DATA0
line by reducing the original 2.5s timeout to SDHCI_CMD_DEFAULT_BUSY_TIMEOUT_NS
which is 10ms.

With this writing to the card times out during a MMC_CMD_STOP_TRANSMISSION
command, observed on i.MX6ul.

All these timeouts print errors and are not expected to trigger in
normal operation, therefore just make the hardcoded timeouts in the
driver the new minimum.

Fixes: 02986964885c ("mci: imx-esdhc: implement esdhc_poll using sdhci_read32_poll_timeout")
Fixes: bbecd0b7bb7e ("mci: sdhci: add support for struct mci_data::timeout_ns")
Reported-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
---
 drivers/mci/imx-esdhc-common.c | 6 +++---
 drivers/mci/sdhci.c            | 2 +-
 drivers/mci/sdhci.h            | 4 +---
 3 files changed, 5 insertions(+), 7 deletions(-)

diff --git a/drivers/mci/imx-esdhc-common.c b/drivers/mci/imx-esdhc-common.c
index 228f4a9b03fe..66f3edc670e0 100644
--- a/drivers/mci/imx-esdhc-common.c
+++ b/drivers/mci/imx-esdhc-common.c
@@ -394,7 +394,7 @@ int __esdhc_send_cmd(struct fsl_esdhc_host *host, struct mci_cmd *cmd,
 		 */
 		ret = esdhc_poll(host, SDHCI_PRESENT_STATE, val,
 				 val & PRSSTAT_DAT0,
-				 sdhci_compute_timeout(cmd, NULL, 2500 * MSECOND));
+				 max_t(u64, sdhci_compute_timeout(cmd, NULL), 2500 * MSECOND));
 		if (ret) {
 			dev_err(host->dev, "timeout PRSSTAT_DAT0\n");
 			goto undo_setup_data;
@@ -419,7 +419,7 @@ int __esdhc_send_cmd(struct fsl_esdhc_host *host, struct mci_cmd *cmd,
 	/* Wait for the bus to be idle */
 	ret = esdhc_poll(host, SDHCI_PRESENT_STATE, val,
 			 (val & (SDHCI_CMD_INHIBIT_CMD | SDHCI_CMD_INHIBIT_DATA)) == 0,
-			 sdhci_compute_timeout(cmd, data, SECOND));
+			 max_t(u64, sdhci_compute_timeout(cmd, data), SECOND));
 	if (ret) {
 		dev_err(host->dev, "timeout 2\n");
 		return -ETIMEDOUT;
@@ -427,7 +427,7 @@ int __esdhc_send_cmd(struct fsl_esdhc_host *host, struct mci_cmd *cmd,
 
 	ret = esdhc_poll(host, SDHCI_PRESENT_STATE, val,
 			 (val & SDHCI_DATA_LINE_ACTIVE) == 0,
-			 sdhci_compute_timeout(cmd, NULL, 100 * MSECOND));
+			 max_t(u64, sdhci_compute_timeout(cmd, NULL), 100 * MSECOND));
 	if (ret) {
 		dev_err(host->dev, "timeout 3\n");
 		return -ETIMEDOUT;
diff --git a/drivers/mci/sdhci.c b/drivers/mci/sdhci.c
index 17847a13ed5f..9bf886dfe3f4 100644
--- a/drivers/mci/sdhci.c
+++ b/drivers/mci/sdhci.c
@@ -836,7 +836,7 @@ int sdhci_wait_idle(struct sdhci *host, struct mci_cmd *cmd, struct mci_data *da
 		    mmc_op_tuning(cmd->cmdidx)))
 		mask &= ~SDHCI_CMD_INHIBIT_DATA;
 
-	timeout_ns = sdhci_compute_timeout(cmd, data, SDHCI_CMD_DEFAULT_BUSY_TIMEOUT_NS);
+	timeout_ns = sdhci_compute_timeout(cmd, data);
 
 	ret = wait_on_timeout(timeout_ns,
 			!(sdhci_read32(host, SDHCI_PRESENT_STATE) & mask));
diff --git a/drivers/mci/sdhci.h b/drivers/mci/sdhci.h
index 25d257b23145..ec82b1b8ff9a 100644
--- a/drivers/mci/sdhci.h
+++ b/drivers/mci/sdhci.h
@@ -372,12 +372,10 @@ void sdhci_set_bus_width(struct sdhci *host, int width);
  * sdhci_compute_timeout() - compute suitable timeout for operation
  * @cmd: MCI command being sent, can be NULL
  * @data: MCI data being sent, can be NULL
- * @default_timeout: fallback value
  *
  * Return: the number of nanoseconds to wait.
  */
-static inline ktime_t sdhci_compute_timeout(struct mci_cmd *cmd, struct mci_data *data,
-					    ktime_t default_timeout)
+static inline ktime_t sdhci_compute_timeout(struct mci_cmd *cmd, struct mci_data *data)
 {
 	if (data && data->timeout_ns != 0)
 		return data->timeout_ns;
