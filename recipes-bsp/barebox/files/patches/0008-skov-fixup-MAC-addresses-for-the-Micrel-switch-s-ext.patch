From: =?UTF-8?q?Ulrich=20=C3=96lmann?= <u.oelmann@pengutronix.de>
Date: Thu, 27 Aug 2020 12:58:41 +0200
Subject: [PATCH] skov: fixup MAC-addresses for the Micrel switch's external
 ports
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

To be able to use the Micrel switch's external ports independently (without
being combined into a hardware assisted software bridge) each of them needs a
unique MAC-address. As in that setup the fec (eth0) is unable to send packets to
the outside world one can re-use its MAC-address for the first port (eth1). Look
up the MAC-Address for the second port (eth2) in barebox' state. If it is not
changed from its default value in the devicetree (00:11:22:33:44:55) then
transplant the fec's MAC-address to the second port as well (either both ports
are combined into a bridge or they are connected to different subnets so that a
doubled MAC-address does no harm as well). Finally provide them to Linux by
fixing up the kernel devicetree.

Signed-off-by: Ulrich Ã–lmann <u.oelmann@pengutronix.de>
---
 arch/arm/boards/skov-imx6/board.c   | 113 ++++++++++++++++++++++++++++++++++++
 arch/arm/dts/imx6qdl-skov-imx6.dtsi |  11 ++++
 2 files changed, 124 insertions(+)

diff --git a/arch/arm/boards/skov-imx6/board.c b/arch/arm/boards/skov-imx6/board.c
index 9d25ff245dcb..ae5596fba05c 100644
--- a/arch/arm/boards/skov-imx6/board.c
+++ b/arch/arm/boards/skov-imx6/board.c
@@ -19,6 +19,7 @@
 #include <environment.h>
 #include <i2c/i2c.h>
 #include <bootsource.h>
+#include <net.h>
 
 /*
  * This initcall needs to be executed before coredevices, so we have a chance to
@@ -71,6 +72,114 @@ static int skov_imx6_fixup_display(void)
 }
 fs_initcall(skov_imx6_fixup_display);
 
+static int eth_of_fixup_node(struct device_node *root, const char *node_path, const u8 *ethaddr)
+{
+	struct device_node *node;
+	int ret;
+
+	if (!is_valid_ether_addr(ethaddr)) {
+		unsigned char ethaddr_str[sizeof("xx:xx:xx:xx:xx:xx")];
+
+		ethaddr_to_string(ethaddr, ethaddr_str);
+		pr_err("The mac-address %s is invalid.\n", ethaddr_str);
+		return -EINVAL;
+	}
+
+	node = of_find_node_by_path_from(root, node_path);
+	if (!node) {
+		pr_err("Did not find node %s to fix up with stored mac-address.\n",
+		       node_path);
+		return -ENOENT;
+	}
+
+	ret = of_set_property(node, "mac-address", ethaddr, ETH_ALEN, 1);
+	if (ret)
+		pr_err("Setting mac-address property of %s failed with: %s.\n",
+		       node->full_name, strerror(-ret));
+
+	return ret;
+}
+
+static int eth_of_fixup_node_from_eth_device(struct device_node *root, const char *node_path,
+        const char *ethname)
+{
+	struct eth_device *edev;
+
+	edev = eth_get_byname(ethname);
+	if (!edev) {
+		pr_err("Did not find eth device \"%s\" to copy mac-address from.\n", ethname);
+		return -ENOENT;
+	}
+
+	return eth_of_fixup_node(root, node_path, edev->ethaddr);
+}
+
+static int get_mac_address_from_env_variable(const char *env, u8 ethaddr[ETH_ALEN])
+{
+	const char *ethaddr_str;
+	int ret;
+
+	ethaddr_str = getenv(env);
+	if (!ethaddr_str) {
+		pr_err("State variable %s storing the mac-address not found.\n", env);
+		return -ENOENT;
+	}
+
+	ret = string_to_ethaddr(ethaddr_str, ethaddr);
+	if (ret < 0) {
+		pr_err("Could not convert value \"%s\" found in state variable %s into mac-address.\n",
+		       ethaddr_str, env);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int get_default_mac_address_from_state_node(const char *state_node_path, u8 ethaddr[ETH_ALEN])
+{
+	struct device_node *node;
+	int ret;
+
+	node = of_find_node_by_path(state_node_path);
+	if (!node) {
+		pr_err("Node %s defining the state variable not found.\n", state_node_path);
+		return -ENOENT;
+	}
+
+	ret = of_property_read_u8_array(node, "default", ethaddr, ETH_ALEN);
+	if (ret) {
+		pr_err("Node %s has no property \"default\" of proper type.\n", state_node_path);
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+static int eth2_of_fixup_node_individually(struct device_node *root, const char *node_path,
+		const char *ethname, const char *env, const char *state_node_path)
+{
+	u8 env_ethaddr[ETH_ALEN], default_ethaddr[ETH_ALEN];
+	int ret;
+
+	ret = get_mac_address_from_env_variable(env, env_ethaddr);
+	if (ret)
+		goto copy_mac_from_eth0;
+
+	ret = get_default_mac_address_from_state_node(state_node_path, default_ethaddr);
+	if (ret)
+		goto copy_mac_from_eth0;
+
+	/* As the default is bogus copy the MAC address from eth0 if */
+	/* the state variable has not been set to a different value  */
+	if (memcmp(env_ethaddr, default_ethaddr, ETH_ALEN) == 0)
+		goto copy_mac_from_eth0;
+
+	return eth_of_fixup_node(root, node_path, env_ethaddr);
+
+copy_mac_from_eth0:
+	return eth_of_fixup_node_from_eth_device(root, node_path, ethname);
+}
+
 static int skov_imx6_fixup(struct device_node *root, void *unused)
 {
 	int ret;
@@ -78,6 +187,10 @@ static int skov_imx6_fixup(struct device_node *root, void *unused)
 	uint32_t brightness;
 	struct device_node *node;
 
+	eth_of_fixup_node_from_eth_device(root, "/mdio-gpio/ksz8873@3/ports/ports@0", "eth0");
+	eth2_of_fixup_node_individually(root, "/mdio-gpio/ksz8873@3/ports/ports@1", "eth0",
+		"state.ethaddr.eth2", "/state/ethaddr/eth2");
+
 	switch (bootsource_get()) {
 	case BOOTSOURCE_MMC:
 		/* use default value of state variable defined in devicetree */
diff --git a/arch/arm/dts/imx6qdl-skov-imx6.dtsi b/arch/arm/dts/imx6qdl-skov-imx6.dtsi
index 0cd6674af2a3..052f64460bd7 100644
--- a/arch/arm/dts/imx6qdl-skov-imx6.dtsi
+++ b/arch/arm/dts/imx6qdl-skov-imx6.dtsi
@@ -139,6 +139,17 @@
 				default = <0>;
 			};
 		};
+
+		ethaddr {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			eth2 {
+				reg = <0x1E 0x6>;
+				type = "mac";
+				default = [00 11 22 33 44 55];
+			};
+		};
 	};
 
 	backlight_lcd: backlight_lcd {
