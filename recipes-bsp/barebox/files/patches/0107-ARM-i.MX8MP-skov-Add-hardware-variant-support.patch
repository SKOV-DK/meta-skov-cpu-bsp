From: Oleksij Rempel <o.rempel@pengutronix.de>
Date: Wed, 27 Sep 2023 13:00:18 +0200
Subject: [PATCH] ARM: i.MX8MP: skov: Add hardware variant support

Introduce hardware variant detection in skov-imx8mp board. This
addition uses GPIOs to identify hardware versions and set the
appropriate device tree compatible strings accordingly.

Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
---
 arch/arm/boards/skov-imx8mp/board.c | 128 ++++++++++++++++++++++++++++++++++++
 1 file changed, 128 insertions(+)

diff --git a/arch/arm/boards/skov-imx8mp/board.c b/arch/arm/boards/skov-imx8mp/board.c
index 58aca6923603..3a1cd83bbd43 100644
--- a/arch/arm/boards/skov-imx8mp/board.c
+++ b/arch/arm/boards/skov-imx8mp/board.c
@@ -1,14 +1,30 @@
 // SPDX-License-Identifier: GPL-2.0
 
+#include "linux/kernel.h"
 #include <bootsource.h>
 #include <common.h>
 #include <deep-probe.h>
 #include <envfs.h>
+#include <environment.h>
+#include <globalvar.h>
+#include <gpio.h>
 #include <init.h>
 #include <io.h>
 #include <mach/imx/bbu.h>
+#include <mach/imx/generic.h>
 #include <mach/imx/iomux-mx8mp.h>
 
+#define GPIO_HW_VARIANT  {\
+	{IMX_GPIO_NR(1, 8), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var0"}, \
+	{IMX_GPIO_NR(1, 9), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var1"}, \
+	{IMX_GPIO_NR(1, 10), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var2"}, \
+	{IMX_GPIO_NR(1, 11), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var3"}, \
+	{IMX_GPIO_NR(1, 12), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var4"}, \
+	{IMX_GPIO_NR(1, 13), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var5"}, \
+	{IMX_GPIO_NR(1, 14), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var6"}, \
+	{IMX_GPIO_NR(1, 15), GPIOF_DIR_IN | GPIOF_ACTIVE_HIGH, "var7"}, \
+}
+
 struct skov_imx8mp_storage {
 	const char *name;
 	const char *env_path;
@@ -43,6 +59,116 @@ static const struct skov_imx8mp_storage skov_imx8mp_storages[] = {
 	},
 };
 
+struct board_description {
+	const char *dts_compatible;
+	const char *dts_compatible_hdmi;
+	unsigned flags;
+};
+
+#define SKOV_IMX8MP_HAS_HDMI	BIT(0)
+
+static const struct board_description imx8mp_variants[] = {
+	[0] = {
+		.dts_compatible = "skov,imx8mp-skov-revb-lt6",
+	},
+	[1] = {
+		.dts_compatible = "skov,imx8mp-skov-revb-mi1010ait-1cp1",
+		.dts_compatible_hdmi = "skov,imx8mp-skov-revb-hdmi",
+		.flags = SKOV_IMX8MP_HAS_HDMI,
+	},
+};
+
+static int skov_imx8mp_get_variant_id(uint *id)
+{
+	struct gpio gpios_rev[] = GPIO_HW_VARIANT;
+	struct device_node *gpio_np;
+	u32 hw_rev;
+	int ret;
+
+	gpio_np = of_find_node_by_name_address(NULL, "gpio@30200000");
+	if (!gpio_np)
+		return -ENODEV;
+
+	ret = of_device_ensure_probed(gpio_np);
+	if (ret)
+		return ret;
+
+	ret = gpio_array_to_id(gpios_rev, ARRAY_SIZE(gpios_rev), &hw_rev);
+	if (ret)
+		goto exit_get_id;
+
+	*id = hw_rev;
+
+	return 0;
+exit_get_id:
+	pr_err("Failed to read gpio ID: %pe\n", ERR_PTR(ret));
+	return ret;
+}
+
+static int skov_imx8mp_get_hdmi(struct device *dev)
+{
+	const char *env = "state.display.external";
+	struct device_node *state_np;
+	unsigned int val = 0;
+	int ret;
+
+	state_np = of_find_node_by_name_address(NULL, "state");
+	if (!state_np) {
+		dev_err(dev, "Failed to find state node\n");
+		return -ENODEV;
+	}
+
+	ret = of_device_ensure_probed(state_np);
+	if (ret) {
+		dev_err(dev, "Failed to probe state node: %pe\n", ERR_PTR(ret));
+		return ret;
+	}
+
+	ret = getenv_uint(env, &val);
+	if (ret) {
+		dev_err(dev, "Failed to read %s: %pe\n", env, ERR_PTR(ret));
+		return ret;
+	}
+
+	return val;
+}
+
+static int skov_imx8mp_init_variant(struct device *dev)
+{
+	const struct board_description *variant;
+	const char *compatible;
+	unsigned int v = 0;
+	int ret;
+
+	ret = skov_imx8mp_get_variant_id(&v);
+	if (ret)
+		return ret;
+
+	if (v >= ARRAY_SIZE(imx8mp_variants)) {
+		dev_err(dev, "Invalid variant %u\n", v);
+		return -EINVAL;
+	}
+
+	variant = &imx8mp_variants[v];
+
+	if (variant->flags & SKOV_IMX8MP_HAS_HDMI) {
+		ret = skov_imx8mp_get_hdmi(dev);
+		if (ret < 0)
+			return ret;
+
+		if (ret)
+			compatible = variant->dts_compatible_hdmi;
+		else
+			compatible = variant->dts_compatible;
+	} else {
+		compatible = variant->dts_compatible;
+	}
+
+	of_prepend_machine_compatible(NULL, compatible);
+
+	return 0;
+}
+
 static void skov_imx8mp_enable_env(struct device *dev,
 				   const struct skov_imx8mp_storage *st,
 				   bool *enabled)
@@ -110,6 +236,8 @@ static int skov_imx8mp_probe(struct device *dev)
 {
 	skov_imx8mp_init_storage(dev);
 
+	skov_imx8mp_init_variant(dev);
+
 	return 0;
 }
 
