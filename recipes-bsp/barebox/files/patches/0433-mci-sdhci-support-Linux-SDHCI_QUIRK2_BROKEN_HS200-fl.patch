From: Ahmad Fatoum <a.fatoum@pengutronix.de>
Date: Sun, 4 May 2025 17:02:33 +0200
Subject: [PATCH] mci: sdhci: support Linux SDHCI_QUIRK2_BROKEN_HS200 flag

In Linux HS200 is op-out for SDHCI. Let's do the same in barebox.
We intentionally keep MMC_CAP2_HS200 for Arasan, as I have not verified
on the hardware that the SDHCI implementation there correctly reports
SDR104 as supported (which would imply HS200 when used for eMMC).

Upstream-Status: Pending

Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
---
 drivers/mci/am654-sdhci.c            |  3 +++
 drivers/mci/arasan-sdhci.c           |  3 +++
 drivers/mci/dwcmshc-sdhci.c          |  2 ++
 drivers/mci/imx-esdhc.c              |  3 +++
 drivers/mci/rockchip-dwcmshc-sdhci.c |  3 +++
 drivers/mci/sdhci.c                  | 32 ++++++++++++++++++++++++++++++++
 drivers/mci/sdhci.h                  |  4 ++++
 7 files changed, 50 insertions(+)

diff --git a/drivers/mci/am654-sdhci.c b/drivers/mci/am654-sdhci.c
index 13c8876573c7..be0a6e09f796 100644
--- a/drivers/mci/am654-sdhci.c
+++ b/drivers/mci/am654-sdhci.c
@@ -638,6 +638,9 @@ static int am654_sdhci_probe(struct device *dev)
 	if (ret)
 		return ret;
 
+	/* HS200 not supported by this driver at the moment */
+	plat->sdhci.quirks2 = SDHCI_QUIRK2_BROKEN_HS200;
+
 	plat->sdhci.mci = mci;
 	sdhci_setup_host(&plat->sdhci);
 
diff --git a/drivers/mci/arasan-sdhci.c b/drivers/mci/arasan-sdhci.c
index c320aae13a87..c8ab78b0f839 100644
--- a/drivers/mci/arasan-sdhci.c
+++ b/drivers/mci/arasan-sdhci.c
@@ -774,6 +774,9 @@ static int arasan_sdhci_probe(struct device *dev)
 			mci->ops.execute_tuning = arasan_zynqmp_execute_tuning;
 		mci->caps2 |= MMC_CAP2_HS200;
 		arasan_sdhci->quirks |= SDHCI_ARASAN_QUIRK_CLOCK_25_BROKEN;
+	} else {
+		/* HS200 only supported for ZynqMP at the moment */
+		arasan_sdhci->sdhci.quirks2 = SDHCI_QUIRK2_BROKEN_HS200;
 	}
 
 	/*
diff --git a/drivers/mci/dwcmshc-sdhci.c b/drivers/mci/dwcmshc-sdhci.c
index 174cc3f76816..6fdbb61565f2 100644
--- a/drivers/mci/dwcmshc-sdhci.c
+++ b/drivers/mci/dwcmshc-sdhci.c
@@ -325,6 +325,8 @@ static int dwcmshc_probe(struct device *dev)
 	host->sdhci.base = IOMEM(iores->start);
 	host->sdhci.mci = mci;
 	host->sdhci.max_clk = clk_get_rate(clk);
+	/* HS200 not supported by this driver at the moment */
+	host->sdhci.quirks2 = SDHCI_QUIRK2_BROKEN_HS200;
 	host->cb = dwcmshc_cb;
 
 	mci->hw_dev = dev;
diff --git a/drivers/mci/imx-esdhc.c b/drivers/mci/imx-esdhc.c
index 6f2e5bb30fb2..8a7106af9726 100644
--- a/drivers/mci/imx-esdhc.c
+++ b/drivers/mci/imx-esdhc.c
@@ -478,6 +478,9 @@ static int fsl_esdhc_probe(struct device *dev)
 	host->mci.hw_dev = dev;
 	host->sdhci.mci = &host->mci;
 
+	if (!(host->socdata->flags & ESDHC_FLAG_HS200))
+		host->sdhci.quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;
+
 	ret = sdhci_setup_host(&host->sdhci);
 	if (ret)
 		goto err_clk_disable;
diff --git a/drivers/mci/rockchip-dwcmshc-sdhci.c b/drivers/mci/rockchip-dwcmshc-sdhci.c
index 025279c29a34..267d0146d308 100644
--- a/drivers/mci/rockchip-dwcmshc-sdhci.c
+++ b/drivers/mci/rockchip-dwcmshc-sdhci.c
@@ -341,6 +341,9 @@ static int rk_sdhci_probe(struct device *dev)
 
 	mci_of_parse(&host->mci);
 
+	/* HS200 not supported by this driver at the moment */
+	host->sdhci.quirks2 = SDHCI_QUIRK2_BROKEN_HS200;
+
 	sdhci_setup_host(&host->sdhci);
 
 	dev->priv = host;
diff --git a/drivers/mci/sdhci.c b/drivers/mci/sdhci.c
index 6308dc9d9140..5364f602d79a 100644
--- a/drivers/mci/sdhci.c
+++ b/drivers/mci/sdhci.c
@@ -1050,6 +1050,38 @@ int sdhci_setup_host(struct sdhci *host)
 	if (sdhci_can_64bit_dma(host))
 		host->flags |= SDHCI_USE_64_BIT_DMA;
 
+	if (host->quirks2 & SDHCI_QUIRK2_NO_1_8_V) {
+		host->caps1 &= ~(SDHCI_SUPPORT_SDR104 | SDHCI_SUPPORT_SDR50 |
+				 SDHCI_SUPPORT_DDR50);
+		/*
+		 * The SDHCI controller in a SoC might support HS200/HS400
+		 * (indicated using mmc-hs200-1_8v/mmc-hs400-1_8v dt property),
+		 * but if the board is modeled such that the IO lines are not
+		 * connected to 1.8v then HS200/HS400 cannot be supported.
+		 * Disable HS200/HS400 if the board does not have 1.8v connected
+		 * to the IO lines. (Applicable for other modes in 1.8v)
+		 */
+		mci->caps2 &= ~(MMC_CAP2_HSX00_1_8V | MMC_CAP2_HS400_ES);
+		mci->host_caps &= ~(MMC_CAP_1_8V_DDR | MMC_CAP_UHS);
+	}
+
+	/* Any UHS-I mode in caps implies SDR12 and SDR25 support. */
+	if (host->caps1 & (SDHCI_SUPPORT_SDR104 | SDHCI_SUPPORT_SDR50 |
+			   SDHCI_SUPPORT_DDR50))
+		mci->host_caps |= MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25;
+
+	/* SDR104 supports also implies SDR50 support */
+	if (host->caps1 & SDHCI_SUPPORT_SDR104) {
+		mci->host_caps |= MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_SDR50;
+		/* SD3.0: SDR104 is supported so (for eMMC) the caps2
+		 * field can be promoted to support HS200.
+		 */
+		if (!(host->quirks2 & SDHCI_QUIRK2_BROKEN_HS200))
+			mci->caps2 |= MMC_CAP2_HS200;
+	} else if (host->caps1 & SDHCI_SUPPORT_SDR50) {
+		mci->host_caps |= MMC_CAP_UHS_SDR50;
+	}
+
 	if ((mci->caps2 & (MMC_CAP2_HS200_1_8V_SDR | MMC_CAP2_HS400_1_8V)))
 		host->flags |= SDHCI_SIGNALING_180;
 
diff --git a/drivers/mci/sdhci.h b/drivers/mci/sdhci.h
index b38837caaec1..91c9c4a60ab5 100644
--- a/drivers/mci/sdhci.h
+++ b/drivers/mci/sdhci.h
@@ -247,6 +247,10 @@ struct sdhci {
 	unsigned int quirks;
 #define SDHCI_QUIRK_MISSING_CAPS		BIT(27)
 	unsigned int quirks2;
+/* The system physically doesn't support 1.8v, even if the host does */
+#define SDHCI_QUIRK2_NO_1_8_V				BIT(2)
+/* Controller does not support HS200 */
+#define SDHCI_QUIRK2_BROKEN_HS200			BIT(6)
 #define SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN	BIT(15)
 #define SDHCI_QUIRK2_ISSUE_CMD_DAT_RESET_TOGETHER	BIT(19)
 	u32 caps;	/* CAPABILITY_0 */
