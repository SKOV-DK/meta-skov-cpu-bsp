From: Juergen Borleis <jbe@pengutronix.de>
Date: Tue, 8 Dec 2015 09:59:19 +0100
Subject: [PATCH] Skov: add support for base platform and board variants 19 &
 20
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The Skov platform potentially consists of many variants of CPUs (i.MX6S/DL and
i.MX6D/Q), NAND memories (size differs from 256 MiB to 8 GiB) and populated
SDRAM (256 MiB up to 2 GiB). All these variants share one PCB.

Some bootstrap resistors are provided which decode the variant and which allow
for it's detection at runtime. This information is needed to choose the bootspec
entry with the matching devicetree to boot the system. Based upon this mechanism
usage of a single Barebox image and Linux root filesystem for all known board
variants is made possible.

Signed-off-by: Juergen Borleis <jbe@pengutronix.de>
Signed-off-by: Enrico Jorns <ejo@pengutronix.de>
Signed-off-by: Ulrich Ölmann <u.oelmann@pengutronix.de>
Signed-off-by: Søren Andersen <san@skov.dk>
[Note: this commit results of squashing commits v2016.08.0..17bb4fca9a0c]
---
 arch/arm/boards/Makefile                           |   1 +
 arch/arm/boards/skov-imx6/Makefile                 |   2 +
 arch/arm/boards/skov-imx6/board.c                  |  30 +
 arch/arm/boards/skov-imx6/env/init/automount       |  14 +
 arch/arm/boards/skov-imx6/env/nv/boot.default      |   1 +
 .../skov-imx6/flash-header-mx6-skov-imx6.imxcfg    |   3 +
 arch/arm/boards/skov-imx6/lowlevel.c               | 673 +++++++++++++++++++++
 arch/arm/boards/skov-imx6/version.c                | 245 ++++++++
 arch/arm/dts/Makefile                              |   1 +
 arch/arm/dts/imx6dl-skov-imx6.dts                  |  24 +
 arch/arm/dts/imx6q-skov-imx6.dts                   |  24 +
 arch/arm/dts/imx6qdl-skov-imx6.dtsi                | 318 ++++++++++
 arch/arm/mach-imx/Kconfig                          |   5 +
 common/blspec.c                                    |  20 +-
 images/Makefile.imx                                |   5 +
 15 files changed, 1358 insertions(+), 8 deletions(-)
 create mode 100644 arch/arm/boards/skov-imx6/Makefile
 create mode 100644 arch/arm/boards/skov-imx6/board.c
 create mode 100644 arch/arm/boards/skov-imx6/env/init/automount
 create mode 100644 arch/arm/boards/skov-imx6/env/nv/boot.default
 create mode 100644 arch/arm/boards/skov-imx6/flash-header-mx6-skov-imx6.imxcfg
 create mode 100644 arch/arm/boards/skov-imx6/lowlevel.c
 create mode 100644 arch/arm/boards/skov-imx6/version.c
 create mode 100644 arch/arm/dts/imx6dl-skov-imx6.dts
 create mode 100644 arch/arm/dts/imx6q-skov-imx6.dts
 create mode 100644 arch/arm/dts/imx6qdl-skov-imx6.dtsi

diff --git a/arch/arm/boards/Makefile b/arch/arm/boards/Makefile
index e3dcc6a61507..ce8554545602 100644
--- a/arch/arm/boards/Makefile
+++ b/arch/arm/boards/Makefile
@@ -100,6 +100,7 @@ obj-$(CONFIG_MACH_REALQ7)			+= datamodul-edm-qmx6/
 obj-$(CONFIG_MACH_RPI_COMMON)			+= raspberry-pi/
 obj-$(CONFIG_MACH_SABRELITE)			+= freescale-mx6-sabrelite/
 obj-$(CONFIG_MACH_SABRESD)			+= freescale-mx6-sabresd/
+obj-$(CONFIG_MACH_SKOV_IMX6)			+= skov-imx6/
 obj-$(CONFIG_MACH_FREESCALE_IMX6SX_SABRESDB)	+= freescale-mx6sx-sabresdb/
 obj-$(CONFIG_MACH_SAMA5D3XEK)			+= sama5d3xek/
 obj-$(CONFIG_MACH_SAMA5D3_XPLAINED)		+= sama5d3_xplained/
diff --git a/arch/arm/boards/skov-imx6/Makefile b/arch/arm/boards/skov-imx6/Makefile
new file mode 100644
index 000000000000..206715adce68
--- /dev/null
+++ b/arch/arm/boards/skov-imx6/Makefile
@@ -0,0 +1,2 @@
+obj-y += board.o version.o
+lwl-y += lowlevel.o
diff --git a/arch/arm/boards/skov-imx6/board.c b/arch/arm/boards/skov-imx6/board.c
new file mode 100644
index 000000000000..0362379bb88a
--- /dev/null
+++ b/arch/arm/boards/skov-imx6/board.c
@@ -0,0 +1,30 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Based on code marked with:
+ * Copyright (C) 2015 Sascha Hauer, Pengutronix
+ */
+
+#include <common.h>
+#include <init.h>
+#include <mach/bbu.h>
+
+static int skov_imx6_devices_init(void)
+{
+	if (!of_machine_is_compatible("skov,imx6"))
+		return 0;
+
+	imx6_bbu_internal_spi_i2c_register_handler("spiflash", "/dev/m25p0.barebox",
+		BBU_HANDLER_FLAG_DEFAULT);
+
+	return 0;
+}
+coredevice_initcall(skov_imx6_devices_init);
diff --git a/arch/arm/boards/skov-imx6/env/init/automount b/arch/arm/boards/skov-imx6/env/init/automount
new file mode 100644
index 000000000000..bc9ff48a0afb
--- /dev/null
+++ b/arch/arm/boards/skov-imx6/env/init/automount
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+if [ "$1" = menu ]; then
+	init-menu-add-entry "$0" "Automountpoints"
+	exit
+fi
+
+# development support
+mkdir -p /mnt/tftp
+automount /mnt/tftp 'ifup eth0 && mount -t tftp $eth0.serverip /mnt/tftp'
+
+# regular SD card based boot procedure
+mkdir -p /mnt/sd
+automount -d /mnt/sd 'mmc2.probe=1 && mount -t ext4 /dev/mmc2.0 /mnt/sd'
diff --git a/arch/arm/boards/skov-imx6/env/nv/boot.default b/arch/arm/boards/skov-imx6/env/nv/boot.default
new file mode 100644
index 000000000000..fe1a363da1e7
--- /dev/null
+++ b/arch/arm/boards/skov-imx6/env/nv/boot.default
@@ -0,0 +1 @@
+bootchooser
diff --git a/arch/arm/boards/skov-imx6/flash-header-mx6-skov-imx6.imxcfg b/arch/arm/boards/skov-imx6/flash-header-mx6-skov-imx6.imxcfg
new file mode 100644
index 000000000000..400a87015425
--- /dev/null
+++ b/arch/arm/boards/skov-imx6/flash-header-mx6-skov-imx6.imxcfg
@@ -0,0 +1,3 @@
+soc imx6
+loadaddr 0x00907000
+dcdofs 0x400
diff --git a/arch/arm/boards/skov-imx6/lowlevel.c b/arch/arm/boards/skov-imx6/lowlevel.c
new file mode 100644
index 000000000000..de210016e149
--- /dev/null
+++ b/arch/arm/boards/skov-imx6/lowlevel.c
@@ -0,0 +1,695 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Partially based on code of:
+ * Copyright (C) 2014, Rose Technology <san@rosetechnology.dk>
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+#define pr_fmt(fmt) "skov-imx6: " fmt
+
+#include <common.h>
+#include <mach/generic.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <debug_ll.h>
+#include <io.h>
+#include <mach/imx6-mmdc.h>
+#include <mach/imx6-ddr-regs.h>
+#include <mach/imx6.h>
+#include <mach/xload.h>
+#include <mach/esdctl.h>
+#include <serial/imx-uart.h>
+#include <mach/iomux-mx6.h>
+
+#define SKOV_IMX6_SDHC_CHANNEL 2 /* SDHC #3 */
+#define SKOV_IMX6_NOR_CHANNEL 0 /* SPI master #1 */
+
+static void __udelay(int us)
+{
+	volatile int i;
+
+	for (i = 0; i < us * 4; i++);
+}
+
+/* ------------------------------------------------------------------------ */
+
+/*
+ * Micron MT41K128M16JT-125 IT:K ->  2 GBit = 16 Meg x 16 x 8 banks
+ *
+ * Speed Grade   Data Rate (MT/s)  tRCD-tRP-CL   tRCD(ns)  tRP(ns)  CL(ns)
+ *    -125 ¹²       1600            11-11-11      13.75     13.75   13.75
+ *               (=800 MHz)
+ *
+ * ¹ Backward compatible to 1066 (=533 MHz), CL = 7
+ * ² Backward compatible to 1333 (=667 MHz), CL = 9
+ *
+ * Memory configuration used by variant
+ * - "High Performance", 64 bit data bus, 1066 MHz, 1 GiB memory
+ */
+static const struct mx6_ddr3_cfg skov_imx6_cfg_4x128Mb_1066MHz = {
+	.mem_speed = 1066,
+	.density = 2, /* GiBit */
+	.width = 16, /* 16 bit data per device */
+	.banks = 8,
+	.rowaddr = 14, /* 16 k */
+	.coladdr = 10, /* 1 k */
+	.pagesz = 2, /* [kiB] */
+	.trcd = 1375, /* 13.75 ns = 11 clocks @ 1.6 GHz */
+	.trcmin = 4875, /* 48.75 ns = 39 clocks @ 1.6 GHz */
+	.trasmin = 3500, /* 35 ns = 28 clocks @ 1.6 GHz */
+	.SRT = 0,
+};
+
+static const struct mx6_ddr_sysinfo skov_imx6_sysinfo_4x128Mb_1066MHz = {
+	.dsize = 2, /* 64 bit wide = 4 devices, 16 bit each */
+	.cs_density = 8, /* four 2 GBit devices connected */
+	.ncs = 1, /* one CS line for all devices */
+	.cs1_mirror = 1, /* TODO */
+	.bi_on = 1, /* TODO */
+	.rtt_nom = 1, /* MX6_MMDC_P0_MPODTCTRL -> 0x00022227 */
+	.rtt_wr = 0, /* is LW_EN is 0 in their code */
+	.ralat = 5, /* TODO */
+	.walat = 1, /* TODO */
+	.mif3_mode = 3, /* TODO */
+	.rst_to_cke = 0x23, /* used in their code as well */
+	.sde_to_rst = 0x10, /* used in their code as well */
+	.pd_fast_exit = 0, /* TODO */
+};
+
+/* calibration info for the "max performance" and "high performance" */
+static const struct mx6_mmdc_calibration skov_imx6_calib_4x128Mb_1066MHz = {
+	.p0_mpwldectrl0 = 0x0011000E,
+	.p0_mpwldectrl1 = 0x000E001B,
+	.p0_mpdgctrl0 = 0x42720306,
+	.p0_mpdgctrl1 = 0x026F0266,
+	.p0_mprddlctl = 0x45393B3E,
+	.p0_mpwrdlctl = 0x40434541,
+
+	.p1_mpwldectrl0 = 0x00190015,
+	.p1_mpwldectrl1 = 0x00070018,
+	.p1_mpdgctrl0 = 0x4273030A,
+	.p1_mpdgctrl1 = 0x02740240,
+	.p1_mprddlctl = 0x403A3747,
+	.p1_mpwrdlctl = 0x473E4A3B,
+};
+
+/* ------------------------------------------------------------------------ */
+
+static struct mx6dq_iomux_ddr_regs ddr_iomux_q = {
+	.dram_sdqs0 = 0x00000030,
+	.dram_sdqs1 = 0x00000030,
+	.dram_sdqs2 = 0x00000030,
+	.dram_sdqs3 = 0x00000030,
+	.dram_sdqs4 = 0x00000030,
+	.dram_sdqs5 = 0x00000030,
+	.dram_sdqs6 = 0x00000030,
+	.dram_sdqs7 = 0x00000030,
+	.dram_dqm0 = 0x00020030,
+	.dram_dqm1 = 0x00020030,
+	.dram_dqm2 = 0x00020030,
+	.dram_dqm3 = 0x00020030,
+	.dram_dqm4 = 0x00020030,
+	.dram_dqm5 = 0x00020030,
+	.dram_dqm6 = 0x00020030,
+	.dram_dqm7 = 0x00020030,
+	.dram_cas = 0x00020030,
+	.dram_ras = 0x00020030,
+	.dram_sdclk_0 = 0x00020030,
+	.dram_sdclk_1 = 0x00020030,
+	.dram_sdcke0 = 0x00003000,
+	.dram_sdcke1 = 0x00003000,
+	.dram_reset = 0x00020030,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = 0x00003030,
+	.dram_sdodt1 = 0x00003030,
+};
+
+static struct mx6dq_iomux_grp_regs grp_iomux_q = {
+	.grp_b0ds = 0x00000030,
+	.grp_b1ds = 0x00000030,
+	.grp_b2ds = 0x00000030,
+	.grp_b3ds = 0x00000030,
+	.grp_b4ds = 0x00000030,
+	.grp_b5ds = 0x00000030,
+	.grp_b6ds = 0x00000030,
+	.grp_b7ds = 0x00000030,
+	.grp_addds = 0x00000030,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_ctlds = 0x00000030,
+	.grp_ddr_type = 0x000C0000,
+};
+
+static void spl_imx6q_dram_init(const struct mx6_ddr_sysinfo *si,
+				const struct mx6_mmdc_calibration *cb,
+				const struct mx6_ddr3_cfg *cfg)
+{
+	mx6dq_dram_iocfg(64, &ddr_iomux_q, &grp_iomux_q);
+	mx6_dram_cfg(si, cb, cfg);
+	__udelay(100);
+}
+
+/* ------------------------------------------------------------------------ */
+/*
+ * Device Information: Varies per DDR3 part number and speed grade
+ * Note: this SDRAM type is used on the "Low Cost" variant
+ *
+ * Micron MT41K128M16JT-125 IT:K ->  2 GBit = 16 Meg x 16 x 8 banks
+ *
+ * Speed Grade   Data Rate (MT/s)  tRCD-tRP-CL   tRCD(ns)  tRP(ns)  CL(ns)
+ *    -125 ¹²       1600            11-11-11      13.75     13.75   13.75
+ *               (=800 MHz)
+ *
+ * ¹ Backward compatible to 1066 (=533 MHz), CL = 7
+ * ² Backward compatible to 1333 (=667 MHz), CL = 9
+ *
+ * Memory configuration used by variant
+ * - "Low Cost", 32 bit data bus, 800 MHz, 512 MiB memory
+ */
+static const struct mx6_ddr3_cfg skov_imx6_cfg_2x128Mb_800MHz = {
+	.mem_speed = 800,
+	.density = 2, /* GiBit */
+	.width = 16, /* 16 bit data per device */
+	.banks = 8,
+	.rowaddr = 14, /* 16 k */
+	.coladdr = 10, /* 1 k */
+	.pagesz = 2, /* [kiB] */
+	.trcd = 1375, /* 13.75 ns = 11 clocks @ 1.6 GHz */
+	.trcmin = 4875, /* 48.75 ns = 39 clocks @ 1.6 GHz */
+	.trasmin = 3500, /* 35 ns = 28 clocks @ 1.6 GHz */
+	.SRT = 0,
+};
+
+static const struct mx6_ddr_sysinfo skov_imx6_sysinfo_2x128Mb_800MHz = {
+	.dsize = 1, /* 32 bit wide = 2 devices, 16 bit each */
+	.cs_density = 4, /* two 2 GBit devices connected */
+	.ncs = 1, /* one CS line for all devices */
+	.cs1_mirror = 1, /* TODO */
+	.bi_on = 1, /* TODO */
+	.rtt_nom = 1, /* MX6_MMDC_P0_MPODTCTRL -> 0x00022227 */
+	.rtt_wr = 0, /* is LW_EN is 0 in their code */
+	.ralat = 5, /* TODO */
+	.walat = 1, /* TODO */
+	.mif3_mode = 3, /* TODO */
+	.rst_to_cke = 0x23, /* used in their code as well */
+	.sde_to_rst = 0x10, /* used in their code as well */
+	.pd_fast_exit = 0, /* TODO */
+};
+
+static const struct mx6_mmdc_calibration skov_imx6_calib_2x128Mb_800MHz = {
+	.p0_mpwldectrl0 = 0x0040003C,
+	.p0_mpwldectrl1 = 0x0032003E,
+	.p0_mpdgctrl0 = 0x42350231,
+	.p0_mpdgctrl1 = 0x021A0218,
+	.p0_mprddlctl = 0x4B4B4E49,
+	.p0_mpwrdlctl = 0x3F3F3035,
+};
+
+/* ------------------------------------------------------------------------ */
+
+static const struct mx6sdl_iomux_ddr_regs ddr_iomux_s = {
+	.dram_sdqs0 = 0x00000030,
+	.dram_sdqs1 = 0x00000030,
+	.dram_sdqs2 = 0x00000030,
+	.dram_sdqs3 = 0x00000030,
+	.dram_sdqs4 = 0x00000030,
+	.dram_sdqs5 = 0x00000030,
+	.dram_sdqs6 = 0x00000030,
+	.dram_sdqs7 = 0x00000030,
+	.dram_dqm0 = 0x00020030,
+	.dram_dqm1 = 0x00020030,
+	.dram_dqm2 = 0x00020030,
+	.dram_dqm3 = 0x00020030,
+	.dram_dqm4 = 0x00020030,
+	.dram_dqm5 = 0x00020030,
+	.dram_dqm6 = 0x00020030,
+	.dram_dqm7 = 0x00020030,
+	.dram_cas = 0x00020030,
+	.dram_ras = 0x00020030,
+	.dram_sdclk_0 = 0x00020030,
+	.dram_sdclk_1 = 0x00020030,
+	.dram_sdcke0 = 0x00003000,
+	.dram_sdcke1 = 0x00003000,
+	.dram_reset = 0x00020030,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdodt0 = 0x00003030,
+	.dram_sdodt1 = 0x00003030,
+};
+
+static const struct mx6sdl_iomux_grp_regs grp_iomux_s = { /* TODO */
+	.grp_b0ds = 0x00000030,
+	.grp_b1ds = 0x00000030,
+	.grp_b2ds = 0x00000030,
+	.grp_b3ds = 0x00000030,
+	.grp_b4ds = 0x00000030,
+	.grp_b5ds = 0x00000030,
+	.grp_b6ds = 0x00000030,
+	.grp_b7ds = 0x00000030,
+	.grp_addds = 0x00000030,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_ctlds = 0x00000030,
+	.grp_ddr_type = 0x000C0000,
+};
+
+static void spl_imx6sdl_dram_init(const struct mx6_ddr_sysinfo *si,
+				const struct mx6_mmdc_calibration *cb,
+				const struct mx6_ddr3_cfg *cfg)
+{
+	mx6sdl_dram_iocfg(64, &ddr_iomux_s, &grp_iomux_s);
+	mx6_dram_cfg(si, cb, cfg);
+	__udelay(100);
+}
+
+/* ------------------------------------------------------------------------ */
+
+#define BKLGT_PWR_PAD_CTRL MX6_PAD_CTL_SPEED_LOW | MX6_PAD_CTL_DSE_80ohm | MX6_PAD_CTL_SRE_SLOW
+
+static inline void init_backlight_gpios(int cpu_type, unsigned board_variant)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *gpio6base = IOMEM(MX6_GPIO6_BASE_ADDR);
+	void __iomem *gpio1base = IOMEM(MX6_GPIO1_BASE_ADDR);
+	unsigned reg;
+
+	/*
+	 * since revision B a backlight switch is present which can help to
+	 * prevent any kind of flicker when switching on the board. Use it.
+	 * GPIO6/23 controls the backlight. High switches off the backlight.
+	 */
+	switch (board_variant) {
+	case 0 ... 8:
+		break;
+	default:
+		reg = readl(gpio6base + 0x04);
+		reg |= BIT(23);
+		writel(reg, gpio6base + 0x04); /* output */
+		reg = readl(gpio6base + 0x00);
+		reg |= BIT(23);
+		writel(reg, gpio6base + 0x00);
+
+		switch (cpu_type) {
+		case IMX6_CPUTYPE_IMX6S:
+		case IMX6_CPUTYPE_IMX6DL:
+			writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x2D0);
+			writel(BKLGT_PWR_PAD_CTRL, iomuxbase + 0x6B8);
+			break;
+		case IMX6_CPUTYPE_IMX6D:
+		case IMX6_CPUTYPE_IMX6Q:
+			writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x068);
+			writel(BKLGT_PWR_PAD_CTRL, iomuxbase + 0x37C);
+			break;
+		}
+	}
+
+	/*
+	 * switch brightness to the lowest available value. This is what we
+	 * can do for revision A boards
+	 * GPIO1/1 controls (via PWM) the brightness. A static low means
+	 * a very dark backlight
+	 */
+	reg = readl(gpio1base + 0x04);
+	reg |= BIT(1);
+	writel(reg, gpio1base + 0x04); /* output */
+	reg = readl(gpio1base + 0x00);
+	reg &= ~BIT(1);
+	writel(reg, gpio1base + 0x00);
+
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x210);
+		writel(BKLGT_PWR_PAD_CTRL, iomuxbase + 0x5E0);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x224);
+		writel(BKLGT_PWR_PAD_CTRL, iomuxbase + 0x5F4);
+		break;
+	}
+}
+
+#define MMC_PWR_PAD_CTRL MX6_PAD_CTL_SPEED_LOW | MX6_PAD_CTL_DSE_80ohm | MX6_PAD_CTL_SRE_SLOW
+
+/*
+ * Some variants needs special tweaks and they needs them as early as possible
+ * Note: do not call this function in early boot, you may switch off the SD
+ * card you need to boot from...
+ */
+static inline void init_mmc_gpios(int cpu_type, unsigned board_variant)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *gpiobase = IOMEM(MX6_GPIO7_BASE_ADDR);
+	unsigned reg;
+
+	/*
+	 * all revisions have an SD card voltage IO selector, to select 1.8 V or
+	 * 3.3 V to be used for the IO signals from/to the SD card.
+	 * GPIO7/13 selects the voltage: high means 1.8 V, low means 3.3 V
+	 */
+	/* Select 3.3 V IO supply */
+	reg = readl(gpiobase + 0x04);
+	reg |= BIT(13);
+	writel(reg, gpiobase + 0x04); /* output */
+	reg = readl(gpiobase + 0x00);
+	reg &= ~BIT(13);
+	writel(reg, gpiobase + 0x00);
+
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x21C);
+		writel(MMC_PWR_PAD_CTRL, iomuxbase + 0x5ec);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x250);
+		writel(MMC_PWR_PAD_CTRL, iomuxbase + 0x620);
+		break;
+	}
+
+	if (board_variant < 13)
+		return; /* no way to switch the SD card's power supply */
+
+	/*
+	 * Turn off SD cards power in order to reset it.
+	 * Revision C has an additional MMC power supply switch. It seems
+	 * we need to reset the card by power cycling, else we get
+	 * read errors when we accessing it. This happens after warm starts
+	 * or by external triggered reset (and I guess when the watchdog resets
+	 * the system as well).
+	 * GPIO7/8 is used for this purpose and must be high to enable the power
+	 */
+	reg = readl(gpiobase + 0x04);
+	reg |= BIT(8);
+	writel(reg, gpiobase + 0x04); /* output */
+	reg = readl(gpiobase + 0x00);
+	reg &= ~BIT(8);
+	writel(reg, gpiobase + 0x00);
+
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x334);
+		writel(MMC_PWR_PAD_CTRL, iomuxbase + 0x71C);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(IOMUX_CONFIG_SION | 0x05, iomuxbase + 0x2D0);
+		writel(MMC_PWR_PAD_CTRL, iomuxbase + 0x6B8);
+		break;
+	}
+}
+
+#define LED_PAD_CTRL MX6_PAD_CTL_SPEED_LOW | MX6_PAD_CTL_DSE_240ohm | MX6_PAD_CTL_SRE_SLOW
+
+static inline void setup_leds(int cpu_type)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *gpiobase = IOMEM(MX6_GPIO1_BASE_ADDR);
+	unsigned reg;
+
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(0x05, iomuxbase + 0x20C); /* LED1 (GPIO0) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5DC);
+		writel(0x05, iomuxbase + 0x224); /* LED2 (GPIO2) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5F4);
+		writel(0x05, iomuxbase + 0x22C); /* LED3 (GPIO4) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5FC);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(0x05, iomuxbase + 0x220); /* LED1 (GPIO0) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x5f0);
+		writel(0x05, iomuxbase + 0x234); /* LED2 (GPIO2) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x604);
+		writel(0x05, iomuxbase + 0x238); /* LED3 (GPIO4) */
+		writel(LED_PAD_CTRL, iomuxbase + 0x608);
+		break;
+	}
+
+	/* Turn off all LEDS */
+	reg = readl(gpiobase + 0x00);
+	reg &= ~(1 | 4 | 16);
+	writel(reg, gpiobase + 0x00);
+
+	/* make them output */
+	reg = readl(gpiobase + 0x04);
+	reg |= 1 | 4 | 16;
+	writel(reg, gpiobase + 0x04);
+}
+
+static inline void setup_uart(int cpu_type)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+
+	/* UART TxD output is pin EIM/D26, e.g. UART is in DTE mode */
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(0x0, iomuxbase + 0x904); /*  IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT */
+		writel(0x4, iomuxbase + 0x16c); /*  IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26 */
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(0x0, iomuxbase + 0x928); /*  IOMUXC_UART2_UART_RX_DATA_SELECT_INPUT */
+		writel(0x4, iomuxbase + 0x0bc); /*  IOMUXC_SW_MUX_CTL_PAD_EIM_DATA26 */
+		break;
+	}
+
+	imx6_ungate_all_peripherals();
+	imx6_uart_setup(IOMEM(MX6_UART2_BASE_ADDR));
+	pbl_set_putc(imx_uart_putc, IOMEM(MX6_UART2_BASE_ADDR));
+
+	pr_debug("\n");
+}
+
+#define V_PAD_CTRL MX6_PAD_CTL_PUS_100K_UP | MX6_PAD_CTL_PUE | MX6_PAD_CTL_SPEED_LOW | MX6_PAD_CTL_DSE_DISABLE | MX6_PAD_CTL_SRE_SLOW
+
+static inline unsigned skov_imx6_get_version(int cpu_type)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *gpiobase = IOMEM(MX6_GPIO2_BASE_ADDR);
+	unsigned reg;
+	unsigned var = 0;
+
+	/* mux pins as GPIOs */
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		writel(0x05, iomuxbase + 0x348); /* VERSION_0, GPIO2/10 */
+		writel(V_PAD_CTRL, iomuxbase + 0x730);
+		writel(0x05, iomuxbase + 0x35c); /* VERSION_1, GPIO2/15 */
+		writel(V_PAD_CTRL, iomuxbase + 0x744);
+		writel(0x05, iomuxbase + 0x340); /* VERSION_2, GPIO2/8 */
+		writel(V_PAD_CTRL, iomuxbase + 0x728);
+		writel(0x05, iomuxbase + 0x344); /* VERSION_3, GPIO2/9 */
+		writel(V_PAD_CTRL, iomuxbase + 0x72C);
+		writel(0x05, iomuxbase + 0x350); /* VERSION_4, GPIO2/12 */
+		writel(V_PAD_CTRL, iomuxbase + 0x738);
+		writel(0x05, iomuxbase + 0x358); /* VERSION_5, GPIO2/14 */
+		writel(V_PAD_CTRL, iomuxbase + 0x740);
+		writel(0x05, iomuxbase + 0x34c); /* VERSION_6, GPIO2/11 */
+		writel(V_PAD_CTRL, iomuxbase + 0x734);
+		writel(0x05, iomuxbase + 0x354); /* VERSION_7, GPIO2/13 */
+		writel(V_PAD_CTRL, iomuxbase + 0x73C);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		writel(0x05, iomuxbase + 0x324); /* VERSION_0, GPIO2/10 */
+		writel(V_PAD_CTRL, iomuxbase + 0x70c);
+		writel(0x05, iomuxbase + 0x338); /* VERSION_1, GPIO2/15 */
+		writel(V_PAD_CTRL, iomuxbase + 0x720);
+		writel(0x05, iomuxbase + 0x31c); /* VERSION_2, GPIO2/8 */
+		writel(V_PAD_CTRL, iomuxbase + 0x704);
+		writel(0x05, iomuxbase + 0x320); /* VERSION_3, GPIO2/9 */
+		writel(V_PAD_CTRL, iomuxbase + 0x708);
+		writel(0x05, iomuxbase + 0x32c); /* VERSION_4, GPIO2/12 */
+		writel(V_PAD_CTRL, iomuxbase + 0x714);
+		writel(0x05, iomuxbase + 0x334); /* VERSION_5, GPIO2/14 */
+		writel(V_PAD_CTRL, iomuxbase + 0x71c);
+		writel(0x05, iomuxbase + 0x328); /* VERSION_6, GPIO2/11 */
+		writel(V_PAD_CTRL, iomuxbase + 0x710);
+		writel(0x05, iomuxbase + 0x330); /* VERSION_7, GPIO2/13 */
+		writel(V_PAD_CTRL, iomuxbase + 0x718);
+		break;
+	default:
+		pr_err("Invalid SoC! i.MX6S/DL or i.MX6Q expected (found %d)\n", cpu_type);
+		return -1;
+	}
+
+	/* force all to be inputs */
+	reg = readl(gpiobase + 0x04);
+	reg &= ~(0xff00);
+	writel(reg, gpiobase + 0x04);
+
+	reg = readl(gpiobase + 0x00);
+	var |= !!(reg & (1 << 13));
+	var <<= 1;
+	var |= !!(reg & (1 << 11));
+	var <<= 1;
+	var |= !!(reg & (1 << 14));
+	var <<= 1;
+	var |= !!(reg & (1 << 12));
+	var <<= 1;
+	var |= !!(reg & (1 << 9));
+	var <<= 1;
+	var |= !!(reg & (1 << 8));
+	var <<= 1;
+	var |= !!(reg & (1 << 15));
+	var <<= 1;
+	var |= !!(reg & (1 << 10));
+
+	return (~var) & 0xff;
+}
+
+/*
+ * Hardware marked board revisions and deployments
+ *
+ *   count      board    ram       flash       CPU
+ *               rev.
+ * 00000000       A    1024 MiB   1024 MiB     i.MX6Q
+ * 00000001       A     512 MiB    256 MiB     i.MX6S
+ * 00000010       A    1024 MiB    512 MiB     i.MX6Q
+ * 00000011       ---- not defined ----
+ * 00000100       A     512 MiB    256 MiB     i.MX6S
+ * 00000101       ---- not defined ----
+ * 00000110       ---- not defined ----
+ * 00000111       ---- not defined ----
+ * 00001000       A    1024 MiB    512 MiB     i.MX6Q
+ * 00001001       B     256 MiB     16 MiB     i.MX6S
+ * 00001010       B     256 MiB    256 MiB     i.MX6S
+ * 00001011       B    1024 MiB    256 MiB     i.MX6Q
+ * 00001100       B    2048 MiB      8 GiB     i.MX6Q
+ * 00001101       C     256 MiB    256 MiB     i.MX6S
+ * 00001110       C    1024 MiB    256 MiB     i.MX6Q
+ * 00001111       C     512 MiB    256 MiB     i.MX6S
+ * 00010000       C     512 MiB      4 GiB     i.MX6S
+ * 00010001       C    2048 MiB      8 GiB     i.MX6Q
+ * 00010010       C    4096 MiB     16 GiB     i.MX6Q+
+ * 00010011       C     512 MiB      2 GiB     i.MX6S
+ * 00010100       C    1024 MiB      4 GiB     i.MX6Q
+ * 00010101       C     512 MiB      2 GIB     i.MX6S
+ * 00010110       C    1024 MiB      4 GIB     i.MX6Q
+ *
+ * This routine does not return if starting the image from SD card or NOR
+ * was successful. It restarts skov_imx6_start() instead
+ */
+static void skov_imx6_init(int cpu_type, unsigned board_variant)
+{
+	switch (board_variant) {
+	case 19: /* i.MX6S "Solo_R512M_F2G" */
+		if (cpu_type != IMX6_CPUTYPE_IMX6S) {
+			pr_err("Invalid SoC! i.MX6S expected\n");
+			return;
+		}
+		pr_debug("Initializing board variant 19\n");
+		spl_imx6sdl_dram_init(&skov_imx6_sysinfo_2x128Mb_800MHz,
+					&skov_imx6_calib_2x128Mb_800MHz,
+					&skov_imx6_cfg_2x128Mb_800MHz);
+		break;
+	case 20: /* i.MX6Q, "Quad_R1G_F2G" */
+		if (cpu_type != IMX6_CPUTYPE_IMX6Q) {
+			pr_err("Invalid SoC! i.MX6Q expected\n");
+			return;
+		}
+		pr_debug("Initializing board variant 20\n");
+		spl_imx6q_dram_init(&skov_imx6_sysinfo_4x128Mb_1066MHz,
+					&skov_imx6_calib_4x128Mb_1066MHz,
+					&skov_imx6_cfg_4x128Mb_1066MHz);
+		break;
+	case 21: /* i.MX6S "Solo_R512M_F2G" */
+		if (cpu_type != IMX6_CPUTYPE_IMX6S) {
+			pr_err("Invalid SoC! i.MX6S expected\n");
+			return;
+		}
+		pr_debug("Initializing board variant 21\n");
+		spl_imx6sdl_dram_init(&skov_imx6_sysinfo_2x128Mb_800MHz,
+					&skov_imx6_calib_2x128Mb_800MHz,
+					&skov_imx6_cfg_2x128Mb_800MHz);
+		break;
+	case 22: /* i.MX6Q, "Quad_R1G_F4G" */
+		if (cpu_type != IMX6_CPUTYPE_IMX6Q) {
+			pr_err("Invalid SoC! i.MX6Q expected\n");
+			return;
+		}
+		pr_debug("Initializing board variant 22\n");
+		spl_imx6q_dram_init(&skov_imx6_sysinfo_4x128Mb_1066MHz,
+					&skov_imx6_calib_4x128Mb_1066MHz,
+					&skov_imx6_cfg_4x128Mb_1066MHz);
+		break;
+	default:
+		pr_err("Unsupported board revision: 0x%x\n", board_variant);
+		/* don't continue */
+		while(1);
+		break;
+	}
+
+	pr_info("Loading bootloader image from SD card...");
+	imx6_esdhc_start_image(SKOV_IMX6_SDHC_CHANNEL);
+	pr_info("failed\nLoading bootloader image from SPI flash...");
+	imx6_spi_start_image(SKOV_IMX6_NOR_CHANNEL);
+	pr_info("failed. No valid boot source found. Giving up\n");
+}
+
+extern char __dtb_z_imx6q_skov_imx6_start[];
+extern char __dtb_z_imx6dl_skov_imx6_start[];
+
+/* called twice: once for SDRAM setup only, second for devicetree setup */
+static noinline void skov_imx6_start(void)
+{
+	int cpu_type = __imx6_cpu_type();
+	unsigned board_variant = skov_imx6_get_version(cpu_type);
+
+	if (get_pc() <= MX6_MMDC_PORT0_BASE_ADDR) {
+		/* first call: do the lowlevel things first */
+		init_backlight_gpios(cpu_type, board_variant);
+		setup_leds(cpu_type);
+		setup_uart(cpu_type);
+		pr_info("Starting to init IMX6 system...\n");
+		skov_imx6_init(cpu_type, board_variant);
+		pr_err("Unable to start bootloader\n");
+		while(1)
+			;
+	}
+
+	init_mmc_gpios(cpu_type, board_variant);
+
+	/* boot this platform (second call) */
+	switch (cpu_type) {
+	case IMX6_CPUTYPE_IMX6S:
+	case IMX6_CPUTYPE_IMX6DL:
+		pr_debug("Startup i.MX6S/DL based system...\n");
+		imx6q_barebox_entry(__dtb_z_imx6dl_skov_imx6_start);
+		break;
+	case IMX6_CPUTYPE_IMX6D:
+	case IMX6_CPUTYPE_IMX6Q:
+		pr_debug("Startup i.MX6Q based system...\n");
+		imx6q_barebox_entry(__dtb_z_imx6q_skov_imx6_start);
+		break;
+	}
+}
+
+ENTRY_FUNCTION(start_imx6_skov_imx6, r0, r1, r2)
+{
+	arm_cpu_lowlevel_init();
+
+	relocate_to_current_adr();
+	setup_c();
+	barrier();
+
+	skov_imx6_start();
+}
diff --git a/arch/arm/boards/skov-imx6/version.c b/arch/arm/boards/skov-imx6/version.c
new file mode 100644
index 000000000000..f2e1f024513f
--- /dev/null
+++ b/arch/arm/boards/skov-imx6/version.c
@@ -0,0 +1,257 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0
+ */
+
+#include <stdio.h>
+#include <driver.h>
+#include <malloc.h>
+#include <init.h>
+#include <of.h>
+#include <of_gpio.h>
+#include <gpio.h>
+#include <printk.h>
+#include <globalvar.h>
+#include <linux/kernel.h>
+
+#define MAX_V_GPIO 8
+
+struct board_description {
+	const char *value;
+	const char *revision;
+	const char *soc;
+	const char *dts_compatible;
+};
+
+static const struct board_description imx6_variants[] = {
+	[0] = {
+		.value = "high performance",
+		.revision = "A",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revA",
+	},
+	[1] = {
+		.value = "low cost",
+		.revision = "A",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revA",
+	},
+	[2] = {
+		.value = "high performance",
+		.revision = "A",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revA",
+	},
+	[4] = {
+		.value = "low cost",
+		.revision = "A",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revA",
+	},
+	[8] = {
+		.value = "high performance",
+		.revision = "A",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revA",
+	},
+	[9] = {
+		.value = "minimum cost",
+		.revision = "B",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revB",
+	},
+	[10] = {
+		.value = "low cost",
+		.revision = "B",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revB",
+	},
+	[11] = {
+		.value = "high performance",
+		.revision = "B",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revB",
+	},
+	[12] = {
+		/* FIXME this one is a revision 'C' according to the schematics */
+		.value = "max performance",
+		.revision = "B",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revB",
+	},
+	[13] = {
+		.value = "low cost",
+		.revision = "C",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revC",
+	},
+	[14] = {
+		.value = "high performance",
+		.revision = "C",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revC",
+	},
+	[15] = {
+		.value = "middle performance",
+		.revision = "C",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revC",
+	},
+	[16] = {
+		.value = "Solo_R512M_F4G",
+		.revision = "C",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revC",
+	},
+	[17] = {
+		.value = "Quad_R2G_F8G",
+		.revision = "C",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revC",
+	},
+	[18] = {
+		.value = "QuadPlus_R4G_F16G",
+		.revision = "C",
+		.soc = "i.MX6Q+",
+		.dts_compatible = "skov,imx6-imxq-revC",
+	},
+	[19] = {
+		.value = "Solo_R512M_F2G",
+		.revision = "C",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revC",
+	},
+	[20] = {
+		.value = "Quad_R1G_F4G",
+		.revision = "C",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revC",
+	},
+	[21] = {
+		.value = "Solo_R512M_F2G",
+		.revision = "C",
+		.soc = "i.MX6S",
+		.dts_compatible = "skov,imx6-imxdl-revC",
+	},
+	[22] = {
+		.value = "Quad_R1G_F4G",
+		.revision = "C",
+		.soc = "i.MX6Q",
+		.dts_compatible = "skov,imx6-imxq-revC",
+	},
+};
+
+/*
+ * Some variants need tweaks to make them work
+ *
+ * Revision A has no backlight control, since revision B it is present (GPIO6/23)
+ * Revision A needs GPIO1/24 to be low to make network working
+ * Revision C can control the SD main power supply
+ */
+static void tweak_board(unsigned var)
+{
+	switch (var) {
+	case 0 ... 8:
+		/*
+		 * MX6QDL_PAD_ENET_RX_ER__GPIO1_IO24 is a gpio which must be
+		 * low to enable the RMII from the switch point of view
+		 */
+		gpio_request(24, "must_be_low");
+		gpio_direction_output(24, 0);
+		break;
+	}
+
+	/* backlight handling */
+	switch (var) {
+	case 0 ... 8:
+		break;
+	default:
+		gpio_request(183, "backlight switch");
+		gpio_direction_output(183, 1); /* switch it off as early as possible */
+		gpio_request(1, "backlight brightness");
+		gpio_direction_output(1, 0); /* dark */
+	}
+
+	/* SD card handling */
+	gpio_request(205, "mmc io supply");
+	gpio_direction_output(205, 0); /* select 3.3 V IO voltage */
+
+	switch (var) {
+	case 0 ... 12:
+		break;
+	default:
+		/* keep in sync with devicetree's 'regulator-boot-on' setting for this regulator */
+		gpio_request(200, "mmc power supply");
+		gpio_direction_output(200, 1); /* switch on */
+	}
+}
+
+static int skov_version_probe(struct device_d *dev)
+{
+	struct device_node *np = dev->device_node;
+	static char *gpio_name = "skov-imx6-variant-0"; /* don't change content */
+	char *number;
+	unsigned var = 0;
+	int i, rc, gpios[MAX_V_GPIO];
+
+	/* expected order in device tree is GPIO version bit 0 ... GPIO version bit 'n' */
+	for (i = 0; i < MAX_V_GPIO; i++) {
+		gpios[i] = of_get_named_gpio(np, "version-gpio", i);
+		if (gpios[i] < 0) {
+			dev_err(dev, "Not enough GPIOs defined.\n");
+			dev_err(dev, "Expected 0..%d, but failed at %d.\n", MAX_V_GPIO - 1, i + 1);
+			goto unclaim_on_error;
+		}
+		gpio_name[18] = '0' + i; /* keep in sync with its content */
+		rc = gpio_request(gpios[i], gpio_name);
+		if (rc < 0) {
+			dev_err(dev, "Failed to claim GPIO %d as '%s'\n", gpios[i], gpio_name);
+			goto unclaim_on_error;
+		}
+		gpio_direction_input(gpios[i]);
+	}
+
+	for (i = MAX_V_GPIO - 1; i >= 0; i--) {
+		var <<= 1;
+		var |= !!!gpio_get_value(gpios[i]);
+	}
+
+	if (var >= ARRAY_SIZE(imx6_variants)) {
+		dev_err(dev, "Invalid 'version' value. Expected up to %u, but got %u\n", ARRAY_SIZE(imx6_variants) - 1, var);
+		goto unclaim_on_error;
+	}
+
+	asprintf(&number, "%u", var);
+	globalvar_add_simple("board.no", number);
+	globalvar_add_simple("board.variant", imx6_variants[var].value == NULL ? "undefined" : imx6_variants[var].value);
+	globalvar_add_simple("board.revision", imx6_variants[var].revision == NULL ? "undefined" : imx6_variants[var].revision);
+	globalvar_add_simple("board.soc", imx6_variants[var].soc == NULL ? "undefined" : imx6_variants[var].soc);
+	globalvar_add_simple("board.dts", imx6_variants[var].dts_compatible == NULL ? "undefined" : imx6_variants[var].dts_compatible);
+
+	tweak_board(var);
+
+	free(number);
+	return 0;
+
+unclaim_on_error:
+	dev_err(dev, "Invalid/incomplete 'version' GPIO declaration in devicetree\n");
+	dev_dbg(dev, "Check 'skov-imx6,version' node for %d GPIO entries\n", MAX_V_GPIO);
+	i--;
+	while (i >= 0)
+		gpio_free(gpios[i--]);
+	return -ENODEV;
+}
+
+static __maybe_unused struct of_device_id skov_version_ids[] = {
+	{
+		.compatible = "skov-imx6,version",
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct driver_d skov_version_driver = {
+	.name = "skov-imx6-variant",
+	.probe = skov_version_probe,
+	.of_compatible = DRV_OF_COMPAT(skov_version_ids),
+};
+device_platform_driver(skov_version_driver);
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 813e09814546..8c332568e789 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -57,6 +57,7 @@ pbl-dtb-$(CONFIG_MACH_RADXA_ROCK) += rk3188-radxarock.dtb.o
 pbl-dtb-$(CONFIG_MACH_REALQ7) += imx6q-dmo-edmqmx6.dtb.o
 pbl-dtb-$(CONFIG_MACH_SABRELITE) += imx6q-sabrelite.dtb.o imx6dl-sabrelite.dtb.o
 pbl-dtb-$(CONFIG_MACH_SABRESD) += imx6q-sabresd.dtb.o
+pbl-dtb-$(CONFIG_MACH_SKOV_IMX6) += imx6dl-skov-imx6.dtb.o imx6q-skov-imx6.dtb.o
 pbl-dtb-$(CONFIG_MACH_FREESCALE_IMX6SX_SABRESDB) += imx6sx-sdb.dtb.o
 pbl-dtb-$(CONFIG_MACH_SOCFPGA_ALTERA_SOCDK) += socfpga_cyclone5_socdk.dtb.o
 pbl-dtb-$(CONFIG_MACH_SOCFPGA_EBV_SOCRATES) += socfpga_cyclone5_socrates.dtb.o
diff --git a/arch/arm/dts/imx6dl-skov-imx6.dts b/arch/arm/dts/imx6dl-skov-imx6.dts
new file mode 100644
index 000000000000..e7e4310ebf47
--- /dev/null
+++ b/arch/arm/dts/imx6dl-skov-imx6.dts
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2015 Juergen Borleis, Pengutronix <kernel@pengutronix.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6dl.dtsi"
+#include <arm/imx6dl.dtsi>
+#include "imx6qdl-skov-imx6.dtsi"
+
+/ {
+	model = "Skov IMX6";
+	compatible = "skov,imx6", "fsl,imx6dl";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+};
diff --git a/arch/arm/dts/imx6q-skov-imx6.dts b/arch/arm/dts/imx6q-skov-imx6.dts
new file mode 100644
index 000000000000..33b2ebe41c22
--- /dev/null
+++ b/arch/arm/dts/imx6q-skov-imx6.dts
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2015 Juergen Borleis, Pengutronix <kernel@pengutronix.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include "imx6q.dtsi"
+#include <arm/imx6q.dtsi>
+#include "imx6qdl-skov-imx6.dtsi"
+
+/ {
+	model = "Skov IMX6";
+	compatible = "skov,imx6", "fsl,imx6q";
+
+	chosen {
+		stdout-path = &uart2;
+	};
+};
diff --git a/arch/arm/dts/imx6qdl-skov-imx6.dtsi b/arch/arm/dts/imx6qdl-skov-imx6.dtsi
new file mode 100644
index 000000000000..3ddc58c55d51
--- /dev/null
+++ b/arch/arm/dts/imx6qdl-skov-imx6.dtsi
@@ -0,0 +1,318 @@
+/*
+ * Copyright 2015 Juergen Borleis, Pengutronix <kernel@pengutronix.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/ {
+	barebox_environment {
+		compatible = "barebox,environment";
+		device-path = &barebox_env;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led0: D1 {
+			label = "D1";
+			gpios = <&gpio1 2 0>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+
+		led1: D2 {
+			label = "D2";
+			gpios = <&gpio1 0 0>; 
+			default-state = "off";
+		};
+
+		led2: D3 {
+			label = "D3";
+			gpios = <&gpio1 4 0>;
+			default-state = "on";
+		};
+	};
+
+	skov_version {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_version>;
+		status = "okay";
+		compatible = "skov-imx6,version";
+		version-gpio = <&gpio2 10 0>, <&gpio2 15 0>, <&gpio2 8 0>, <&gpio2 9 0>, <&gpio2 12 0>, <&gpio2 14 0>, <&gpio2 11 0>, <&gpio2 13 0>;
+	};	
+
+	/* State: mutable part */
+	state: state {
+		magic = <0x34a0fc27>;
+		compatible = "barebox,state";
+		backend-type = "raw";
+		backend = <&state_storage>;
+		backend-stridesize = <0x40>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		bootstate {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			system0 { /* the node's name here must match the subnode's name in the 'bootstate' node */
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				remaining_attempts {
+					reg = <0x0 0x4>;
+					type = "uint32";
+					default = <3>;
+				};
+				priority {
+					reg = <0x4 0x4>;
+					type = "uint32";
+					default = <30>;
+				};
+			};
+
+			system1 { /* the node's name here must match the subnode's name in the 'bootstate' node */
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				remaining_attempts {
+					reg = <0x8 0x4>;
+					type = "uint32";
+					default = <3>;
+				};
+				priority {
+					reg = <0xC 0x4>;
+					type = "uint32";
+					default = <20>;
+				};
+			};
+
+			last_chosen {
+				reg = <0x10 0x4>;
+				type = "uint32";
+			};
+		};
+
+		kmsfb-manage-conf {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			xres {
+				reg = <0x14 0x4>;
+				type = "uint32";
+				default = <800>;
+			};
+
+			yres {
+				reg = <0x18 0x4>;
+				type = "uint32";
+				default = <480>;
+			};
+		};
+
+		display {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			brightness {
+				reg = <0x1C 0x1>;
+				type = "uint8";
+				default = <8>;
+			};
+		};
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	pinctrl_hog: hoggrp {
+		/* we need a few pins as GPIOs */
+		fsl,pins = <
+			/* MMC IO voltage select */
+			MX6QDL_PAD_GPIO_18__GPIO7_IO13 0x40000058
+			/* MMC Power Supply Switch (since revision C)
+			MX6QDL_PAD_SD3_RST__GPIO7_IO08 0x40000058
+			/* Backlight Power Supply Switch (since revision B)
+			MX6QDL_PAD_RGMII_TD3__GPIO6_IO23 0x40000058
+			/* Backlight Brightness */
+			MX6QDL_PAD_GPIO_1__GPIO1_IO01 0x40000058
+			/* must be high */
+			MX6QDL_PAD_ENET_RX_ER__GPIO1_IO24 0x40000058
+		>;
+	};
+
+	pinctrl_version: versiongrp {
+		fsl,pins = <
+			MX6QDL_PAD_SD4_DAT0__GPIO2_IO08 0x1b040
+			MX6QDL_PAD_SD4_DAT1__GPIO2_IO09 0x1b040
+			MX6QDL_PAD_SD4_DAT2__GPIO2_IO10 0x1b040
+			MX6QDL_PAD_SD4_DAT3__GPIO2_IO11 0x1b040
+			MX6QDL_PAD_SD4_DAT4__GPIO2_IO12 0x1b040
+			MX6QDL_PAD_SD4_DAT5__GPIO2_IO13 0x1b040
+			MX6QDL_PAD_SD4_DAT6__GPIO2_IO14 0x1b040
+			MX6QDL_PAD_SD4_DAT7__GPIO2_IO15 0x1b040
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
+			MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
+		>;
+	};
+
+	pinctrl_ecspi1: ecspi1grp {
+		fsl,pins = <
+			MX6QDL_PAD_EIM_D17__ECSPI1_MISO 0x100b1
+			MX6QDL_PAD_EIM_D18__ECSPI1_MOSI 0x100b1
+			MX6QDL_PAD_EIM_D16__ECSPI1_SCLK 0x100b1
+			MX6QDL_PAD_EIM_D24__GPIO3_IO24 0x40000058 /* CS# signal */
+		>;
+	};
+
+	/* pins for eth0 */
+	pinctrl_enet: enetgrp {
+		fsl,pins = <
+			MX6QDL_PAD_ENET_MDIO__ENET_MDIO 0x100b0
+			MX6QDL_PAD_ENET_MDC__ENET_MDC 0x100b0
+			MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN 0x100b0
+			MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN 0x100b0
+			MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0 0x100b0
+			MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1 0x100b0
+			MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0 0x100b0
+			MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1 0x100b0
+			MX6QDL_PAD_GPIO_16__ENET_REF_CLK 0x400000c0
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX6QDL_PAD_SD3_CMD__SD3_CMD 0x17059
+			MX6QDL_PAD_SD3_CLK__SD3_CLK 0x10059
+			MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
+			MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
+			MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
+			MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
+			MX6QDL_PAD_SD3_DAT4__GPIO7_IO01 0x1b040 /* WP */
+			MX6QDL_PAD_SD3_DAT5__GPIO7_IO00 0x1b040 /* CD */
+		>;
+	};
+
+	pinctrl_gpmi_nand: gpminandgrp {
+		fsl,pins = <
+			MX6QDL_PAD_NANDF_CLE__NAND_CLE 0xb0b1
+			MX6QDL_PAD_NANDF_ALE__NAND_ALE 0xb0b1
+			MX6QDL_PAD_NANDF_RB0__NAND_READY_B 0xb000
+			MX6QDL_PAD_NANDF_CS0__NAND_CE0_B 0xb0b1
+			MX6QDL_PAD_NANDF_CS1__NAND_CE1_B 0xb0b1
+			MX6QDL_PAD_SD4_CMD__NAND_RE_B 0xb0b1
+			MX6QDL_PAD_SD4_CLK__NAND_WE_B 0xb0b1
+			MX6QDL_PAD_NANDF_D0__NAND_DATA00 0xb0b1
+			MX6QDL_PAD_NANDF_D1__NAND_DATA01 0xb0b1
+			MX6QDL_PAD_NANDF_D2__NAND_DATA02 0xb0b1
+			MX6QDL_PAD_NANDF_D3__NAND_DATA03 0xb0b1
+			MX6QDL_PAD_NANDF_D4__NAND_DATA04 0xb0b1
+			MX6QDL_PAD_NANDF_D5__NAND_DATA05 0xb0b1
+			MX6QDL_PAD_NANDF_D6__NAND_DATA06 0xb0b1
+			MX6QDL_PAD_NANDF_D7__NAND_DATA07 0xb0b1
+		>;
+	};
+};
+
+/* console */
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+/* spi */
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 24 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "okay";
+
+	norflash: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,n25q064", "st,m25p";
+		spi-max-frequency = <54000000>;
+		reg = <0>;
+	};
+};
+
+/* eth0 */
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rmii";
+	status = "okay";
+	phy-reset-gpios = <&gpio1 5 0>;
+	phy-reset-duration = <100>;
+	#address-cells = <0>;
+	#size-cells = <1>;
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&wdog1 {
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	wp-gpios = <&gpio7 1 0>;
+	cd-gpios = <&gpio7 0 0>;
+	status = "okay";
+	fsl,delay-line;
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand>;
+	nand-on-flash-bbt;
+	status = "okay";
+
+	partition@0 {
+		label = "firmware";
+		reg = <0x00000000 0x000000000>; /* keep zero sized to enable autodetection */
+	};
+};
+
+/* define the SPI based 8 MiB NOR flash layout */
+&norflash {
+	partition@0 {
+		label = "barebox";
+		reg = <0x0 0x100000>;
+	};
+
+	/* space left to let barebox grow */
+
+	/* placed near the end of the NOR memory */
+	barebox_env: partition@780000 {
+		label = "barebox-environment";
+		reg = <0x780000 0x40000>;
+	};
+
+	/* placed at the end of the NOR memory */
+	state_storage: partition@7C0000 {
+		label = "barebox-state";
+		reg = <0x7C0000 0x40000>; /* four times mirrored */
+	};
+};
+
+&ocotp {
+	barebox,provide-mac-address = <&fec 0x620>;
+};
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index 80f8fd80aecc..c336e4ecd8a8 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -316,6 +316,11 @@ config MACH_CM_FX6
 	bool "CM FX6"
 	select ARCH_IMX6
 
+config MACH_SKOV_IMX6
+	bool "Skov IMX6"
+	select ARCH_IMX6
+	select ARM_USE_COMPRESSED_DTB
+
 endif
 
 # ----------------------------------------------------------
diff --git a/common/blspec.c b/common/blspec.c
index bf98e6b29acd..3f844bdf5569 100644
--- a/common/blspec.c
+++ b/common/blspec.c
@@ -258,14 +258,18 @@ static bool entry_is_of_compatible(struct blspec_entry *entry)
 	const char *compat;
 	char *filename;
 
-	/* If we don't have a root node every entry is compatible */
-	barebox_root = of_get_root_node();
-	if (!barebox_root)
-		return true;
-
-	ret = of_property_read_string(barebox_root, "compatible", &compat);
-	if (ret)
-		return false;
+	/* try the shortcut first */
+	compat = getenv("global.board.dts");
+	if (compat == NULL) {
+		/* If we don't have a root node every entry is compatible */
+		barebox_root = of_get_root_node();
+		if (!barebox_root)
+			return true;
+
+		ret = of_property_read_string(barebox_root, "compatible", &compat);
+		if (ret)
+			return false;
+	}
 
 	if (entry->rootpath)
 		abspath = entry->rootpath;
diff --git a/images/Makefile.imx b/images/Makefile.imx
index effa5edc0f6e..5e3c58260b6d 100644
--- a/images/Makefile.imx
+++ b/images/Makefile.imx
@@ -378,6 +378,11 @@ CFG_start_phytec_phycore_imx6dl_som_emmc_1gib.pblx.imximg = $(board)/phytec-som-
 FILE_barebox-phytec-phycore-imx6dl-som-emmc-1gib.img = start_phytec_phycore_imx6dl_som_emmc_1gib.pblx.imximg
 image-$(CONFIG_MACH_PHYTEC_SOM_IMX6) += barebox-phytec-phycore-imx6dl-som-emmc-1gib.img
 
+pblx-$(CONFIG_MACH_SKOV_IMX6) += start_imx6_skov_imx6
+CFG_start_imx6_skov_imx6.imx-sram-img = $(board)/skov-imx6/flash-header-mx6-skov-imx6.imxcfg
+FILE_barebox-skov-imx6.img = start_imx6_skov_imx6.imx-sram-img
+image-$(CONFIG_MACH_SKOV_IMX6) += barebox-skov-imx6.img
+
 pblx-$(CONFIG_MACH_GW_VENTANA) += start_imx6q_gw54xx_1gx64
 CFG_start_imx6q_gw54xx_1gx64.pblx.imximg = $(board)/gateworks-ventana/flash-header-ventana-quad-1gx64.imxcfg
 FILE_barebox-gateworks-imx6q-ventana-1gx64.img = start_imx6q_gw54xx_1gx64.pblx.imximg
