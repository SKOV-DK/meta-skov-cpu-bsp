From ed0a0598a68ab3c7722bd73252a256da9398913d Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Fri, 30 Dec 2016 11:00:11 +0100
Subject: [PATCH 1/1] at91 skov

---
 Makefile                  |   2 +-
 board/Config.in           |  32 ++-
 board/arm9-cpu/arm9-cpu.c | 643 ++++++++++++++++++++++++++++++++++++++++++++++
 board/arm9-cpu/arm9-cpu.h | 172 +++++++++++++
 board/arm9-cpu/board.mk   |   8 +
 crt0_gnu.S                | 115 ++++-----
 driver/flash.c            |  37 ++-
 driver/nandflash.c        |   4 +-
 driver/pmc.c              |  13 +-
 driver/serial_flash.c     |  12 +-
 include/board.h           |   4 +
 include/flash.h           |   3 +-
 include/nandflash.h       |   7 +
 main.c                    |  66 +++--
 toplevel_cpp.mk           |   7 +
 15 files changed, 1012 insertions(+), 113 deletions(-)
 create mode 100644 board/arm9-cpu/arm9-cpu.c
 create mode 100644 board/arm9-cpu/arm9-cpu.h
 create mode 100644 board/arm9-cpu/board.mk

diff --git a/Makefile b/Makefile
index 3f82f14..79837e0 100644
--- a/Makefile
+++ b/Makefile
@@ -182,7 +182,7 @@ include	driver/driver_cpp.mk
 #  -lc 	   : 	tells the linker to tie in newlib
 #  -lgcc   : 	tells the linker to tie in newlib
 LDFLAGS+=-nostartfiles -Map=$(BINDIR)/$(BOOT_NAME).map --cref
-LDFLAGS+=-T elf32-littlearm.lds $(GC_SECTIONS) -Ttext $(LINK_ADDR)
+LDFLAGS+=-T elf32-littlearm.lds $(GC_SECTIONS) -Ttext $(LINK_ADDR) -Tdata 0x00310000
 
 ifneq ($(DATA_SECTION_ADDR),)
 LDFLAGS+=-Tdata $(DATA_SECTION_ADDR)
diff --git a/board/Config.in b/board/Config.in
index 3e1cc4e..e468ec3 100644
--- a/board/Config.in
+++ b/board/Config.in
@@ -4,13 +4,13 @@ config	HAVE_DOT_CONFIG
 
 config CONFIG_BOARDNAME
 	string "Board Name"
-	default "at91sam9260ek"
+	default "arm9-cpu"
 	help
 	  Name of the target
 
 choice
 	prompt "Board Type"
-	default	CONFIG_AT91SAM9260EK
+	default	CONFIG_ARM9_CPU
 	help
 	  Select which board you want to build for
 
@@ -63,6 +63,24 @@ config	CONFIG_AT91SAM9263EK
 	help
 	  Use the AT91SAM9263EK Development board
 
+config  CONFIG_ARM9_CPU
+        bool "SKOV ARM9-CPU"
+        select CONFIG_SDRAM   
+        select ALLOW_FLASH
+	select ALLOW_DATAFLASH
+        select ALLOW_NANDFLASH
+        select ALLOW_SDCARD
+        select ALLOW_SDRAM_16BIT   
+        select DATAFLASHCARD_ON_CS0
+        select ALLOW_CPU_CLK_200MHZ
+        select ALLOW_CPU_CLK_240MHZ
+        select ALLOW_CRYSTAL_16_000MHZ
+        select ALLOW_BOOT_FROM_DATAFLASH_CS0
+        select ALLOW_DATAFLASH_RECOVERY
+        select ALLOW_NANDFLASH_RECOVERY
+        help
+          Use the SKOV ARM9 CPU Module
+
 config	CONFIG_AT91SAM9RLEK
 	bool "at91sam9rlek"
 	select ALLOW_DATAFLASH
@@ -192,6 +210,7 @@ endchoice
 
 config CONFIG_CHIP
 	string
+	default "AT91SAM9263"	if CONFIG_ARM9_CPU
 	default "AT91SAM9260"	if CONFIG_AT91SAM9260EK
 	default "AT91SAM9261"	if CONFIG_AT91SAM9261EK
 	default "AT91SAM9263"	if CONFIG_AT91SAM9263EK
@@ -209,6 +228,7 @@ config CONFIG_CHIP
 
 config CONFIG_BOARD
 	string
+	default "arm9-cpu"	if CONFIG_ARM9_CPU
 	default "at91sam9260ek"	if CONFIG_AT91SAM9260EK
 	default "at91sam9261ek"	if CONFIG_AT91SAM9261EK
 	default "at91sam9263ek"	if CONFIG_AT91SAM9263EK
@@ -229,6 +249,7 @@ config CONFIG_MACH_TYPE
 	default "1099"	if CONFIG_AT91SAM9260EK
 	default "0x350"	if CONFIG_AT91SAM9261EK
 	default "0x4B2"	if CONFIG_AT91SAM9263EK	
+	default "0x4B2" if CONFIG_ARM9_CPU
 	default "1326"	if CONFIG_AT91SAM9RLEK
 	default "0x44B"	if CONFIG_AT91SAM9XEEK
 	default "0x86F"	if CONFIG_AT91SAM9G10EK		
@@ -254,6 +275,7 @@ config CONFIG_TOP_OF_MEMORY
 	default "0x301000"	if CONFIG_AT91SAM9260EK
 	default "0x328000"	if CONFIG_AT91SAM9261EK
 	default "0x314000"	if CONFIG_AT91SAM9263EK	
+	default "0x314000"      if CONFIG_ARM9_CPU
 	default "0x310000"	if CONFIG_AT91SAM9RLEK
 	default "0x306000"	if CONFIG_AT91SAM9XEEK
 	default "0x304000"	if CONFIG_AT91SAM9G10EK
@@ -375,7 +397,7 @@ config	DISABLE_CPU_CLK_240MHZ
 
 choice
 	prompt "Bus Speed"
-	default CONFIG_BUS_SPEED_133MHZ
+	default CONFIG_BUS_SPEED_100MHZ
 	help
 	  Select the speed of the bus
 
@@ -391,6 +413,10 @@ config CONFIG_BUS_SPEED_100MHZ
 	bool "100 MHz"
 	depends on ALLOW_CPU_CLK_200MHZ || ALLOW_CPU_CLK_400MHZ
 
+config CONFIG_BUS_SPEED_120MHZ
+	bool "120 MHz"
+	depends on ALLOW_CPU_CLK_240MHZ
+
 config CONFIG_BUS_SPEED_133MHZ
 	bool "133 MHz"
 	depends on ALLOW_CPU_CLK_400MHZ || ALLOW_CPU_CLK_266MHZ
diff --git a/board/arm9-cpu/arm9-cpu.c b/board/arm9-cpu/arm9-cpu.c
new file mode 100644
index 0000000..1cb90bc
--- /dev/null
+++ b/board/arm9-cpu/arm9-cpu.c
@@ -0,0 +1,643 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2009, Atmel Corporation
+ * All rights reserved.
+ * PSRAM,16 bit SDRAM support courtesy of Epsilon Group
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "common.h"
+#include "hardware.h"
+#include "arch/at91_ccfg.h"
+#include "arch/at91_matrix.h"
+#include "arch/at91_wdt.h"
+#include "arch/at91_rstc.h"
+#include "arch/at91_pmc.h"
+#include "arch/at91_smc.h"
+#include "arch/at91_pio.h"
+#include "arch/at91_sdramc.h"
+#include "spi.h"
+#include "gpio.h"
+#include "pmc.h"
+#include "dbgu.h"
+#include "debug.h"
+#include "sdramc.h"
+#include "psram.h"
+#include "pit_timer.h"
+#include "arm9-cpu.h"
+#include "nand.h"
+#include "nandflash.h"
+
+#ifdef CONFIG_USER_HW_INIT
+extern void hw_init_hook(void);
+#endif
+
+static int test_var_init = 0xacdcabba;
+
+static inline void matrix_writel(const unsigned int value, unsigned int reg)
+{
+	writel(value, reg + AT91C_BASE_MATRIX);
+}
+
+static inline unsigned int matrix_readl(unsigned int reg)
+{
+	return readl(reg + AT91C_BASE_MATRIX);
+}
+
+static void at91_matrix_hw_init(void)
+{
+	/* Bus Matrix Master Configuration Register */
+	matrix_writel(AT91C_MATRIX_ULBT_16_BEAT, MATRIX_MCFG0);		/* OHCI */
+	matrix_writel(AT91C_MATRIX_ULBT_8_BEAT, MATRIX_MCFG1);		/* ISI */
+	matrix_writel(AT91C_MATRIX_ULBT_8_BEAT, MATRIX_MCFG2);		/* 2D */
+	matrix_writel(AT91C_MATRIX_ULBT_8_BEAT, MATRIX_MCFG3);		/* DMAC */
+	matrix_writel(AT91C_MATRIX_ULBT_4_BEAT, MATRIX_MCFG4);		/* MACB */
+	matrix_writel(AT91C_MATRIX_ULBT_16_BEAT, MATRIX_MCFG5);		/* LCDC */
+	matrix_writel(AT91C_MATRIX_ULBT_SINGLE_ACCESS, MATRIX_MCFG6);	/* PDC */
+	matrix_writel(AT91C_MATRIX_ULBT_8_BEAT, MATRIX_MCFG7);		/* DBUS */
+	matrix_writel(AT91C_MATRIX_ULBT_4_BEAT, MATRIX_MCFG8);		/* IBUS */
+
+	/* Bus Matrix Slave Configuration Registers */
+	matrix_writel((AT91C_MATRIX_ARBT_FIXED_PRIORITY
+			| AT91C_MATRIX_FIXED_DEFMSTR_ARM926I
+			| AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR
+			| AT91C_MATRIX_SLOT_CYCLE_(32)),
+			MATRIX_SCFG0);		/* ROM */
+
+	matrix_writel((AT91C_MATRIX_ARBT_FIXED_PRIORITY
+			| AT91C_MATRIX_FIXED_DEFMSTR_EMAC
+			| AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR
+			| AT91C_MATRIX_SLOT_CYCLE_(32)),
+			MATRIX_SCFG1);		/* RAM80K */
+
+	matrix_writel((AT91C_MATRIX_ARBT_FIXED_PRIORITY
+			| AT91C_MATRIX_FIXED_DEFMSTR_USB
+			| AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR
+			| AT91C_MATRIX_SLOT_CYCLE_(16)),
+			MATRIX_SCFG2);		/* RAM16K */
+
+	matrix_writel((AT91C_MATRIX_ARBT_FIXED_PRIORITY
+			| AT91C_MATRIX_FIXED_DEFMSTR_PDC
+			| AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR
+			| AT91C_MATRIX_SLOT_CYCLE_(4)),
+			MATRIX_SCFG3);		/* PERIPHERALS */
+
+	matrix_writel((AT91C_MATRIX_ARBT_ROUND_ROBIN
+			| AT91C_MATRIX_FIXED_DEFMSTR_ARM926I
+			| AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR
+			| AT91C_MATRIX_SLOT_CYCLE_(32)),
+			MATRIX_SCFG4);		/* EBI0 */
+
+	matrix_writel((AT91C_MATRIX_ARBT_FIXED_PRIORITY
+			| AT91C_MATRIX_FIXED_DEFMSTR_LCDC
+			| AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR
+			| AT91C_MATRIX_SLOT_CYCLE_(64)),
+			MATRIX_SCFG5);		/* EBI1 */
+
+	matrix_writel((AT91C_MATRIX_ARBT_FIXED_PRIORITY
+			| AT91C_MATRIX_FIXED_DEFMSTR_ARM926D
+			| AT91C_MATRIX_DEFMSTR_TYPE_LAST_DEFMSTR
+			| AT91C_MATRIX_SLOT_CYCLE_(4)),
+			MATRIX_SCFG6);		/* APB */
+
+	/* ROM */
+	matrix_writel((AT91C_MATRIX_M0PR_(1)
+			| AT91C_MATRIX_M1PR_(0)
+			| AT91C_MATRIX_M2PR_(2)
+			| AT91C_MATRIX_M3PR_(1)
+			| AT91C_MATRIX_M4PR_(0)
+			| AT91C_MATRIX_M5PR_(3)
+			| AT91C_MATRIX_M6PR_(2)
+			| AT91C_MATRIX_M7PR_(3)),
+			MATRIX_PRAS0);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(0),
+			MATRIX_PRBS0);
+
+	/* RAM80K */
+	matrix_writel((AT91C_MATRIX_M0PR_(1)
+			| AT91C_MATRIX_M1PR_(2)
+			| AT91C_MATRIX_M2PR_(1)
+			| AT91C_MATRIX_M3PR_(3)
+			| AT91C_MATRIX_M4PR_(0)
+			| AT91C_MATRIX_M5PR_(0)
+			| AT91C_MATRIX_M6PR_(3)
+			| AT91C_MATRIX_M7PR_(0)),
+			MATRIX_PRAS1);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(2),
+			MATRIX_PRBS1);
+
+	/* RAM16K */
+	matrix_writel((AT91C_MATRIX_M0PR_(1)
+			| AT91C_MATRIX_M1PR_(0)
+			| AT91C_MATRIX_M2PR_(2)
+			| AT91C_MATRIX_M3PR_(1)
+			| AT91C_MATRIX_M4PR_(0)
+			| AT91C_MATRIX_M5PR_(3)
+			| AT91C_MATRIX_M6PR_(3)
+			| AT91C_MATRIX_M7PR_(2)),
+			MATRIX_PRAS2);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(0),
+			MATRIX_PRBS2);
+
+	/* PERIPHERALS */
+	matrix_writel((AT91C_MATRIX_M0PR_(0)
+			| AT91C_MATRIX_M1PR_(1)
+			| AT91C_MATRIX_M2PR_(0)
+			| AT91C_MATRIX_M3PR_(2)
+			| AT91C_MATRIX_M4PR_(1)
+			| AT91C_MATRIX_M5PR_(0)
+			| AT91C_MATRIX_M6PR_(3)
+			| AT91C_MATRIX_M7PR_(2)),
+			MATRIX_PRAS3);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(3),
+			MATRIX_PRBS3);
+
+#if defined(CONFIG_PSRAM)
+	/* EBI0 */
+	matrix_writel((AT91C_MATRIX_M0PR_(2)
+			| AT91C_MATRIX_M1PR_(1)
+			| AT91C_MATRIX_M2PR_(1)
+			| AT91C_MATRIX_M3PR_(3)
+			| AT91C_MATRIX_M4PR_(0)
+			| AT91C_MATRIX_M5PR_(3)
+			| AT91C_MATRIX_M6PR_(0)
+			| AT91C_MATRIX_M7PR_(0)),
+			MATRIX_PRAS4);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(2),
+			MATRIX_PRBS4);
+#else
+	/* EBI0 */
+	matrix_writel((AT91C_MATRIX_M0PR_(1)
+			| AT91C_MATRIX_M1PR_(3)
+			| AT91C_MATRIX_M2PR_(0)
+			| AT91C_MATRIX_M3PR_(2)
+			| AT91C_MATRIX_M4PR_(3)
+			| AT91C_MATRIX_M5PR_(0)
+			| AT91C_MATRIX_M6PR_(0)
+			| AT91C_MATRIX_M7PR_(1)),
+			MATRIX_PRAS4);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(2),
+			MATRIX_PRBS4);
+#endif /* #if defined(CONFIG_PSRAM) */
+	/* EBI1 */
+	matrix_writel((AT91C_MATRIX_M0PR_(0)
+			| AT91C_MATRIX_M1PR_(1)
+			| AT91C_MATRIX_M2PR_(0)
+			| AT91C_MATRIX_M3PR_(0)
+			| AT91C_MATRIX_M4PR_(3)
+			| AT91C_MATRIX_M5PR_(2)
+			| AT91C_MATRIX_M6PR_(3)
+			| AT91C_MATRIX_M7PR_(2)),
+			MATRIX_PRAS5);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(1),
+			MATRIX_PRBS5);
+
+	/* APB */
+	matrix_writel((AT91C_MATRIX_M0PR_(1)
+			| AT91C_MATRIX_M1PR_(0)
+			| AT91C_MATRIX_M2PR_(2)
+			| AT91C_MATRIX_M3PR_(1)
+			| AT91C_MATRIX_M4PR_(0)
+			| AT91C_MATRIX_M5PR_(0)
+			| AT91C_MATRIX_M6PR_(3)
+			| AT91C_MATRIX_M7PR_(3)),
+			MATRIX_PRAS4);
+
+	matrix_writel(AT91C_MATRIX_M8PR_(2),
+			MATRIX_PRBS4);
+}
+
+#ifdef CONFIG_DEBUG
+static void at91_dbgu_hw_init(void)
+{
+	/* Configure DBGU pin */
+	const struct pio_desc dbgu_pins[] = {
+		{"RXD", AT91C_PIN_PC(30), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"TXD", AT91C_PIN_PC(31), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	pio_configure(dbgu_pins);
+
+	/*  Configure the dbgu pins */
+	writel((1 << AT91C_ID_PIOCDE), (PMC_PCER + AT91C_BASE_PMC));
+}
+
+static void initialize_dbgu(void)
+{
+	at91_dbgu_hw_init();
+
+	dbgu_init(BAUDRATE(MASTER_CLOCK, 115200));
+}
+#endif /* #ifdef CONFIG_DEBUG */
+
+#ifdef CONFIG_SDRAM
+static void sdramc_hw_init(void)
+{
+	/* Configure sdramc pins */
+	const struct pio_desc sdramc_pins[] = {
+		{"D16", AT91C_PIN_PD(16), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D17", AT91C_PIN_PD(17), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D18", AT91C_PIN_PD(18), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D19", AT91C_PIN_PD(19), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D20", AT91C_PIN_PD(20), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D21", AT91C_PIN_PD(21), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D22", AT91C_PIN_PD(22), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D23", AT91C_PIN_PD(23), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D24", AT91C_PIN_PD(24), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D25", AT91C_PIN_PD(25), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D26", AT91C_PIN_PD(26), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D27", AT91C_PIN_PD(27), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D28", AT91C_PIN_PD(28), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D29", AT91C_PIN_PD(29), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D30", AT91C_PIN_PD(30), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{"D31", AT91C_PIN_PD(31), 0, PIO_DEFAULT, PIO_PERIPH_A},
+		{(char *) 0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the SDRAMC PINs */
+	writel((1 << AT91C_ID_PIOCDE), (PMC_PCER + AT91C_BASE_PMC));
+	pio_configure(sdramc_pins);
+}
+
+static void sdramc0_init(void)
+{
+	unsigned int reg;
+	struct sdramc_register sdramc_config;
+	struct nand_info nand;
+	/**
+	 * @author Søren Andersen <san@rosetechnology.dk>
+	 * Variables for telling Uboot if we have 64 ot 128MB RAM 
+	 */
+	volatile unsigned int *test_adr1=(unsigned int*)0x20000000, *test_adr2=(unsigned int*)0x21000000;
+	unsigned int test_val1=(unsigned int)0x534B4F56, test_val2=(unsigned int)0x564F4B53;
+	int mem128 = 1, i;
+
+#ifdef CONFIG_SDRAM_16BIT
+	sdramc_config.cr = AT91C_SDRAMC_NC_10 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_2
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_16_BITS
+				| AT91C_SDRAMC_TWR_2 | AT91C_SDRAMC_TRC_7
+				| AT91C_SDRAMC_TRP_2 | AT91C_SDRAMC_TRCD_2
+				| AT91C_SDRAMC_TRAS_5 | AT91C_SDRAMC_TXSR_8;
+#else
+
+#ifndef CONFIG_NANDFLASH
+	sdramc_config.cr = AT91C_SDRAMC_NC_10 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_2
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_32_BITS
+				| AT91C_SDRAMC_TWR_2 | AT91C_SDRAMC_TRC_7
+				| AT91C_SDRAMC_TRP_2 | AT91C_SDRAMC_TRCD_2
+				| AT91C_SDRAMC_TRAS_5 | AT91C_SDRAMC_TXSR_8;
+#else
+	nandflash_hw_init();
+	/* Change RAM timming to fit 240MHz, if nand is present */
+	if (nandflash_detect_non_onfi(&nand) == 0) {
+		/* Nand flash found: TRC, TXSR changed. */
+		sdramc_config.cr = AT91C_SDRAMC_NC_10 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_2
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_32_BITS
+				| AT91C_SDRAMC_TWR_2 | AT91C_SDRAMC_TRC_8
+				| AT91C_SDRAMC_TRP_2 | AT91C_SDRAMC_TRCD_2
+				| AT91C_SDRAMC_TRAS_5 | AT91C_SDRAMC_TXSR_9;
+	} else {
+		sdramc_config.cr = AT91C_SDRAMC_NC_10 | AT91C_SDRAMC_NR_13 | AT91C_SDRAMC_CAS_2
+				| AT91C_SDRAMC_NB_4_BANKS | AT91C_SDRAMC_DBW_32_BITS
+				| AT91C_SDRAMC_TWR_2 | AT91C_SDRAMC_TRC_7
+				| AT91C_SDRAMC_TRP_2 | AT91C_SDRAMC_TRCD_2
+				| AT91C_SDRAMC_TRAS_5 | AT91C_SDRAMC_TXSR_8;
+	}
+#endif  /* NANDFLASH */
+#endif	/* #ifdef CONFIG_SDRAM_16BIT */
+
+	sdramc_config.tr = (MASTER_CLOCK * 7) / 1000000;
+	sdramc_config.mdr = AT91C_SDRAMC_MD_SDRAM;
+
+	sdramc_hw_init();
+
+	reg =  readl(AT91C_BASE_CCFG + CCFG_EBI0CSA);
+	reg |= AT91C_VDDIOM_SEL_33V;
+	reg |= AT91C_EBI_CS1A_SDRAMC;
+	writel(reg, AT91C_BASE_CCFG + CCFG_EBI0CSA);
+
+	sdramc_initialize(&sdramc_config, AT91C_BASE_EBI0_CS1);
+	/**
+	 *@author Søren Andersen <san@rosetechnology.dk>
+	 * Find out if we have 64 or 128 MB RAM
+	 */
+#ifndef CONFIG_SDRAM_16BIT
+	*test_adr1 = test_val1;
+	for(i = 0; i < 3000; i++) {
+		*(test_adr1+i) = test_val2+i;
+	}
+	for(i = 0; i < 3000; i++) {
+	        if((*(test_adr1+i)) == test_val2+i) {
+                	//Yes we can!!!
+                } else {   
+            		//NO: thats means we have 64MB 
+            		mem128 = 0;
+	       	}
+	}
+	if( mem128 == 1 ) { //We have 128MB Ram
+        	dbg_log(1,"128MB Ram\n\r");
+        	/** For U-Boot so it can find out how much memory we have
+		 *  Look at board/atmel/arm9-cpu/arm9-cpu.c in the U-boot section
+        	 */
+	       	*test_adr1 = test_val1; //SKOV 
+        	*test_adr2 = test_val2; //VOKS
+	} else {
+			/* Change number of colums to 9 for 64MB ram. */
+			/* Other parameters does not need to be changed due to chip size. */
+        	dbg_log(1,"64MB Ram\n\r");
+			sdramc_config.cr &=~0x3;	// Clear NC bits
+        	sdramc_config.cr |= AT91C_SDRAMC_NC_9;
+		/* For the bootloader so it can find out how much memory we have                
+		   Look at board/atmel/arm9-cpu/arm9-cpu.c in the Uboot section */
+	        sdramc_initialize(&sdramc_config, AT91C_BASE_EBI0_CS1);
+	        *test_adr1 = test_val2; //VOKS
+	        *test_adr2 = test_val1; //SKOV
+	}
+#endif /* #ifndef CONFIG_SDRAM_16BIT */
+	
+}
+#endif /* #ifdef CONFIG_SDRAM */
+
+#ifdef CONFIG_PSRAM
+
+#define CONFIG_SYS_PSRAM_DATA_ACCESS_PIN	AT91C_PIN_PE(16)
+static void data_access_enable(void)
+{
+	pio_set_value(CONFIG_SYS_PSRAM_DATA_ACCESS_PIN, 0);
+}
+
+static void psram_hw_init(void)
+{
+	unsigned short *addressMax = (unsigned short *)MICRON_8MB_ADDRESS_MAX;
+
+	const struct pio_desc psram_pins[] = {
+		{"CRE", CONFIG_SYS_PSRAM_DATA_ACCESS_PIN, 1, PIO_DEFAULT, PIO_OUTPUT},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure SMC1 CS0 */
+	writel((AT91C_SMC_NWESETUP_(0)
+		| AT91C_SMC_NCS_WRSETUP_(0)
+		| AT91C_SMC_NRDSETUP_(0)
+		| AT91C_SMC_NCS_RDSETUP_(0)),
+		AT91C_BASE_SMC1 + SMC_SETUP0);
+
+	writel((AT91C_SMC_NWEPULSE_(4)
+		| AT91C_SMC_NCS_WRPULSE_(5)
+		| AT91C_SMC_NRDPULSE_(2)
+		| AT91C_SMC_NCS_RDPULSE_(5)),
+		AT91C_BASE_SMC1 + SMC_PULSE0);
+
+	writel((AT91C_SMC_NWECYCLE_(5)
+		|  AT91C_SMC_NRDCYCLE_(7)),
+		AT91C_BASE_SMC1 + SMC_CYCLE0);
+
+	writel((AT91C_SMC_READMODE
+		| AT91C_SMC_WRITEMODE
+		| AT91C_SMC_BAT_BYTE_SELECT
+		| AT91C_SMC_DBW_WIDTH_BITS_16
+		| AT91C_SMC_PMEN
+		| AT91C_SMC_PS_SIZE_THIRTY_TWO_BYTES),
+		AT91C_BASE_SMC1 + SMC_CTRL0);
+
+	/* Configure psram pins */
+	pio_configure(psram_pins);
+
+	data_access_enable();
+
+	/* Enable page mode */
+	readl(addressMax);
+	readl(addressMax);
+	writel(MICRON_RCR, addressMax);
+	writel(MICRON_PAGE_MODE_ENABLE, addressMax);
+}
+#endif /* #ifdef CONFIG_PSRAM */
+
+#if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY)
+static void recovery_buttons_hw_init(void)
+{
+	/* Configure recovery button PINs */
+	const struct pio_desc recovery_button_pins[] = {
+		{"RECOVERY_BUTTON", CONFIG_SYS_RECOVERY_BUTTON_PIN, 0, PIO_PULLUP, PIO_INPUT},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	writel((1 << AT91C_ID_PIOCDE), PMC_PCER + AT91C_BASE_PMC);
+	pio_configure(recovery_button_pins);
+}
+#endif /* #if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY) */
+
+#ifdef CONFIG_HW_INIT
+void hw_init(void)
+{
+	struct nand_info nand;
+	/* Disable watchdog */
+	//writel(AT91C_WDTC_WDDIS, AT91C_BASE_WDT + WDTC_MR);
+	/*
+	 * At this stage the main oscillator is supposed to be enabled
+	 * PCK = MCK = MOSC
+	 */
+	/* Configure PLLA = MOSC * (PLL_MULA + 1) / PLL_DIVA */
+	pmc_cfg_plla(PLLA_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* PCK = PLLA = 2 * MCK */
+	pmc_cfg_mck(MCKR_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Switch MCK on PLLA output */
+	pmc_cfg_mck(MCKR_CSS_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Configure PLLB */
+	pmc_cfg_pllb(PLLB_SETTINGS, PLL_LOCK_TIMEOUT);
+
+	/* Enable External Reset */
+	writel(((0xA5 << 24) | AT91C_RSTC_URSTEN), AT91C_BASE_RSTC + RSTC_RMR);
+
+	at91_matrix_hw_init();
+
+	/* Init timer */
+	timer_init();
+
+#ifdef CONFIG_DEBUG
+	/* Initialize dbgu */
+	initialize_dbgu();
+#endif
+
+	/* Test if variables are initialized correctly */
+	if (test_var_init!=0xacdcabba)	{
+		dbg_log(1,"Error: test_var_init=%x\n\r",test_var_init);
+	}
+
+
+#ifdef CONFIG_SDRAM
+	/* Initialize SDRAMC0 */
+	sdramc0_init();
+#endif
+
+#if defined(CONFIG_PSRAM)
+	psram_hw_init();
+#endif
+
+#ifdef CONFIG_USER_HW_INIT
+	hw_init_hook();
+#endif
+
+#if defined(CONFIG_NANDFLASH_RECOVERY) || defined(CONFIG_DATAFLASH_RECOVERY)
+	/* Init the recovery buttons pins */
+	recovery_buttons_hw_init();
+#endif
+	/**
+	 * @author Søren Andersen <san@rosetechnology.dk>
+ 	 * IF we have a nand flsh, turn to 240 MHz
+ 	 */
+#ifdef CONFIG_NANDFLASH
+	nandflash_hw_init();
+	/* Change PLL to 240MHz, if nand is present */
+	if (nandflash_detect_non_onfi(&nand) == 0) {
+		pmc_cfg_plla(PLLA_SETTINGS_240, PLL_LOCK_TIMEOUT);	
+		pmc_cfg_mck(MCKR_SETTINGS, PLL_LOCK_TIMEOUT);
+		pmc_cfg_mck(MCKR_CSS_SETTINGS, PLL_LOCK_TIMEOUT);
+		pmc_cfg_pllb(PLLB_SETTINGS_240, PLL_LOCK_TIMEOUT);
+		dbgu_init(BAUDRATE(MASTER_CLOCK_240, 115200));
+	}
+#endif //CONFIG_NANDFLASH
+}
+#endif /* #ifdef CONFIG_HW_INIT */
+
+#ifdef CONFIG_DATAFLASH
+void at91_spi0_hw_init(void)
+{
+	/* Configure spi0 PINs */
+	const struct pio_desc spi0_pins[] = {
+		{"MISO",	AT91C_PIN_PA(0),	0, PIO_DEFAULT, PIO_PERIPH_B},
+		{"MOSI",	AT91C_PIN_PA(1),	0, PIO_DEFAULT, PIO_PERIPH_B},
+		{"SPCK",	AT91C_PIN_PA(2),	0, PIO_DEFAULT, PIO_PERIPH_B},
+		{"NPCS",	CONFIG_SYS_SPI_PCS,	1, PIO_PULLUP, PIO_OUTPUT},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Configure the spi0 pins */
+	pio_configure(spi0_pins);
+	writel((1 << AT91C_ID_PIOA), (PMC_PCER + AT91C_BASE_PMC));
+
+	/* Enable the spi0 clock */
+	writel((1 << AT91C_ID_SPI0), (PMC_PCER + AT91C_BASE_PMC));
+}
+#endif /* CONFIG_DATAFLASH */
+
+#ifdef CONFIG_SDCARD
+void at91_mci0_hw_init(void)
+{
+	/* Note: For at91sam9263ek, using MCI1 instead of MCI0 as SD Card booting */
+	/* Configure the MCI1 pins */
+	const struct pio_desc mci_pins[] = {
+		{"MCI1_CK",	AT91C_PIN_PA(6), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCI1_CDA",	AT91C_PIN_PA(7), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCI1_DA0",	AT91C_PIN_PA(8), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCI1_DA1",	AT91C_PIN_PA(9), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCI1_DA2",	AT91C_PIN_PA(10), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{"MCI1_DA3",	AT91C_PIN_PA(11), 0, PIO_PULLUP, PIO_PERIPH_A},
+		{(char *)0, 0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+
+	};
+
+	pio_configure(mci_pins);
+	writel((1 << AT91C_ID_PIOA), (PMC_PCER + AT91C_BASE_PMC));
+
+	/* Enable the clock */
+	writel((1 << AT91C_ID_MCI1), (PMC_PCER + AT91C_BASE_PMC));
+}
+#endif /* #ifdef CONFIG_SDCARD */
+
+#ifdef CONFIG_NANDFLASH
+void nandflash_hw_init(void)
+{
+	unsigned int reg;
+
+	/* Configure NANDFlash pins*/
+	const struct pio_desc nand_pins[] = {
+		{"NANDCS",	CONFIG_SYS_NAND_ENABLE_PIN,	1, PIO_PULLUP, PIO_OUTPUT},
+		{(char *)0, 	0, 0, PIO_DEFAULT, PIO_PERIPH_A},
+	};
+
+	/* Setup Smart Media, first enable the address range of CS3 in HMATRIX user interface  */
+	reg = readl(AT91C_BASE_CCFG + CCFG_EBI0CSA);
+	reg |= AT91C_EBI_CS3A_SM;
+	writel(reg, AT91C_BASE_CCFG + CCFG_EBI0CSA);
+
+	/* Configure SMC CS3 */
+	writel((AT91C_SMC_NWESETUP_(1)
+		| AT91C_SMC_NCS_WRSETUP_(1)
+		| AT91C_SMC_NRDSETUP_(1)
+		| AT91C_SMC_NCS_RDSETUP_(1)),
+		AT91C_BASE_SMC0 + SMC_SETUP3);
+
+	writel((AT91C_SMC_NWEPULSE_(3)
+		| AT91C_SMC_NCS_WRPULSE_(3)
+		| AT91C_SMC_NRDPULSE_(3)
+		| AT91C_SMC_NCS_RDPULSE_(3)),
+		AT91C_BASE_SMC0 + SMC_PULSE3);
+
+	writel((AT91C_SMC_NWECYCLE_(5)
+		|  AT91C_SMC_NRDCYCLE_(5)),
+		AT91C_BASE_SMC0 + SMC_CYCLE3);
+
+	writel((AT91C_SMC_READMODE
+		| AT91C_SMC_WRITEMODE
+		| AT91C_SMC_NWAITM_NWAIT_DISABLE
+		| AT91C_SMC_DBW_WIDTH_BITS_16
+		| AT91_SMC_TDF_(2)),
+		AT91C_BASE_SMC0 + SMC_CTRL3);
+
+	/* Configure the NANDFlash pins */
+	pio_configure(nand_pins);
+	writel((1 << AT91C_ID_PIOCDE), PMC_PCER + AT91C_BASE_PMC);
+}
+
+void nandflash_config_buswidth(unsigned char busw)
+{
+	unsigned long csa;
+
+	csa = readl(AT91C_BASE_SMC0 + SMC_CTRL3);
+
+	if (busw == 0)
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_8;
+	else
+		csa |= AT91C_SMC_DBW_WIDTH_BITS_16;
+
+	writel(csa, AT91C_BASE_SMC0 + SMC_CTRL3);
+}
+#endif /* #ifdef CONFIG_NANDFLASH */
+
+#ifdef CONFIG_FLASH
+void norflash_hw_init(void)
+{
+	/*  Turn on clock for BMS pin */
+	writel((1 << AT91C_ID_PIOB), (PMC_PCER + AT91C_BASE_PMC));
+}
+#endif
diff --git a/board/arm9-cpu/arm9-cpu.h b/board/arm9-cpu/arm9-cpu.h
new file mode 100644
index 0000000..cf8dad4
--- /dev/null
+++ b/board/arm9-cpu/arm9-cpu.h
@@ -0,0 +1,172 @@
+/* ----------------------------------------------------------------------------
+ *         ATMEL Microcontroller Software Support
+ * ----------------------------------------------------------------------------
+ * Copyright (c) 2006, Atmel Corporation
+
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the disclaimer below.
+ *
+ * Atmel's name may not be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __ARM9_CPU_H__
+#define __ARM9_CPU_H__
+
+/*
+ * PMC Settings
+ *
+ * The main oscillator is enabled as soon as possible in the c_startup
+ * and MCK is switched on the main oscillator.
+ * PLL initialization is done later in the hw_init() function
+ */
+#if defined(CONFIG_CPU_CLK_200MHZ)
+
+#if     defined(CONFIG_CRYSTAL_16_000MHZ)
+#define MASTER_CLOCK            (200000000/2)
+#define PLL_LOCK_TIMEOUT        1000000   
+#define PLLA_SETTINGS           0x2031B004
+#define PLLB_SETTINGS           0x10053001
+#endif
+
+#if defined(CONFIG_CRYSTAL_16_36766MHZ)
+#define MASTER_CLOCK		(199919000/2)
+#define PLL_LOCK_TIMEOUT	1000000
+#define PLLA_SETTINGS		0x20AABF0E
+#define PLLB_SETTINGS		0x10483F0E
+#endif /* #if defined(CONFIG_CRYSTAL_16_36766MHZ) */
+
+#if defined(CONFIG_CRYSTAL_18_432MHZ)
+#define MASTER_CLOCK		(198656000/2)
+#define PLL_LOCK_TIMEOUT	1000000
+#define PLLA_SETTINGS		0x2060BF09
+#define PLLB_SETTINGS		0x10483F0E
+#endif /* #if defined(CONFIG_CRYSTAL_18_432MHZ) */
+#endif /* #if defined(CONFIG_CPU_CLK_200MHZ) */
+
+#if defined(CONFIG_CPU_CLK_240MHZ)
+#if     defined(CONFIG_CRYSTAL_16_000MHZ)
+#define MASTER_CLOCK            (240000000/2)
+#define PLL_LOCK_TIMEOUT        1000000
+#define PLLA_SETTINGS           0x203BB004
+#define PLLB_SETTINGS           0x10053001
+#endif
+
+#if defined(CONFIG_CRYSTAL_16_36766MHZ)
+#error "240 MHz not supported for a 16.36766 MHz crystal (Only 200 MHz)"
+#endif
+
+#if defined(CONFIG_CRYSTAL_18_432MHZ)
+#define MASTER_CLOCK		(240000000/2)
+#define PLL_LOCK_TIMEOUT	1000000
+#define PLLA_SETTINGS		0x2271BF30
+#define PLLB_SETTINGS		0x10483F0E
+#endif /* #if defined(CONFIG_CRYSTAL_18_432MHZ) */
+#endif /* #if defined(CONFIG_CPU_CLK_240MHZ) */
+
+
+
+/* Switch MCK on PLLA output PCK = PLLA = 2 * MCK */
+#define MCKR_SETTINGS		(AT91C_PMC_PRES_CLK | AT91C_PMC_MDIV_2)
+#define MCKR_CSS_SETTINGS	(AT91C_PMC_CSS_PLLA_CLK | MCKR_SETTINGS)
+/**
+ * @author: Søren Andersen <san@rosetechnology.dk>
+ */
+#define PLLA_SETTINGS_240       0x203BB004
+#define PLLB_SETTINGS_240       0x10053001
+#define MASTER_CLOCK_240	(240000000/2)
+/*
+ * SDRAM Controller
+ */
+#define AT91C_BASE_SDRAMC	AT91C_BASE_SDRAMC0
+
+/*
+* DataFlash Settings
+*/
+#define CONFIG_SYS_SPI_CLOCK	AT91C_SPI_CLK
+#define CONFIG_SYS_SPI_BUS	0
+#define CONFIG_SYS_SPI_MODE	SPI_MODE0
+
+#if CONFIG_SYS_SPI_BUS == 0
+#define CONFIG_SYS_BASE_SPI	AT91C_BASE_SPI0
+#elif CONFIG_SYS_SPI_BUS == 1
+#define CONFIG_SYS_BASE_SPI	AT91C_BASE_SPI1
+#endif
+
+#if (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS0_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	0
+#define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(5)
+#elif (AT91C_SPI_PCS_DATAFLASH == AT91C_SPI_PCS1_DATAFLASH)
+#define CONFIG_SYS_SPI_CS	1
+#define CONFIG_SYS_SPI_PCS	AT91C_PIN_PA(3)
+#endif
+
+/*
+ * NandFlash Settings
+ */
+#define CONFIG_SYS_NAND_BASE		AT91C_BASE_EBI0_CS3
+#define CONFIG_SYS_NAND_MASK_ALE	(1 << 21)
+#define CONFIG_SYS_NAND_MASK_CLE	(1 << 22)
+
+#define CONFIG_SYS_NAND_ENABLE_PIN	AT91C_PIN_PD(15)
+
+/**
+ * NorFlash Settings
+ */
+#define AT91C_EBI_CS0			0x10000000
+#define AT91_NORFLASH_BASE      	AT91C_EBI_CS0
+#define I_CACHE         		(1<<12)
+/*
+ * MCI Settings
+ */
+#define CONFIG_SYS_BASE_MCI		AT91C_BASE_MCI1
+
+/*
+ * Recovery Button
+ */
+#define CONFIG_SYS_RECOVERY_BUTTON_PIN	AT91C_PIN_PC(4)
+#define RECOVERY_BUTTON_NAME	"BP2"
+
+/*
+ * BMS PIN
+ */
+#define CONFIG_SYS_BMS_PIN		AT91C_PIN_PB(3)
+
+/*
+ * SDCARD CARD DETECT
+ */
+#define CONFIG_SYS_SD_CD_PIN	AT91C_PIN_PE(18)
+
+/*
+ * LEDS
+ */
+#define SKOV_LED1			AT91C_PIN_PD(0)
+#define SKOV_LED2			AT91C_PIN_PD(1)
+#define SKOV_LED3			AT91C_PIN_PD(7)
+/* export function */
+extern void hw_init(void);
+
+extern void norflash_hw_init(void);
+extern void nandflash_hw_init(void);
+extern void nandflash_config_buswidth(unsigned char busw);
+
+extern void at91_spi0_hw_init(void);
+
+extern void at91_mci0_hw_init(void);
+
+#endif /* #ifndef __ARM9_CPU_H__ */
diff --git a/board/arm9-cpu/board.mk b/board/arm9-cpu/board.mk
new file mode 100644
index 0000000..7cd61eb
--- /dev/null
+++ b/board/arm9-cpu/board.mk
@@ -0,0 +1,8 @@
+CPPFLAGS += \
+	-DCONFIG_ARM9_CPU \
+	-mcpu=arm926ej-s
+
+ASFLAGS += \
+	-DCONFIG_ARM9_CPU \
+	-mcpu=arm926ej-s
+
diff --git a/crt0_gnu.S b/crt0_gnu.S
index 87b5ea0..d258ca7 100644
--- a/crt0_gnu.S
+++ b/crt0_gnu.S
@@ -49,7 +49,7 @@ _exception_vectors:
 	b 	swi_vector   	/* Software Interrupt */
 	b 	pabt_vector  	/* Prefetch Abort */
 	b 	dabt_vector  	/* Data Abort */
-.word		_edata		/* Size of the binary for ROMCode loading */
+.word		0x6000		/* Size of the binary for ROMCode loading */
 	b 	irq_vector	/* IRQ : read the AIC */
 	b 	fiq_vector      /* FIQ */
 
@@ -74,81 +74,68 @@ _init_stack:
 	ldr     sp,=TOP_OF_MEMORY
 
 #ifdef CONFIG_FLASH
+	/* First: enable icache and dcache, otherwise we are too slow */
+        mrc     p15, 0, r0, c1, c0, 0 
+        orr     r0, r0, #0x1000
+        orr     r0, r0, #0x0004
+        mcr     p15, 0, r0, c1, c0, 0	
 /*
  * When running from NOR, we must relocate to SRAM prior to resetting
  * the clocks and SMC timings.
  */
 _relocate_to_sram:
+/* relocation is skipped. */
+/* Par. NOR user XIP, ser.flash + SD uses remapped SRAM. */
 
-#if 0
-	/* relocation is slow, disable the watchdog or it will trigger */
-	ldr	r1, =0xFFFFFD44
-	mov	r2, #0x00008000
-	str	r2, [r1]
-#endif
-
-	mov	r1, #0
-	ldr	r3, =_stext
-	ldr	r4, =_edata
-1:
-	cmp     r3, r4
-	ldrcc   r2, [r1], #4
-	strcc   r2, [r3], #4
-	bcc     1b
-	ldr	pc, =_setup_clocks
+_setup_clocks:
+#ifdef CONFIG_ARM9_CPU
+#ifdef CONFIG_CPU_CLK_200MHZ 
+_setup_norflash:
+/**
+ * @author Søren Andersen
+ * Set Mode: 
+ * Set to 16Bit bus width, enable read and write
+ * Enable pagemode, 32 byte pages
+ *
+ */ 
+       ldr     r0,=0xFFFFE40C //AT91C_SMC0_CTRL0
+//       ldr     r1,=0x31111103 //San Rose this dont work at the 29GL512P flash
+	ldr     r1,=0x00111103		
+       str     r1, [r0]
+/**
+ * @autor Søren Andersen
+ * Set cycle long enougth:
+ * at least 12 Cycles->120ns plus a little extra 
+ */   
+        ldr     r0,=0xFFFFE408 //AT91C_SMC0_CYCLE0
+        ldr     r1,=0x000D000D
+        str     r1, [r0]
+
+/**
+ * @author Søren Andersen
+ * Set pulse long enougth:
+ * Pulse should be a bit shorter than the cycle
+ */ 
+        ldr     r0,=0xFFFFE404 //AT91C_SMC0_PULSE0
+        ldr     r1,=0x0C0A0C0A
+        str     r1, [r0]
+  
+/**
+ * @author Søren Andersen
+ * SMC setup:
+ * Setup time is 2 cycles after the CS signal
+ */
+        ldr     r0,=0xFFFFE400 //AT91C_SMC0_SETUP0
+        ldr     r1,=0x00020002
+        str     r1, [r0] 
+#endif /* CONFIG_CPU_CLK_200MHZ */
+#endif /* CONFIG_ARM9_CPU */
 #endif /* CONFIG_FLASH */
 
 	ldr     r4, = lowlevel_clock_init
 	mov     lr, pc
 	bx      r4
 
-#if 0
-_setup_clocks:
-/* Test if main oscillator is enabled */
-	ldr 	r0,=AT91C_PMC_SR
-	ldr 	r1, [r0]
-	ldr 	r2,=AT91C_PMC_MOSCS
-	ands 	r1, r1, r2
-	bne     _switch_to_mosc
-
-
-/* Enable the main oscillator */
-_enable_mosc:
-	ldr 	r0,=AT91C_PMC_MOR
-	mov 	r1, #(0x40 << 8)
-	ldr 	r2,=AT91C_CKGR_MOSCEN
-	orr 	r1, r1, r2
-	str	r1, [r0]
-	ldr 	r0,=AT91C_PMC_SR
-1:
-	ldr 	r1, [r0]
-	ldr 	r2,=AT91C_PMC_MOSCS
-	ands 	r1, r1, r2
-	beq     1b
-	
-/* Test if MCK == SLOW CLOCK */
-_switch_to_mosc:
-	ldr 	r0,=AT91C_PMC_MCKR
-	ldr 	r1,=AT91C_PMC_CSS
-	ldr 	r2, [r0]
-	and 	r2, r2, r1
-	mov	r1, #0
-	cmp    	r1, r2
-/* No => Do nothing */
-	bne	_init_data
-/* Yes => Switch to the main oscillator */
-	ldr 	r1,=AT91C_PMC_CSS_MAIN_CLK
-	ldr 	r2,=AT91C_PMC_PRES_CLK
-	orr	r1, r1, r2
-	str 	r1, [r0]
-	ldr 	r0,=AT91C_PMC_SR
-1:
-	ldr     r1, [r0]
-	ldr	r2,=AT91C_PMC_MCKRDY
-	ands    r1, r1, r2
-	beq     1b
-#endif
-
 /* Copy the data section in RAM at .data link address */
 _init_data:
         ldr      r2, =_lp_data
diff --git a/driver/flash.c b/driver/flash.c
index 11615c7..3b48bbf 100644
--- a/driver/flash.c
+++ b/driver/flash.c
@@ -23,18 +23,31 @@
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
-#include "../include/part.h"
-#include "../include/main.h"
-#include "../include/flash.h"
-#include <stdlib.h>
+#include "board.h"
+#include "arch/at91_pio.h"
+#include "gpio.h"
+#include "string.h"
+#include "common.h"
+#include "debug.h"
 
-
-int load_norflash(unsigned int img_addr,
-		unsigned int img_size,
-		unsigned int img_dest)
+int load_norflash(struct image_info *img_info)
 {
-    norflash_hw_init();
+        unsigned int offset = img_info->offset;
+        unsigned int size = img_info->length;
+        unsigned char *dest = img_info->dest;
+
+
+        norflash_hw_init();
+        /**
+         * It should only be possible to load data from Nor flash if BMS pin = 0
+         */
+
+        if ((pio_get_value(CONFIG_SYS_BMS_PIN)) == 0) {
+            memcpy(dest, (char *)(AT91_NORFLASH_BASE + offset), size);
+            return 0;
+        } else {
+            return -3;
+        }    
+        
 
-    memcpy((char *)img_dest, (char *)(AT91_NORFLASH_BASE + img_addr), img_size);
-    return 0;
-}
+}	
diff --git a/driver/nandflash.c b/driver/nandflash.c
index 3054408..8dc3715 100644
--- a/driver/nandflash.c
+++ b/driver/nandflash.c
@@ -352,7 +352,7 @@ static int nandflash_detect_onfi(struct nand_chip *chip)
 	return 0;
 }
 
-static int nandflash_detect_non_onfi(struct nand_chip *chip)
+int nandflash_detect_non_onfi(struct nand_chip *chip)
 {
 	int manf_id, dev_id, cellinfo, extid, tmp_manf, tmp_dev;
 	struct nandflash_dev *type;
@@ -408,7 +408,7 @@ static int nandflash_detect_non_onfi(struct nand_chip *chip)
 		return -1;
 	}
 	
-	dbg_log(1, "NAND device: %s, Manufacturer ID: %d Chip ID: %d\n\r",
+	dbg_log(3, "NAND device: %s, Manufacturer ID: %d Chip ID: %d\n\r",
 			type->name, manf_id, dev_id);
 
 	/* Newer devices have all the information in additional id bytes */
diff --git a/driver/pmc.c b/driver/pmc.c
index aa358b1..c16d74d 100644
--- a/driver/pmc.c
+++ b/driver/pmc.c
@@ -80,17 +80,22 @@ void lowlevel_clock_init()
 	}
 	
 	/* After stablization, switch to Main Oscillator */
-	if ((read_pmc(PMC_MCKR) & AT91C_PMC_CSS) == AT91C_PMC_CSS_SLOW_CLK) {
+//	if ((read_pmc(PMC_MCKR) & AT91C_PMC_CSS) == AT91C_PMC_CSS_SLOW_CLK) {
+//  PMC register changed. This line fites at91sam9263 cpu:
+	if ((read_pmc(PMC_MCKR) & 3) != 2) {
 		unsigned long tmp;
 
 		tmp = read_pmc(PMC_MCKR);
-		tmp &= ~AT91C_PMC_CSS;
+//		tmp &= ~AT91C_PMC_CSS;
+		tmp &= ~0x03;
 		tmp |= AT91C_PMC_CSS_MAIN_CLK;
 		write_pmc(PMC_MCKR, tmp);
 		while (!(read_pmc(PMC_SR) & AT91C_PMC_MCKRDY)) ;
 
-		tmp &= ~AT91C_PMC_PRES;
-		tmp |= AT91C_PMC_PRES_CLK;
+//		tmp &= ~AT91C_PMC_PRES;
+		tmp &= ~0x1c;
+//		tmp |= AT91C_PMC_PRES_CLK;
+		tmp |= 0;
 		write_pmc(PMC_MCKR, tmp);
 		while (!(read_pmc(PMC_SR) & AT91C_PMC_MCKRDY)) ;
 	}
diff --git a/driver/serial_flash.c b/driver/serial_flash.c
index 30fb9c5..669b281 100644
--- a/driver/serial_flash.c
+++ b/driver/serial_flash.c
@@ -292,10 +292,10 @@ static int sf_cmd_read_id(unsigned char *idcode, unsigned int idcode_len)
 	unsigned int i;
 	unsigned char *p = idcode;
 
-	dbg_log(1, "SF: Got idcodes:");
+	dbg_log(3, "SF: Got idcodes:");
 	for (i = 0; i < idcode_len; i++)
-		dbg_log(1, "%d ", *p++);
-	dbg_log(1, "\n\r");
+		dbg_log(3, "%d ", *p++);
+	dbg_log(3, "\n\r");
 #endif
 	return 0;
 }
@@ -309,7 +309,7 @@ static int sf_cmd_read_status_at45(unsigned char *page_256)
 	if (ret)
 		return -1;
 
-	dbg_log(1, "SF: AT45 status register: %d\n\r", status);
+	dbg_log(3, "SF: AT45 status register: %d\n\r", status);
 
 	if ((status & AT45_STATUS_P2_PAGE_SIZE))
 		*page_256 = 1;
@@ -394,7 +394,7 @@ static int dataflash_erase_p2(unsigned int offset, unsigned int len)
 		offset += page_size;
 	}
 
-	dbg_log(1, "SF: AT45: Successfully erased %d bytes @ %d\n\r", len, offset);
+	dbg_log(3, "SF: AT45: Successfully erased %d bytes @ %d\n\r", len, offset);
 
 	return 0;
 }
@@ -785,7 +785,7 @@ int load_dataflash(struct image_info *img_info)
 		return -2;
 #endif
 
-	dbg_log(1, "SF: Copy %d bytes from %d to %d\n\r", size, offset, dest);
+	dbg_log(3, "SF: Copy %d bytes from %d to %d\n\r", size, offset, dest);
 
 	ret = (*sf_read)(offset, size, dest);
 	if (ret) {
diff --git a/include/board.h b/include/board.h
index ce75aa1..98b0c42 100644
--- a/include/board.h
+++ b/include/board.h
@@ -72,4 +72,8 @@
 #include "at91sama5d3xek.h"
 #endif
 
+#ifdef CONFIG_ARM9_CPU
+#include "arm9-cpu.h"
+#endif
+
 #endif /* #ifndef __BOARD_H__ */
diff --git a/include/flash.h b/include/flash.h
index d9e5dc4..82ab3c8 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -44,7 +44,6 @@
 
 void norflash_hw_init(void);
 
-int load_norflash(unsigned int img_addr, unsigned int img_size,
-                  unsigned int img_dest);
+int load_norflash(struct image_info *img_info);
 
 #endif	/* #ifndef __NORFLASH_H__ */
diff --git a/include/nandflash.h b/include/nandflash.h
index 2a16f95..c607e67 100644
--- a/include/nandflash.h
+++ b/include/nandflash.h
@@ -28,6 +28,13 @@
 #ifndef __NANDFLASH_H__
 #define __NANDFLASH_H__
 
+#include "nand.h"
 extern int load_nandflash(struct image_info *img_info);
+/**
+ * @author Søren Andersen <san@rosetechnology.dk>
+ * Find out if we have a nand flash From arm9-cpu.c
+ */
+extern int nandflash_detect_non_onfi(struct nand_info *nand);
+   
 
 #endif /* #ifndef __NANDFLASH_H__ */
diff --git a/main.c b/main.c
index d69de79..f5bfc55 100644
--- a/main.c
+++ b/main.c
@@ -34,6 +34,8 @@
 #include "nandflash.h"
 #include "sdcard.h"
 #include "flash.h"
+#include "arch/at91_pio.h"
+#include "gpio.h"
 
 extern int load_kernel(struct image_info *img_info);
 
@@ -46,22 +48,18 @@ static int init_loadfunction(void)
 #if defined(CONFIG_LOAD_LINUX)
 	load_image = &load_kernel;
 #else
-#if defined (CONFIG_DATAFLASH)
-	load_image = &load_dataflash;
-#elif defined(CONFIG_NANDFLASH)
-	load_image = &load_nandflash;
-#elif defined(CONFIG_SDCARD)
-	load_image = &load_sdcard;
-#else
+/*
 #error "No booting media specified!"
 #endif
+*/
 #endif
 	return 0;
 }
 
 static void display_banner (void)
 {
-	dbg_log(1, "\n\nAT91Bootstrap %s\n\n\r",
+	dbg_log(1, "\n\r");
+	dbg_log(1, "AT91Bootstrap %s\n\n\r",
 			AT91BOOTSTRAP_VERSION" ( "COMPILE_TIME" )");
 }
 
@@ -71,7 +69,11 @@ int main(void)
 	int ret;
 
 	image_info.dest = (unsigned char *)JUMP_ADDR;
-#if defined (CONFIG_DATAFLASH) || defined(CONFIG_NANDFLASH)
+/**
+ * @author Søren Andersen <san@rosetechnology.dk>
+ */
+        
+#if defined (CONFIG_DATAFLASH) || defined(CONFIG_NANDFLASH) || defined(CONFIG_FLASH) 
 	image_info.offset = IMG_ADDRESS;
 	image_info.length = IMG_SIZE;
 #endif
@@ -88,19 +90,45 @@ int main(void)
 	init_loadfunction();
 
 	dbg_log(1, "Downloading image...\n\r");
+#if defined(CONFIG_FLASH)
+        load_image = &load_norflash;
+        ret = (*load_image)(&image_info);
+        if (ret == 0){
+                dbg_log(1, "Jump to NOR flash!\n\r");
+                return JUMP_ADDR;
+        }
+        if (ret == -1) {
+                dbg_log(1, "Failed to load NOR flash image\n\r");
+        }
+#endif
 
-	ret = (*load_image)(&image_info);
-	if (ret == 0){
-		dbg_log(1, "Done!\n\r");
-	}
-	if (ret == -1) {
-		dbg_log(1, "Failed to load image\n\r");
-		while(1);
+#if defined(CONFIG_SDCARD)	
+		/* Only boot SD if "card detect" is low */
+        if (pio_get_value(CONFIG_SYS_SD_CD_PIN) == 0) {
+            load_image = &load_sdcard;
+    	    ret = (*load_image)(&image_info);
+    	    if (ret == 0){
+	                dbg_log(1, "Jump to SD-Card!\n\r");
+    	            return JUMP_ADDR;
+    	    }
+    	    if (ret == -1) {
+    	            dbg_log(1, "Failed to load SD-Card image\n\r");
+    	    }
 	}
-	if (ret == -2) {
-		dbg_log(1, "Success to recovery\n\r");
-		while (1);
+#endif
+
+
+#if defined(CONFIG_DATAFLASH)
+        load_image = &load_dataflash;
+        ret = (*load_image)(&image_info);
+        if (ret == 0){
+		dbg_log(1, "Jump to Dataflash!\n\r");
+                return JUMP_ADDR;
 	}
+        if (ret == -1) {
+                dbg_log(1, "Failed to load Dataflash image\n\r");
+        }
+#endif
 
 #ifdef CONFIG_SCLK
 	slowclk_switch_osc32();
diff --git a/toplevel_cpp.mk b/toplevel_cpp.mk
index f5e3477..9c7e98f 100644
--- a/toplevel_cpp.mk
+++ b/toplevel_cpp.mk
@@ -29,3 +29,10 @@ ifeq ($(CONFIG_USER_HW_INIT),y)
 CPPFLAGS += -DCONFIG_USER_HW_INIT
 endif
 
+ifeq ($(CONFIG_FLASH),y)
+ASFLAGS += -DCONFIG_FLASH
+endif
+
+ifeq ($(CONFIG_CPU_CLK_200MHZ),y)
+ASFLAGS += -DCONFIG_CPU_CLK_200MHZ
+endif
-- 
1.8.3.1

