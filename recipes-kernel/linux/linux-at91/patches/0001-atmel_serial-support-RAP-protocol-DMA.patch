From 344f2475120ebc0c3a230d9f6fc26cdd6247e646 Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Sun, 1 Jan 2017 10:14:56 +0100
Subject: [PATCH] atmel_serial: support RAP protocol + DMA

Implement carrier sense
- Use hrtimers to have enough precision
Implement use of DMA to speed up serial driver
---
 arch/arm/include/asm/ioctls.h     |  12 ++
 drivers/tty/serial/atmel_serial.c | 400 ++++++++++++++++++++++++++++++++++++--
 drivers/tty/serial/serial_core.c  |   9 +
 include/linux/serial_core.h       |  11 ++
 4 files changed, 421 insertions(+), 11 deletions(-)

diff --git a/arch/arm/include/asm/ioctls.h b/arch/arm/include/asm/ioctls.h
index 9c96298..02a2bb2 100644
--- a/arch/arm/include/asm/ioctls.h
+++ b/arch/arm/include/asm/ioctls.h
@@ -5,4 +5,16 @@
 
 #include <asm-generic/ioctls.h>
 
+/* Rose Skov Ioctls */
+/* Mab Rose Technology */
+#define TIOCSERSCSMA    0x54AF  /* Set serial port to Carrier Sense Multiple Access */
+#define TIOCSERCSMASST  0x54B0  /* Set time out for carrier sense */
+
+/* San Rose Technology */
+#define TIOS505         0x54B1  /* Set the keyboard driver to work with 505 keyboard */
+
+/* San Rose Technology */
+#define TIOCSAT91RS232  0x54B2   /* Set the serial port in RS232 mode */
+/* End Rose Skov Ioctls */
+
 #endif
diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c
index 9645186..f8958b2 100644
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -51,6 +51,25 @@
 #include <asm/gpio.h>
 #endif
 
+/*MAB Rose add RAP */
+#include <linux/clocksource.h>
+#include <linux/atmel_tc.h>
+#include <linux/wait.h>
+/**
+ * @author: Søren Andersen
+ * Add hrtimer.
+ * We use ms tick.
+ */
+#include <linux/timer.h>
+#include <linux/ktime.h>
+#include <linux/hrtimer.h>
+#define MS_TO_NS(x)     (x * 1E6L)
+/**
+ * Find CPU Speed
+ */
+#include <linux/delay.h>
+/* End Rose */
+
 #define PDC_BUFFER_SIZE		512
 /* Revisit: We should calculate this based on the actual port settings */
 #define PDC_RX_TIMEOUT		(3 * 10)		/* 3 bytes */
@@ -107,6 +126,9 @@ static void atmel_stop_rx(struct uart_port *port);
 #define UART_PUT_RPR(port,v)	__raw_writel(v, (port)->membase + ATMEL_PDC_RPR)
 #define UART_GET_RPR(port)	__raw_readl((port)->membase + ATMEL_PDC_RPR)
 #define UART_PUT_RCR(port,v)	__raw_writel(v, (port)->membase + ATMEL_PDC_RCR)
+/* Rose technology */
+#define UART_GET_RCR(port)      __raw_readl((port)->membase + ATMEL_PDC_RCR)
+/* End Rose */
 #define UART_PUT_RNPR(port,v)	__raw_writel(v, (port)->membase + ATMEL_PDC_RNPR)
 #define UART_PUT_RNCR(port,v)	__raw_writel(v, (port)->membase + ATMEL_PDC_RNCR)
 
@@ -153,7 +175,15 @@ struct atmel_uart_port {
 	unsigned int		irq_status_prev;
 
 	struct circ_buf		rx_ring;
-
+/* ROSE: RAP protocol */
+	unsigned int            carrier_timeout;        /* Timeout in clock ticks between two packages on the bus */
+	unsigned short          last_activity_counter;  /* Counter value at the time of last activity on the bus */
+	signed  short           counter_overflow;       /* Number of counter overflows since last activity */
+	unsigned short          clocked;                /* is the port clocked? */
+	unsigned short          pdc_rx_count;           /* Bytes left in a pdc receive, used to check for line activity */
+	unsigned int            current_baud;           /* store the givem ports baurate */
+	unsigned char           last_activity_is_tx;    /* Is the last activity on the port a send char */
+/* End Rose */
 	struct serial_rs485	rs485;		/* rs485 settings */
 	unsigned int		tx_done_mask;
 };
@@ -161,6 +191,59 @@ struct atmel_uart_port {
 static struct atmel_uart_port atmel_ports[ATMEL_MAX_UART];
 static DECLARE_BITMAP(atmel_ports_in_use, ATMEL_MAX_UART);
 
+/*
+ * Mab Rose Technology
+ * Clocksource needed to initialise timer/counter for csma
+ * tcaddr will be initialised to point to the timer/counter register
+ */
+
+static struct clocksource clksrc = {
+        .name           = "tcb_clksrc",
+        .rating         = 200,
+        .read           = NULL,
+        .mask           = CLOCKSOURCE_MASK(32),
+        .shift          = 18,
+        .flags          = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+static void __iomem *tcaddr;
+
+/* End Mab */
+
+/**
+ * @author Søren Andersen
+ * Use the hr timer timeout for reading and verify
+ * if new chars had arrived in the pdc
+ */
+//struct console *port_console; /* Need to bring the console port data to the hr-timer function */
+short console_index = 0;
+static void atmel_rx_from_dma(struct uart_port *port);
+#define DBUG_PDC_POLL_INTERVAL_NS       100*1E6L                /* 100ms seems to work well */
+int tc_enabled = 0; /* Variable is uset for switching on the csma timer */
+
+static struct at91_dbgu_timer_data {
+        struct hrtimer          timer;
+        ktime_t                 period;
+        ktime_t                 entry_time;
+        int                     sttto;
+        s64                     blocked_time;
+} *hr_data;
+
+static enum hrtimer_restart at91_dbgu_timer (struct hrtimer *var)
+{
+        ktime_t now = var->base->get_time();
+        struct uart_port *port = &atmel_ports[console_index].uart;
+        struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+
+        if (atmel_port->pdc_rx_count != UART_GET_RCR(port)) {
+                atmel_port->pdc_rx_count = UART_GET_RCR(port);
+                tasklet_schedule(&atmel_port->tasklet);
+                //atmel_rx_from_dma(port);
+        }
+        hrtimer_forward(var, now, hr_data->period);
+        return HRTIMER_RESTART;
+}
+/* End San*/
+
 #ifdef SUPPORT_SYSRQ
 static struct console atmel_console;
 #endif
@@ -228,7 +311,7 @@ void atmel_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)
 
 	if (rs485conf->flags & SER_RS485_ENABLED) {
 		dev_dbg(port->dev, "Setting UART to RS485\n");
-		atmel_port->tx_done_mask = ATMEL_US_TXEMPTY;
+		atmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;
 		UART_PUT_TTGR(port, rs485conf->delay_rts_after_send);
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
@@ -337,6 +420,172 @@ static u_int atmel_get_mctrl(struct uart_port *port)
 }
 
 /*
+ * Mab Rose Technology
+ * Calculates and sets the value for carrier sense interrupt
+ */
+static void set_carrier_interrupt(void)
+{
+        unsigned short interrupt_value, counter_value;
+        unsigned int i;
+        struct uart_port *port;
+        struct atmel_uart_port *atmel_port;
+        struct tty_struct *tty;
+
+        counter_value = __raw_readl(tcaddr + ATMEL_TC_REG(0, CV));
+        interrupt_value = counter_value - 1;
+        // We don't take into consideration the overflow, as that is checked in the interrupt routine
+        for(i = 0; i < ATMEL_MAX_UART; i++) {
+                atmel_port = &atmel_ports[i];
+                if(atmel_port->uart.state != NULL && atmel_port->clocked)
+                {
+                        port = &atmel_port->uart;
+                        tty = atmel_port->uart.state->port.tty;
+                        if(port->csma && tty->driver->ops->chars_in_buffer(tty) ) {
+                                //Save the interrupt point for the timer whose interrupt comes next
+                                if( (unsigned short)(interrupt_value - counter_value) >
+                                    (unsigned short)(atmel_port->last_activity_counter + atmel_port->carrier_timeout - counter_value)) {
+                                        interrupt_value = atmel_port->last_activity_counter + atmel_port->carrier_timeout;
+                                }
+                        }
+                }
+        }
+        __raw_writel(interrupt_value, tcaddr + ATMEL_TC_REG(0, RC));
+}
+
+/*
+ * Mab Rose Technology
+ * Update last activity on port, and update the interrupt time
+ */
+static void activity_detected(struct uart_port *port, int offset)
+{
+        struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+        unsigned short counter = __raw_readl(tcaddr + ATMEL_TC_REG(0, CV));
+        if((int)counter + offset < 0) {
+                atmel_port->counter_overflow = 1;
+        }
+        else if ((int)counter + offset > 0xFFFF){
+                atmel_port->counter_overflow = -1;
+        }
+        else {
+                atmel_port->counter_overflow = 0;
+        }
+        atmel_port->last_activity_counter = counter +  offset;
+        set_carrier_interrupt();
+}
+
+/*
+ * Mab Rose Technology
+ * Check if line has been silent for required period for next message
+ */
+static int carrier_sensed(struct uart_port *port)
+{
+        struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+        long elapsed_time;
+        long overflow = atmel_port->counter_overflow;
+        overflow = (overflow*0x10000) +  __raw_readl(tcaddr + ATMEL_TC_REG(0, CV));
+
+        /* Check if any chars have been received since last activy on the line */
+        if( atmel_port->pdc_rx_count != UART_GET_RCR(port) ) {
+                atmel_port->pdc_rx_count = UART_GET_RCR(port);
+                activity_detected(port, 0);
+                return 0;
+        }
+        elapsed_time = overflow - atmel_port->last_activity_counter;
+        if (overflow < atmel_port->last_activity_counter)
+        {
+                return 0;
+        }
+        if ( elapsed_time >= atmel_port->carrier_timeout ) {
+                return 1;
+        }
+        return 0;
+}
+
+/*
+ * Mab Rose Technology
+ * Carrier sense interrupt handler
+ */
+static irqreturn_t carrier_sense_interrupt(int irq, void *dev_id)
+{
+        struct atmel_uart_port *atmel_port;
+        struct uart_port *port;
+        struct tty_struct *tty;
+        unsigned int pending;
+        unsigned int i;
+        int ret = IRQ_NONE;
+
+        pending = (__raw_readl(tcaddr + ATMEL_TC_REG(0, IMR)) & __raw_readl(tcaddr + ATMEL_TC_REG(0, SR)));
+        if (pending & ATMEL_TC_CPCS)
+        {
+
+                for(i = 0; i < ATMEL_MAX_UART; i++){
+                        atmel_port = &atmel_ports[i];
+                        if(atmel_port->uart.state != NULL && atmel_port->clocked)
+                        {
+                                tty = atmel_port->uart.state->port.tty;
+                                port = &atmel_port->uart;
+                                if(port->csma && tty->driver->ops->chars_in_buffer(tty) ){
+                                        if(carrier_sensed(port)) {
+                                                UART_PUT_IER(port, atmel_port->tx_done_mask);
+                                                UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);           /* re-enable PDC transmit */
+                                        }
+                                }
+                        }
+                }
+                ret = IRQ_HANDLED;
+        }
+        if (pending & ATMEL_TC_COVFS)
+        {
+                for(i = 0; i < ATMEL_MAX_UART; i++){
+                        atmel_port = &atmel_ports[i];
+                        if (atmel_port->counter_overflow < 20000) {
+                                atmel_port->counter_overflow = atmel_port->counter_overflow + 1;
+                        }
+                }
+                ret = IRQ_HANDLED;
+        }
+        return ret;
+}
+/*
+ * Mab Rose Technology
+ * Enable timer/counter for csma
+ */
+static int atmel_serial_enable_csma_timer(void)
+{
+        struct atmel_tc *tc;
+        int irqret;
+
+        if(tc_enabled == 0){ /* Only start up the first time, comming to this function, ignore the other time atmel_serial_enable_csma_timer is called */
+                tcaddr = ioremap(AT91SAM9263_BASE_TCB0, SZ_16K);
+                tc = atmel_tc_alloc(0, clksrc.name);
+                if (!tc) {
+		        printk("can't alloc TC for atmel_serial\n");
+		        return -ENODEV;
+                }
+                clk_enable(tc->clk[0]); //Start before starting syncronous work
+
+                irqret = request_irq(tc->irq[0], carrier_sense_interrupt,
+                IRQF_DISABLED | IRQF_TIMER, "rs485 carrier sense", NULL);
+                if (irqret){
+                        printk("Carrier sense interrupt error\n");
+                }
+
+                __raw_writel(ATMEL_TC_CLKDIS, tcaddr + ATMEL_TC_REG(0,CCR)); // Disbale tc before setting up, to avoid unwanted interrupts
+                __raw_writel(ATMEL_TC_WAVESEL_UP        // Up counting not automatic reset on compare
+                        | ATMEL_TC_WAVE                 // Counter mode
+                        | ATMEL_TC_TIMER_CLOCK4,        // MCKL / 128 ~ 1.28us pr tick
+                        tcaddr + ATMEL_TC_REG(0, CMR));
+                __raw_writel(0, tcaddr + ATMEL_TC_REG(0, RC)); //Compare register set to 0
+                __raw_writel(0xFF, tcaddr + ATMEL_TC_REG(0, IDR)); //Disable all interrupts
+                __raw_writel(ATMEL_TC_COVFS | ATMEL_TC_CPCS, tcaddr + ATMEL_TC_REG(0, IER)); // Overflow and Compare C interrupts enabled
+                __raw_writel(ATMEL_TC_CLKEN | ATMEL_TC_SWTRG, tcaddr + ATMEL_TC_REG(0,CCR)); // Start Timer/counter
+                tc_enabled = 1;
+        }
+        return 0;
+}
+/* End Mab */
+
+/*
  * Stop transmitting.
  */
 static void atmel_stop_tx(struct uart_port *port)
@@ -361,6 +610,9 @@ static void atmel_stop_tx(struct uart_port *port)
 static void atmel_start_tx(struct uart_port *port)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
+	/* Mab Rose */
+	struct tty_struct *tty = port->state->port.tty;
+	/* End Mab */
 
 	if (atmel_use_dma_tx(port)) {
 		if (UART_GET_PTSR(port) & ATMEL_PDC_TXTEN)
@@ -377,6 +629,16 @@ static void atmel_start_tx(struct uart_port *port)
 	}
 	/* Enable interrupts */
 	UART_PUT_IER(port, atmel_port->tx_done_mask);
+
+	/* Mab Rose Technology
+         * Impelementing waiting, so write does't
+	 * return to userspace before buffer is empty
+	 */
+	if(port->csma){
+	        spin_unlock(&port->lock);
+	        wait_event_interruptible(tty->write_wait, !tty->driver->ops->chars_in_buffer(tty));
+	        spin_lock(&port->lock);
+	}
 }
 
 /*
@@ -565,6 +827,9 @@ static void
 atmel_handle_receive(struct uart_port *port, unsigned int pending)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
+	/* Rose */
+        int offset, delay_x10 = 213, timeout_x10_bits = PDC_RX_TIMEOUT * 10 + 4; // f(x) = 30.42x + 21.31
+        /* End Rose */
 
 	if (atmel_use_dma_rx(port)) {
 		/*
@@ -577,6 +842,21 @@ atmel_handle_receive(struct uart_port *port, unsigned int pending)
 		if (pending & (ATMEL_US_ENDRX | ATMEL_US_TIMEOUT)) {
 			UART_PUT_IDR(port, (ATMEL_US_ENDRX
 						| ATMEL_US_TIMEOUT));
+
+			/* Rose*/
+			if(port->csma) {
+				/* san Rose technology */
+				if( loops_per_jiffy > 530000 ) { /* 240Mhz mode */
+					offset = ( 10*((1000000/atmel_port->current_baud) *  timeout_x10_bits + delay_x10))/107;
+				} else {
+					offset = ( 10*((1000000/atmel_port->current_baud) *  timeout_x10_bits + delay_x10))/128;
+				}
+				offset = -offset;
+				activity_detected(port, offset);
+				atmel_port->pdc_rx_count = UART_GET_RCR(port); // do not trigger activity detect on next transmit attempt
+				atmel_port->last_activity_is_tx = 0;
+			}
+			/* End Rose */
 			tasklet_schedule(&atmel_port->tasklet);
 		}
 
@@ -607,11 +887,32 @@ atmel_handle_transmit(struct uart_port *port, unsigned int pending)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
+	/* Rose Technology */
+	int offset, last2bytesInBit_x100 = 1877, delay_x100 = -6850;
+	if( loops_per_jiffy > 530000 ) { /* 240Mhz mode */
+	        offset = ( (1000000/atmel_port->current_baud) *  last2bytesInBit_x100 + delay_x100 )/107;
+	} else {
+		offset = ( (1000000/atmel_port->current_baud) *  last2bytesInBit_x100 + delay_x100 )/128; // f(x) = 18.77x -68.5
+	}
+	/* End Rose */
+
 	if (pending & atmel_port->tx_done_mask) {
+        /*Mab Rose technology */
+		/* TX detect */
+        if(port->csma) {
+			if (atmel_port->last_activity_is_tx == 1) {
+				activity_detected(port, offset);
+				atmel_port->last_activity_is_tx = 0;
+			} else {
+				atmel_port->last_activity_is_tx = 1;
+			}
+        }
+        /* End Mab */
 		/* Either PDC or interrupt transmission */
 		UART_PUT_IDR(port, atmel_port->tx_done_mask);
 		tasklet_schedule(&atmel_port->tasklet);
 	}
+
 }
 
 /*
@@ -688,10 +989,17 @@ static void atmel_tx_dma(struct uart_port *port)
 
 		UART_PUT_TPR(port, pdc->dma_addr + xmit->tail);
 		UART_PUT_TCR(port, count);
-		/* re-enable PDC transmit */
-		UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);
-		/* Enable interrupts */
-		UART_PUT_IER(port, atmel_port->tx_done_mask);
+
+		/* Mab Rose Technology */
+		if (port->csma && !carrier_sensed(port)) {
+                set_carrier_interrupt();
+        } else {
+			/* re-enable PDC transmit */
+			UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);
+			/* Enable interrupts */
+			UART_PUT_IER(port, atmel_port->tx_done_mask);
+		}
+		/* End Mab */
 	} else {
 		if ((atmel_port->rs485.flags & SER_RS485_ENABLED) &&
 		    !(atmel_port->rs485.flags & SER_RS485_RX_DURING_TX)) {
@@ -855,6 +1163,9 @@ static void atmel_tasklet_func(unsigned long data)
 {
 	struct uart_port *port = (struct uart_port *)data;
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
+	/* Mab Rose Technology */
+	struct tty_struct *tty = port->state->port.tty;
+	/*End Mab */
 	unsigned int status;
 	unsigned int status_change;
 
@@ -866,6 +1177,12 @@ static void atmel_tasklet_func(unsigned long data)
 	else
 		atmel_tx_chars(port);
 
+	/*Mab Rose technology */
+    if(port->csma) {
+        wake_up_all(&tty->write_wait); /* signal empty to anyone waiting in write_wait */
+    }
+	/* End Mab */
+
 	status = atmel_port->irq_status;
 	status_change = status ^ atmel_port->irq_status_prev;
 
@@ -881,7 +1198,7 @@ static void atmel_tasklet_func(unsigned long data)
 		if (status_change & ATMEL_US_CTS)
 			uart_handle_cts_change(port, !(status & ATMEL_US_CTS));
 
-		wake_up_interruptible(&port->state->port.delta_msr_wait);
+		wake_up_interruptible(&port->state->delta_msr_wait);
 
 		atmel_port->irq_status_prev = status;
 	}
@@ -951,6 +1268,10 @@ static int atmel_startup(struct uart_port *port)
 
 		atmel_port->pdc_rx_idx = 0;
 
+		/* Rose Technology */
+		atmel_port->pdc_rx_count = PDC_BUFFER_SIZE;
+		/* End Rose */
+
 		UART_PUT_RPR(port, atmel_port->pdc_rx[0].dma_addr);
 		UART_PUT_RCR(port, PDC_BUFFER_SIZE);
 
@@ -1094,6 +1415,9 @@ static void atmel_serial_pm(struct uart_port *port, unsigned int state,
 		 * This is called on uart_open() or a resume event.
 		 */
 		clk_enable(atmel_port->clk);
+		/* Rose Technology */
+		atmel_port->clocked = 1;
+		/*End Rose */
 
 		/* re-enable interrupts if we disabled some on suspend */
 		UART_PUT_IER(port, atmel_port->backup_imr);
@@ -1103,6 +1427,10 @@ static void atmel_serial_pm(struct uart_port *port, unsigned int state,
 		atmel_port->backup_imr = UART_GET_IMR(port);
 		UART_PUT_IDR(port, -1);
 
+		/* Rose Technology */
+		atmel_port->clocked = 0;
+		/* End Rose */
+
 		/*
 		 * Disable the peripheral clock for this serial port.
 		 * This is called on uart_close() or a suspend event.
@@ -1122,6 +1450,7 @@ static void atmel_set_termios(struct uart_port *port, struct ktermios *termios,
 {
 	unsigned long flags;
 	unsigned int mode, imr, quot, baud;
+
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
 	/* Get current mode register */
@@ -1132,6 +1461,10 @@ static void atmel_set_termios(struct uart_port *port, struct ktermios *termios,
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);
 	quot = uart_get_divisor(port, baud);
 
+	/* San Rose */
+	atmel_port->current_baud = baud;
+	/* End San */
+
 	if (quot > 65535) {	/* BRGR is 16-bit, so switch to slower clock */
 		quot /= 8;
 		mode |= ATMEL_US_USCLKS_MCK_DIV8;
@@ -1367,8 +1700,30 @@ static int
 atmel_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
 {
 	struct serial_rs485 rs485conf;
+	/* Mab Rose */
+        struct atmel_uart_port *atmel_port = (struct atmel_uart_port *) port;
+	/* End Mab */
 
 	switch (cmd) {
+	/* Mab Rose
+	* ioctl for specifiying timeout for csma
+	*/
+	case TIOCSERCSMASST:
+		atmel_port->carrier_timeout = (arg*100)/128;
+		break;
+
+	case TIOCSERSCSMA:
+		if (arg == 1 && port->csma == 0) {
+		        atmel_serial_enable_csma_timer(); /* Start-up the csma timer */
+		        port->csma = 1; // set the port in CSMA mode
+		        atmel_port->carrier_timeout = 1031000/128;
+		        activity_detected(port, 0);
+		}
+		else if (arg == 0 && port->csma == 1) {
+		        port->csma = 0; // set the port in normal operation mode
+		}
+		break;
+	/* End Mab */
 	case TIOCSRS485:
 		if (copy_from_user(&rs485conf, (struct serial_rs485 *) arg,
 					sizeof(rs485conf)))
@@ -1390,8 +1745,6 @@ atmel_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
 	return 0;
 }
 
-
-
 static struct uart_ops atmel_pops = {
 	.tx_empty	= atmel_tx_empty,
 	.set_mctrl	= atmel_set_mctrl,
@@ -1498,9 +1851,14 @@ static void __devinit atmel_init_port(struct atmel_uart_port *atmel_port,
 		/* only enable clock when USART is in use */
 	}
 
+	/* Rose Technology */
+	port->csma = 0;
+	atmel_port->clocked = 1;
+	/* End Rose */
+
 	/* Use TXEMPTY for interrupt when rs485 else TXRDY or ENDTX|TXBUFE */
 	if (atmel_port->rs485.flags & SER_RS485_ENABLED)
-		atmel_port->tx_done_mask = ATMEL_US_TXEMPTY;
+		atmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;
 	else if (atmel_use_dma_tx(port)) {
 		port->fifosize = PDC_BUFFER_SIZE;
 		atmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;
@@ -1618,6 +1976,22 @@ static int __init atmel_console_setup(struct console *co, char *options)
 	int parity = 'n';
 	int flow = 'n';
 
+	/* SAN ROSE: Give the port number to global variable, so hrtimer function can see it */
+        console_index = co->index;
+        /* This function is must only be called once, but 3.2 kernel call it 3 times because of early init*/
+        if (atmel_use_dma_tx(port) && hr_data == NULL) {
+                /* Make sure that the port dont has csma enabled, otherwise NO kernel startup */
+                port->csma = 0;
+                /* Start hr timer */
+                hr_data = kmalloc (sizeof (*hr_data), GFP_KERNEL);
+                hr_data->period = ktime_set (0, DBUG_PDC_POLL_INTERVAL_NS);
+                hrtimer_init(&hr_data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+                hr_data->timer.function = at91_dbgu_timer;
+                /* ktime_set -> 10 s to make sure atat the clock is enabled, before read from the register */
+                hrtimer_start(&hr_data->timer, ktime_add(hr_data->period, ktime_set(10,0)) , HRTIMER_MODE_ABS);
+        }
+        /* End SAN */
+
 	if (port->membase == NULL) {
 		/* Port not initialized yet - delay setup */
 		return -ENODEV;
@@ -1795,7 +2169,6 @@ static int __devinit atmel_serial_probe(struct platform_device *pdev)
 	port = &atmel_ports[ret];
 	port->backup_imr = 0;
 	port->uart.line = ret;
-
 	atmel_init_port(port, pdev);
 
 	if (!atmel_use_dma_rx(&port->uart)) {
@@ -1863,6 +2236,11 @@ static int __devexit atmel_serial_remove(struct platform_device *pdev)
 	clear_bit(port->line, atmel_ports_in_use);
 
 	clk_put(atmel_port->clk);
+	/* SAN Rose: Cancel the hrtimer */
+	if (atmel_use_dma_tx(port)) {
+                hrtimer_cancel (&hr_data->timer);
+        }
+	/* End SAN */
 
 	return ret;
 }
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 145817c..3c630ca 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -518,6 +518,15 @@ static int uart_write(struct tty_struct *tty,
 	port = state->uart_port;
 	circ = &state->xmit;
 
+	/*
+	 * Mab rose Technology
+	 * Protect from multiple accesses to the port when in csma mode
+	 */
+	if(port->csma && tty->driver->ops->chars_in_buffer(tty)){
+		wait_event_interruptible(tty->write_wait, !tty->driver->ops->chars_in_buffer(tty));
+	}
+	/* End Mab */
+
 	if (!circ->buf)
 		return 0;
 
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 42e35c3..96ab949 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -378,6 +378,14 @@ struct uart_port {
 	unsigned char		irq_wake;
 	unsigned char		unused[2];
 	void			*private_data;		/* generic platform data pointer */
+	/* Mab Rose Technology */
+	unsigned short          csma;                   /* Carrier Sense Multiple Access mode */
+	/* End Mab */
+};
+
+/* Rose to be compatible with the RAP */
+struct uart_info {
+	struct tty_struct       *tty;
 };
 
 /*
@@ -390,6 +398,9 @@ struct uart_state {
 	struct circ_buf		xmit;
 
 	struct uart_port	*uart_port;
+	/* San Rose */
+	wait_queue_head_t       delta_msr_wait;
+	/* End San */
 };
 
 #define UART_XMIT_SIZE	PAGE_SIZE
-- 
1.8.3.1

