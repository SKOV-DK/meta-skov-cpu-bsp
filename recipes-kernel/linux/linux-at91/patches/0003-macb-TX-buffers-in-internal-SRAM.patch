From b4cf4693063d4f0433cacc39245267bc1ef74082 Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Sun, 1 Jan 2017 10:28:42 +0100
Subject: [PATCH] macb: TX buffers in internal SRAM

---
 drivers/net/ethernet/cadence/Kconfig |   6 +
 drivers/net/ethernet/cadence/macb.c  | 209 ++++++++++++++++++++++++++++++++++-
 drivers/net/ethernet/cadence/macb.h  |  14 ++-
 3 files changed, 223 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/cadence/Kconfig b/drivers/net/ethernet/cadence/Kconfig
index b48378a..4ba9a56 100644
--- a/drivers/net/ethernet/cadence/Kconfig
+++ b/drivers/net/ethernet/cadence/Kconfig
@@ -43,4 +43,10 @@ config MACB
 	  To compile this driver as a module, choose M here: the module
 	  will be called macb.
 
+config MACB_TX_SRAM
+	bool "Atmel MACB TX buffers in internal SRAM"
+	depends on MACB && (ARCH_AT91SAM9260 || ARCH_AT91SAM9263)
+	help
+		Use internal SRAM for TX buffers.
+
 endif # NET_ATMEL
diff --git a/drivers/net/ethernet/cadence/macb.c b/drivers/net/ethernet/cadence/macb.c
index a437b46..79b2966 100644
--- a/drivers/net/ethernet/cadence/macb.c
+++ b/drivers/net/ethernet/cadence/macb.c
@@ -26,6 +26,10 @@
 #include <mach/cpu.h>
 
 #include "macb.h"
+/* San Rose */
+static void reset_phy(struct net_device *dev);
+#define BMSR_PREAM_SUPR         0x0040
+/* End San */
 
 #define RX_BUFFER_SIZE		128
 #define RX_RING_SIZE		512
@@ -34,9 +38,22 @@
 /* Make the IP header word-aligned (the ethernet header is 14 bytes) */
 #define RX_OFFSET		2
 
-#define TX_RING_SIZE		128
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+	#if defined(CONFIG_ARCH_AT91SAM9260)
+		#define TX_RING_SIZE       2
+	#elif defined(CONFIG_ARCH_AT91SAM9263)
+		#define TX_RING_SIZE       32
+	#endif
+	#define TX_BUFFER_SIZE       1536
+	#define TX_RING_BYTES        (sizeof(struct dma_desc) * TX_RING_SIZE)
+	#define TX_DMA_SIZE      ((TX_RING_BYTES) + (TX_RING_SIZE) * (TX_BUFFER_SIZE))
+#else
+	#define TX_RING_SIZE     128
+	#define TX_RING_BYTES        (sizeof(struct dma_desc) * TX_RING_SIZE)
+#endif
 #define DEF_TX_RING_PENDING	(TX_RING_SIZE - 1)
-#define TX_RING_BYTES		(sizeof(struct dma_desc) * TX_RING_SIZE)
+/* End Mab */
 
 #define TX_RING_GAP(bp)						\
 	(TX_RING_SIZE - (bp)->tx_pending)
@@ -54,6 +71,95 @@
 #define MACB_RX_INT_FLAGS	(MACB_BIT(RCOMP) | MACB_BIT(RXUBR)	\
 				 | MACB_BIT(ISR_ROVR))
 
+/* San Rose */
+struct phy_device *phydev1;
+struct net_device *dev1;
+
+static ssize_t status_reg_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+        unsigned int bmsr, bmcr, phyid1, phyid2,  advertice, lpa, expansion, spec_config, spec_stat, conf_stat, pwdor, spec_config1, mdintr, pcver, dis_connect, rstlh;
+	bmcr = phy_read(phydev1, MII_BMCR);
+	bmsr = phy_read(phydev1, MII_BMSR);
+        phyid1 = phy_read(phydev1, MII_PHYSID1);
+        phyid2 = phy_read(phydev1, MII_PHYSID2);
+        advertice = phy_read(phydev1, MII_ADVERTISE);
+        lpa = phy_read(phydev1, MII_LPA);
+        expansion = phy_read(phydev1, MII_EXPANSION);
+        spec_config = phy_read(phydev1, 0x10);
+        spec_stat = phy_read(phydev1,  0x11);
+        conf_stat = phy_read(phydev1, MII_DCOUNTER);
+        pwdor = phy_read(phydev1, MII_FCSCOUNTER);
+        spec_config1 = phy_read(phydev1, MII_NWAYTEST);
+        mdintr = phy_read(phydev1, MII_RERRCOUNTER);
+        pcver = phy_read(phydev1, MII_SREVISION);
+        dis_connect = phy_read(phydev1, MII_RESV1);
+	rstlh = phy_read(phydev1, MII_LBRERROR);
+
+        return sprintf(buf, " MII_BMCR 0x%x\n MII_BMSR 0x%x\n MII_PHYID1 0x%x\n MII_PHYID2 0x%x\n MII_ADVERTISE 0x%x\n MII_LPA 0x%x\n\
+ MII_EXPANSION 0x%x\n Specified Config 0x%x\n Specified conf/stat 0x%x\n 10T conf/stat 0x%x\n PWDOR 0x%x\n Specified Config 0x%x\n\
+ MDINTR 0x%x\n RCVER 0x%x\n DIS_connect 0x%x\n RSTLH 0x%x\n", bmcr, bmsr, phyid1, phyid2, advertice, lpa, expansion, spec_config, spec_stat, conf_stat, pwdor, spec_config1, mdintr, pcver, dis_connect, rstlh);
+
+}
+
+static DEVICE_ATTR(status_reg, S_IRUGO, status_reg_read, NULL);
+
+static ssize_t phy_reset_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+        int len = strlen(buf);
+        if(buf[len-1] == '\n') {
+                len --;
+        }
+
+        if (buf[0] == '1') {
+                reset_phy(dev1);
+        }
+
+        return strlen(buf);
+}
+
+static DEVICE_ATTR(phy_reset, S_IWUSR, NULL, phy_reset_write);
+
+/*
+ * Perform a software reset of the PHY.
+ */
+static void reset_phy(struct net_device *dev)
+{
+        struct macb *bp = netdev_priv(dev);
+        unsigned int bmcr, bmsr;
+	unsigned int timeout = 100000;
+
+        spin_lock(&bp->lock);
+	bmsr = phy_read(phydev1, MII_BMSR);
+	bmcr = phy_read(phydev1, MII_BMCR);
+	bmcr |= BMCR_RESET;
+
+	/* Perform PHY reset */
+	phy_write(phydev1, MII_BMCR, bmcr);
+
+	/* Wait until PHY reset is complete */
+	do {
+		bmcr = phy_read(phydev1, MII_BMCR);
+		timeout--;
+	} while ((bmcr & BMCR_RESET) && timeout);
+
+	timeout = 100000;
+        bmcr = phy_read(phydev1, MII_BMCR);
+        bmcr |= BMCR_ANENABLE;
+        bmcr |= BMCR_ANRESTART;
+
+        phy_write(phydev1, MII_BMCR, bmcr);
+
+        /* Wait until PHY Auto Nigotiation is complete */
+
+        do {
+		bmcr = phy_read(phydev1, MII_BMCR);
+                timeout--;
+        } while ((bmcr & BMCR_ANRESTART) && timeout);
+
+        spin_unlock(&bp->lock);
+}
+/* End San */
+
 static void __macb_set_hwaddr(struct macb *bp)
 {
 	u32 bottom;
@@ -137,10 +243,25 @@ static void macb_handle_link_change(struct net_device *dev)
 {
 	struct macb *bp = netdev_priv(dev);
 	struct phy_device *phydev = bp->phy_dev;
+	/* San Rose */
+	unsigned int bmsr;
+	/* End san */
 	unsigned long flags;
 
 	int status_change = 0;
 
+	/* San Rose */
+	/* Call reset when a pardet fault detected */
+	bmsr = phy_read(phydev1, MII_BMSR);
+	if(!(bmsr & BMSR_LSTATUS))
+	{
+		if((bmsr & BMSR_PREAM_SUPR) && (bmsr & BMSR_ANEGCOMPLETE))
+		{
+	             reset_phy(dev1);
+	        }
+	}
+	/* End San */
+
 	spin_lock_irqsave(&bp->lock, flags);
 
 	if (phydev->link) {
@@ -371,8 +492,12 @@ static void macb_tx(struct macb *bp)
 
 		dev_dbg(&bp->pdev->dev, "skb %u (data %p) TX complete\n",
 			tail, skb->data);
+/* Mab Rose */
+#if !defined(CONFIG_MACB_TX_SRAM)
 		dma_unmap_single(&bp->pdev->dev, rp->mapping, skb->len,
 				 DMA_TO_DEVICE);
+#endif
+/* End Mab */
 		bp->stats.tx_packets++;
 		bp->stats.tx_bytes += skb->len;
 		rp->skb = NULL;
@@ -654,8 +779,15 @@ static int macb_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	entry = bp->tx_head;
 	dev_dbg(&bp->pdev->dev, "Allocated ring entry %u\n", entry);
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+	mapping = bp->tx_ring[entry].addr;
+	memcpy(bp->tx_buffers + entry * TX_BUFFER_SIZE, skb->data, len);
+#else
 	mapping = dma_map_single(&bp->pdev->dev, skb->data,
 				 len, DMA_TO_DEVICE);
+#endif
+/* End Mab */
 	bp->tx_skb[entry].skb = skb;
 	bp->tx_skb[entry].mapping = mapping;
 	dev_dbg(&bp->pdev->dev, "Mapped skb data %p to DMA addr %08lx\n",
@@ -665,8 +797,11 @@ static int macb_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	ctrl |= MACB_BIT(TX_LAST);
 	if (entry == (TX_RING_SIZE - 1))
 		ctrl |= MACB_BIT(TX_WRAP);
-
+/* Mab Rose */
+#if !defined(CONFIG_MACB_TX_SRAM)
 	bp->tx_ring[entry].addr = mapping;
+#endif
+/* End Mab */
 	bp->tx_ring[entry].ctrl = ctrl;
 	wmb();
 
@@ -697,8 +832,14 @@ static void macb_free_consistent(struct macb *bp)
 		bp->rx_ring = NULL;
 	}
 	if (bp->tx_ring) {
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+		iounmap((void *)bp->tx_ring);
+#else
 		dma_free_coherent(&bp->pdev->dev, TX_RING_BYTES,
 				  bp->tx_ring, bp->tx_ring_dma);
+#endif
+/* End Mab */
 		bp->tx_ring = NULL;
 	}
 	if (bp->rx_buffers) {
@@ -707,6 +848,12 @@ static void macb_free_consistent(struct macb *bp)
 				  bp->rx_buffers, bp->rx_buffers_dma);
 		bp->rx_buffers = NULL;
 	}
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+	if (bp->tx_ring_dma)
+		release_mem_region(bp->tx_ring_dma, TX_DMA_SIZE);
+#endif
+/* End Mab */
 }
 
 static int macb_alloc_consistent(struct macb *bp)
@@ -726,7 +873,35 @@ static int macb_alloc_consistent(struct macb *bp)
 	dev_dbg(&bp->pdev->dev,
 		"Allocated RX ring of %d bytes at %08lx (mapped %p)\n",
 		size, (unsigned long)bp->rx_ring_dma, bp->rx_ring);
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+#if  defined(CONFIG_ARCH_AT91SAM9260)
+	if (request_mem_region(AT91SAM9260_SRAM0_BASE, TX_DMA_SIZE, "macb")) {
+		bp->tx_ring_dma = AT91SAM9260_SRAM0_BASE;
+	} else {
+		if (request_mem_region(AT91SAM9260_SRAM1_BASE, TX_DMA_SIZE, "macb")) {
+			bp->tx_ring_dma = AT91SAM9260_SRAM1_BASE;
+		} else {
+			printk(KERN_WARNING "Cannot request SRAM memory for TX ring, already used\n");
+			return -EBUSY;
+		}
+	}
+#elif defined(CONFIG_ARCH_AT91SAM9263)
+	if (request_mem_region(AT91SAM9263_SRAM0_BASE, TX_DMA_SIZE, "macb")) {
+		bp->tx_ring_dma = AT91SAM9263_SRAM0_BASE;
+	} else {
+		printk(KERN_WARNING "Cannot request SRAM memory for TX ring, already used\n");
+		return -EBUSY;
+	}
+#endif
 
+	bp->tx_ring = ioremap(bp->tx_ring_dma, TX_DMA_SIZE);
+	if (!bp->tx_ring)
+		return -ENOMEM;
+
+	bp->tx_buffers_dma = bp->tx_ring_dma + TX_RING_BYTES;
+	bp->tx_buffers = (char *) bp->tx_ring + TX_RING_BYTES;
+#else
 	size = TX_RING_BYTES;
 	bp->tx_ring = dma_alloc_coherent(&bp->pdev->dev, size,
 					 &bp->tx_ring_dma, GFP_KERNEL);
@@ -735,7 +910,8 @@ static int macb_alloc_consistent(struct macb *bp)
 	dev_dbg(&bp->pdev->dev,
 		"Allocated TX ring of %d bytes at %08lx (mapped %p)\n",
 		size, (unsigned long)bp->tx_ring_dma, bp->tx_ring);
-
+#endif
+/* End Mab */
 	size = RX_RING_SIZE * RX_BUFFER_SIZE;
 	bp->rx_buffers = dma_alloc_coherent(&bp->pdev->dev, size,
 					    &bp->rx_buffers_dma, GFP_KERNEL);
@@ -764,11 +940,19 @@ static void macb_init_rings(struct macb *bp)
 		addr += RX_BUFFER_SIZE;
 	}
 	bp->rx_ring[RX_RING_SIZE - 1].addr |= MACB_BIT(RX_WRAP);
-
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91) && defined(CONFIG_MACB_TX_SRAM)
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		bp->tx_ring[i].addr = bp->tx_buffers_dma + i * TX_BUFFER_SIZE;
+		bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
+	}
+#else
 	for (i = 0; i < TX_RING_SIZE; i++) {
 		bp->tx_ring[i].addr = 0;
 		bp->tx_ring[i].ctrl = MACB_BIT(TX_USED);
 	}
+#endif
+/* End Mab */
 	bp->tx_ring[TX_RING_SIZE - 1].ctrl |= MACB_BIT(TX_WRAP);
 
 	bp->rx_tail = bp->tx_head = bp->tx_tail = 0;
@@ -1127,6 +1311,9 @@ static int __init macb_probe(struct platform_device *pdev)
 	unsigned long pclk_hz;
 	u32 config;
 	int err = -ENXIO;
+	/* San Rose */
+	int ret;
+	/* End San */
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs) {
@@ -1247,6 +1434,13 @@ static int __init macb_probe(struct platform_device *pdev)
 		"(mii_bus:phy_addr=%s, irq=%d)\n", dev->name,
 		phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
 
+	/* San Rose */
+    phydev1 = phydev;
+    dev1=dev;
+    ret = device_create_file(&pdev->dev, &dev_attr_status_reg);
+	ret = device_create_file(&pdev->dev, &dev_attr_phy_reset);
+    /* End San */
+
 	return 0;
 
 err_out_unregister_netdev:
@@ -1279,6 +1473,11 @@ static int __exit macb_remove(struct platform_device *pdev)
 
 	dev = platform_get_drvdata(pdev);
 
+	/* San Rose */
+	device_remove_file(&pdev->dev, &dev_attr_status_reg);
+	device_remove_file(&pdev->dev, &dev_attr_phy_reset);
+	/* End san */
+
 	if (dev) {
 		bp = netdev_priv(dev);
 		if (bp->phy_dev)
diff --git a/drivers/net/ethernet/cadence/macb.h b/drivers/net/ethernet/cadence/macb.h
index d3212f6..a1a6828 100644
--- a/drivers/net/ethernet/cadence/macb.h
+++ b/drivers/net/ethernet/cadence/macb.h
@@ -368,9 +368,16 @@ struct macb {
 	unsigned int		tx_head, tx_tail;
 	struct dma_desc		*tx_ring;
 	struct ring_info	*tx_skb;
-
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91)
+	void            *tx_buffers;
+#endif
+/* End Mab */
 	spinlock_t		lock;
 	struct platform_device	*pdev;
+/* Mab Rose */
+	struct clk      *macb_clk;
+/* End Mab */
 	struct clk		*pclk;
 	struct clk		*hclk;
 	struct net_device	*dev;
@@ -381,6 +388,11 @@ struct macb {
 	dma_addr_t		rx_ring_dma;
 	dma_addr_t		tx_ring_dma;
 	dma_addr_t		rx_buffers_dma;
+/* Mab Rose */
+#if defined(CONFIG_ARCH_AT91)
+	dma_addr_t      tx_buffers_dma;
+#endif
+/* End Mab */
 
 	unsigned int		rx_pending, tx_pending;
 
-- 
1.8.3.1

