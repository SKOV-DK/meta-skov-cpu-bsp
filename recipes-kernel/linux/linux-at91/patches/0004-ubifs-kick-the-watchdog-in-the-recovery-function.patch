From cfa41343520cd0267921c9ada24ced740ad84c82 Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Sun, 1 Jan 2017 10:33:11 +0100
Subject: [PATCH] ubifs: kick the watchdog in the recovery function

---
 arch/arm/mach-at91/include/mach/at91_wdt.h |  4 ++++
 drivers/watchdog/at91sam9_wdt.c            | 13 ++++++++++++-
 fs/ubifs/recovery.c                        |  9 +++++++++
 3 files changed, 25 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/mach-at91/include/mach/at91_wdt.h

diff --git a/arch/arm/mach-at91/include/mach/at91_wdt.h b/arch/arm/mach-at91/include/mach/at91_wdt.h
new file mode 100644
index 0000000..ccd36e5
--- /dev/null
+++ b/arch/arm/mach-at91/include/mach/at91_wdt.h
@@ -0,0 +1,4 @@
+/*
+ *Other drivers can also reset the watchdog
+ */
+void at91_reset_wdt(void);
diff --git a/drivers/watchdog/at91sam9_wdt.c b/drivers/watchdog/at91sam9_wdt.c
index 87445b2..d1410a0 100644
--- a/drivers/watchdog/at91sam9_wdt.c
+++ b/drivers/watchdog/at91sam9_wdt.c
@@ -81,6 +81,15 @@ static inline void at91_wdt_reset(void)
 }
 
 /*
+ *San Rose other drivers can tick the watchdog.
+ */
+void at91_reset_wdt(void)
+{
+  at91_wdt_reset();
+}
+EXPORT_SYMBOL(at91_reset_wdt);
+
+/*
  * Timer tick
  */
 static void at91_ping(unsigned long data)
@@ -115,9 +124,11 @@ static int at91_wdt_close(struct inode *inode, struct file *file)
 	clear_bit(0, &at91wdt_private.open);
 
 	/* stop internal ping */
+	/* San rose */
+	/*
 	if (!at91wdt_private.expect_close)
 		del_timer(&at91wdt_private.timer);
-
+	*/
 	at91wdt_private.expect_close = 0;
 	return 0;
 }
diff --git a/fs/ubifs/recovery.c b/fs/ubifs/recovery.c
index ee4f43f..5b31955 100644
--- a/fs/ubifs/recovery.c
+++ b/fs/ubifs/recovery.c
@@ -49,6 +49,12 @@
 
 #include <linux/crc32.h>
 #include <linux/slab.h>
+#if defined (CONFIG_AT91SAM9X_WATCHDOG)
+  #include <mach/at91_wdt.h>
+  #define	PET_WATCHDOG	at91_reset_wdt();
+#else
+  #define	PET_WATCHDOG
+#endif
 #include "ubifs.h"
 
 /**
@@ -240,6 +246,7 @@ int ubifs_recover_master_node(struct ubifs_info *c)
 	const int sz = c->mst_node_alsz;
 	int err, offs1, offs2;
 
+	PET_WATCHDOG
 	dbg_rcvry("recovery");
 
 	err = get_master_node(c, UBIFS_MST_LNUM, &buf1, &mst1, &cor1);
@@ -258,6 +265,7 @@ int ubifs_recover_master_node(struct ubifs_info *c)
 			 * mst1 was written by recovery at offset 0 with no
 			 * corruption.
 			 */
+			PET_WATCHDOG
 			dbg_rcvry("recovery recovery");
 			mst = mst1;
 		} else if (mst2) {
@@ -974,6 +982,7 @@ int ubifs_recover_inl_heads(struct ubifs_info *c, void *sbuf)
 	if (err)
 		return err;
 
+	PET_WATCHDOG
 	dbg_rcvry("checking LPT head at %d:%d", c->nhead_lnum, c->nhead_offs);
 	err = recover_head(c, c->nhead_lnum, c->nhead_offs, sbuf);
 	if (err)
-- 
1.8.3.1

