From 4740b29193e92611a569041c1072a0fca7b9384e Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Sun, 1 Jan 2017 16:21:26 +0100
Subject: [PATCH] add skov arm9-cpu board

---
 arch/arm/mach-at91/Kconfig               |    6 +
 arch/arm/mach-at91/Makefile              |    3 +-
 arch/arm/mach-at91/at91sam9263_devices.c |   12 +-
 arch/arm/mach-at91/at91sam9_alt_reset.S  |   18 +-
 arch/arm/mach-at91/board-skovarm9.c      | 1087 ++++++++++++++++++++++++++++++
 arch/arm/mach-at91/clock.c               |    3 +
 arch/arm/mach-at91/include/mach/board.h  |   81 +++
 arch/arm/tools/mach-types                |    1 +
 8 files changed, 1202 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm/mach-at91/board-skovarm9.c

diff --git a/arch/arm/mach-at91/Kconfig b/arch/arm/mach-at91/Kconfig
index d111c3e..181d2f8 100644
--- a/arch/arm/mach-at91/Kconfig
+++ b/arch/arm/mach-at91/Kconfig
@@ -287,6 +287,12 @@ if ARCH_AT91SAM9263
 
 comment "AT91SAM9263 Board Type"
 
+config MACH_SKOVARM9CPU
+	bool "SKOV ARM9 CPU"
+	select HAVE_AT91_DATAFLASH_CARD
+	help
+	  Select if you are using the SKOV ARM9 CPU card.
+
 config MACH_AT91SAM9263EK
 	bool "Atmel AT91SAM9263-EK Evaluation Kit"
 	select HAVE_AT91_DATAFLASH_CARD
diff --git a/arch/arm/mach-at91/Makefile b/arch/arm/mach-at91/Makefile
index 242174f..37b6f49 100644
--- a/arch/arm/mach-at91/Makefile
+++ b/arch/arm/mach-at91/Makefile
@@ -53,9 +53,10 @@ obj-$(CONFIG_MACH_AT91SAM9261EK) += board-sam9261ek.o
 obj-$(CONFIG_MACH_AT91SAM9G10EK) += board-sam9261ek.o
 
 # AT91SAM9263 board-specific support
-obj-$(CONFIG_MACH_AT91SAM9263EK) += board-sam9263ek.o
+obj-$(CONFIG_MACH_AT91SAM9263EK)+= board-sam9263ek.o
 obj-$(CONFIG_MACH_USB_A9263)	+= board-usb-a926x.o
 obj-$(CONFIG_MACH_NEOCORE926)	+= board-neocore926.o
+obj-$(CONFIG_MACH_SKOVARM9CPU)	+= board-skovarm9.o
 
 # AT91SAM9RL board-specific support
 obj-$(CONFIG_MACH_AT91SAM9RLEK)	+= board-sam9rlek.o
diff --git a/arch/arm/mach-at91/at91sam9263_devices.c b/arch/arm/mach-at91/at91sam9263_devices.c
index e051376..e36f602 100644
--- a/arch/arm/mach-at91/at91sam9263_devices.c
+++ b/arch/arm/mach-at91/at91sam9263_devices.c
@@ -834,6 +834,7 @@ void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data)
 	if (!data)
 		return;
 
+	at91_set_A_periph(AT91_PIN_PC0, 0);	/* LCDVSYNC */
 	at91_set_A_periph(AT91_PIN_PC1, 0);	/* LCDHSYNC */
 	at91_set_A_periph(AT91_PIN_PC2, 0);	/* LCDDOTCK */
 	at91_set_A_periph(AT91_PIN_PC3, 0);	/* LCDDEN */
@@ -1044,16 +1045,16 @@ static struct platform_device at91sam9263_pwm0_device = {
 void __init at91_add_device_pwm(u32 mask)
 {
 	if (mask & (1 << AT91_PWM0))
-		at91_set_B_periph(AT91_PIN_PB7, 1);	/* enable PWM0 */
+		at91_set_B_periph(AT91_PIN_PC28, 1);	/* enable PWM0 buzzer*/
 
 	if (mask & (1 << AT91_PWM1))
 		at91_set_B_periph(AT91_PIN_PB8, 1);	/* enable PWM1 */
 
 	if (mask & (1 << AT91_PWM2))
-		at91_set_B_periph(AT91_PIN_PC29, 1);	/* enable PWM2 */
+		at91_set_B_periph(AT91_PIN_PC29, 1);	/* enable PWM2 lcd contrast*/
 
 	if (mask & (1 << AT91_PWM3))
-		at91_set_B_periph(AT91_PIN_PB29, 1);	/* enable PWM3 */
+		at91_set_B_periph(AT91_PIN_PE10, 1);	/* enable PWM3 lcd backlight*/
 
 	pwm_mask = mask;
 
@@ -1208,8 +1209,9 @@ static struct resource dbgu_resources[] = {
 };
 
 static struct atmel_uart_data dbgu_data = {
-	.use_dma_tx	= 0,
-	.use_dma_rx	= 0,		/* DBGU not capable of receive DMA */
+	.use_dma_tx	= 1, /* Rose: Debug serial port lacks timeout interrupt, therefore it is normaly used without DMA */
+	.use_dma_rx	= 1, /* We implemented a hr-timer to poll the DMA buffer for incomming characters. */
+	                     /* This solution seems to work very well. */
 };
 
 static u64 dbgu_dmamask = DMA_BIT_MASK(32);
diff --git a/arch/arm/mach-at91/at91sam9_alt_reset.S b/arch/arm/mach-at91/at91sam9_alt_reset.S
index e0256de..d55676f 100644
--- a/arch/arm/mach-at91/at91sam9_alt_reset.S
+++ b/arch/arm/mach-at91/at91sam9_alt_reset.S
@@ -18,7 +18,9 @@
 #include <mach/hardware.h>
 #include <mach/at91sam9_sdramc.h>
 #include <mach/at91_rstc.h>
-
+/* San Rose */
+#define AT91_SDRAMC     AT91_SDRAMC0
+/* End San */
 			.arm
 
 			.globl	at91sam9_alt_reset
@@ -36,8 +38,12 @@ at91sam9_alt_reset:	mrc	p15, 0, r0, c1, c0, 0
 
 			.balign	32				@ align to cache line
 
-			str	r2, [r0, #AT91_SDRAMC_TR]	@ disable SDRAM access
-			str	r3, [r0, #AT91_SDRAMC_LPR]	@ power down SDRAM
+/* San Rose */
+			ldr     r0, .at91_va_base_sdramc_lpr    @ AS FLAGS different than 2.6.37
+			str	r2, [r0]
+			ldr     r0, .at91_va_base_sdramc_lpr    @ AS FLAGS different than 2.6.37
+			str	r3, [r0]
+/* End san */
 			str	r4, [r1]			@ reset processor
 
 			b	.
@@ -46,3 +52,9 @@ at91sam9_alt_reset:	mrc	p15, 0, r0, c1, c0, 0
 	.word AT91_VA_BASE_SYS + AT91_SDRAMC0
 .at91_va_base_rstc_cr:
 	.word AT91_VA_BASE_SYS + AT91_RSTC_CR
+/* San Rose */
+.at91_va_base_sdramc_lpr:
+        .word AT91_VA_BASE_SYS + AT91_SDRAMC_LPR
+.at91_va_base_sdramc_tr:
+        .word AT91_VA_BASE_SYS + AT91_SDRAMC_TR
+/* End san */
diff --git a/arch/arm/mach-at91/board-skovarm9.c b/arch/arm/mach-at91/board-skovarm9.c
new file mode 100644
index 0000000..244128c
--- /dev/null
+++ b/arch/arm/mach-at91/board-skovarm9.c
@@ -0,0 +1,1087 @@
+/*
+ * linux/arch/arm/mach-at91/board-skovarm9.c
+ *
+ *  Copyright (C) 2005 SAN People
+ *  Copyright (C) 2007 Atmel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/i2c/at24.h>
+#include <linux/fb.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+
+#include <video/atmel_lcdc.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/at91_shdwc.h>
+#include <mach/system_rev.h>
+/* Logic display detect */
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include "sam9_smc.h"
+#include "generic.h"
+
+/* Need to set Uart to RS485 */
+#include <linux/atmel_serial.h>
+
+/* skov defines */
+#include <linux/skov_pwm.h>
+#include <linux/lc7981.h>
+#include <linux/encoder.h>
+#include <linux/spi/mcp3002.h>
+
+// These belong in asm-generic/sizes.h - but add them here to avoid
+// dependencies outside arch/arm
+#define SZ_384K                                0x00060000
+#define SZ_768K                                0x000C0000
+
+static void __init skovarm9_init_early(void)
+{
+	/* Initialize processor: 16.367 MHz crystal */
+	at91_initialize(16000000);
+
+	/* DBGU on ttyS0. (Rx & Tx only) */
+	at91_register_uart(0, 0, 0);
+
+	/* USART0 on ttyS1. (Rx, Tx, RTS, CTS) RS 485 mode */
+	at91_register_uart(AT91SAM9263_ID_US0, 1, ATMEL_UART_CTS | ATMEL_UART_RTS);
+	/* USART0 on ttyS2. (Rx, Tx) RS 232 mode */
+	at91_register_uart(AT91SAM9263_ID_US1, 2, 0 );
+        /* USART0 on ttyS3. (Rx, Tx) RS 232 mode */
+        at91_register_uart(AT91SAM9263_ID_US2, 3, 0 );
+
+
+	/* set serial console to ttyS0 (ie, DBGU) */
+	at91_set_serial_console(0);
+}
+
+/*
+ * USB Host port
+ */
+static struct at91_usbh_data __initdata skovarm9_usbh_data = {
+	.ports		= 2,
+	.vbus_pin	= { AT91_PIN_PA24, AT91_PIN_PA21 },
+};
+
+/*
+ * USB Device port
+ */
+static struct at91_udc_data __initdata skovarm9_udc_data = {
+	.vbus_pin	= AT91_PIN_PA25,
+	.pullup_pin	= 0,		/* pull-up driven by UDC */
+};
+
+
+/*
+ * ADS7846 Touchscreen
+ */
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+static int ads7843_pendown_state(void)
+{
+	return !at91_get_gpio_value(AT91_PIN_PA15);	/* Touchscreen PENIRQ */
+}
+
+static struct ads7846_platform_data ads_info = {
+	.model			= 7846,
+	.x_min			= 800,
+	.x_max			= 3400,
+	.y_min			= 500,
+	.y_max			= 3400,
+	.vref_delay_usecs	= 300,
+	.x_plate_ohms		= 642,
+	.y_plate_ohms		= 295,
+	.pressure_max		= 1500,
+	.debounce_max		= 100,
+	.debounce_rep		= 8,
+	.debounce_tol		= (~0),
+	.get_pendown_state	= ads7843_pendown_state,
+};
+
+static void __init skovarm9_add_device_ts(void)
+{
+	at91_set_B_periph(AT91_PIN_PA15, 1);	/* External IRQ1, with pullup */
+	at91_set_gpio_input(AT91_PIN_PA31, 1);	/* Touchscreen BUSY signal */
+}
+#else
+static void __init skovarm9_add_device_ts(void) {}
+#endif
+
+/*
+ * San Rose - Voltage and temperature read
+ */
+#if defined(CONFIG_ADC_MCP3002) || defined(CONFIG_ADC_MCP3002_MODULE)
+static struct mcp3002_platform_data mcp3002_info = {
+	.model                  = "mcp3002",
+};
+void __init at91_add_device_adc(void) {}
+#endif
+
+
+/*
+ * SPI devices.
+ */
+static struct spi_board_info skovarm9_spi_devices[] = {
+#if defined(CONFIG_MTD_AT91_DATAFLASH_CARD)
+	{	/* DataFlash card */
+		.modalias	= "mtd_dataflash",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+		.bus_num	= 0,
+	},
+#endif
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+	{
+		.modalias	= "ads7846",
+		.chip_select	= 3,
+		.max_speed_hz	= 125000 * 26,	/* (max sample rate @ 3V) * (cmd + data + overhead) */
+		.bus_num	= 0,
+		.platform_data	= &ads_info,
+		.irq		= AT91SAM9263_ID_IRQ1,
+	},
+#endif
+#if defined(CONFIG_ADC_MCP3002) || defined(CONFIG_ADC_MCP3002_MODULE)
+        {       /* MCP3002 */
+		.modalias       = "mcp3002",
+		.chip_select    = 1,
+		.max_speed_hz   = 1000000,
+		.mode           = SPI_MODE_0,
+		.bus_num        = 0,
+		.platform_data  = &mcp3002_info,
+//              .controller_data = (void *) AT91_PIN_PA25,       /* CS pin */
+	},
+#endif
+
+};
+
+
+/*
+ * MCI (SD/MMC)
+ */
+static struct at91_mmc_data __initdata skovarm9_mmc_data = {
+	.wire4		= 1,
+	.det_pin	= AT91_PIN_PE18,
+	.wp_pin		= AT91_PIN_PE19,
+//	.vcc_pin	= ... not connected
+};
+
+
+/*
+ * MACB Ethernet device
+ */
+static struct at91_eth_data __initdata skovarm9_macb_data = {
+	.phy_irq_pin	= AT91_PIN_PE31,
+	.is_rmii	= 1,
+};
+
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition __initdata skovarm9_nand_partition[] = {
+        {
+		.name   = "Bootstrap",
+		.offset = 0,
+		.size   = SZ_128K,
+	},
+	{
+		.name   = "Uboot",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_384K,
+	},
+	{
+		.name   = "Env1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_128K,
+	},
+	{
+		.name   = "Env2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_128K,
+	},
+	{
+		.name   = "Uboot2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_384K,
+	},
+	{
+		.name   = "Linux",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_2M,
+	},
+	{
+		.name   = "Linux2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_2M,
+	},
+	{
+		.name   = "BMP",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_768K,
+	},
+	{
+		.name   = "BMP2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size   = SZ_768K,
+	},
+	{
+		.name   = "rootfs",
+		.offset = MTDPART_OFS_NXTBLK,
+		//.size = MTDPART_SIZ_FULL,
+		.size   = SZ_128M,
+	},
+};
+
+static struct atmel_nand_data __initdata skovarm9_nand_data = {
+	.ale		= 21,
+	.cle		= 22,
+//	.det_pin	= ... not connected
+	.rdy_pin	= AT91_PIN_PA22,
+	.enable_pin	= AT91_PIN_PD15,
+	.parts		= skovarm9_nand_partition,
+#if defined(CONFIG_MTD_NAND_ATMEL_BUSWIDTH_16)
+	.bus_width_16	= 1,
+#else
+	.bus_width_16	= 0,
+#endif
+	.num_parts	= ARRAY_SIZE(skovarm9_nand_partition),
+};
+
+static struct sam9_smc_config __initdata skovarm9_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 1,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 1,
+
+	.ncs_read_pulse		= 3,
+	.nrd_pulse		= 3,
+	.ncs_write_pulse	= 3,
+	.nwe_pulse		= 3,
+
+	.read_cycle		= 5,
+	.write_cycle		= 5,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE,
+	.tdf_cycles		= 2,
+};
+
+static void __init skovarm9_add_device_nand(void)
+{
+	skovarm9_nand_data.bus_width_16 = board_have_nand_16bit();
+	/* setup bus-width (8 or 16) */
+	if (skovarm9_nand_data.bus_width_16)
+		skovarm9_nand_smc_config.mode |= AT91_SMC_DBW_16;
+	else
+		skovarm9_nand_smc_config.mode |= AT91_SMC_DBW_8;
+
+	/* configure chip-select 3 (NAND) */
+	sam9_smc_configure(3, &skovarm9_nand_smc_config);
+
+	at91_add_device_nand(&skovarm9_nand_data);
+}
+
+
+/*
+ * I2C devices
+ */
+static struct at24_platform_data at24c512 = {
+	.byte_len	= SZ_512K / 8,
+	.page_size	= 128,
+	.flags		= AT24_FLAG_ADDR16,
+};
+
+
+static struct i2c_board_info __initdata skovarm9_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("24c512", 0x50),
+		.platform_data = &at24c512,
+	},
+	{
+		I2C_BOARD_INFO("ds1374", 0x68),
+	}
+	/* more devices can be added using expansion connectors */
+};
+
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes_seiko[] = {
+        {
+                .name           = "70WVW2AZ0 @ 55",
+                .refresh        = 55,
+                .xres           = 800,          .yres           = 480,
+                .pixclock       = KHZ2PICOS(30000),
+
+                .left_margin    = 0,            .right_margin   = 200,
+                .upper_margin   = 0,            .lower_margin   = 10,
+                .hsync_len      = 3,            .vsync_len      = 3,
+                .sync           = 0,
+                .vmode          = FB_VMODE_NONINTERLACED,
+        },
+};
+
+static struct fb_videomode at91_tft_vga_modes_logic[] = {
+        {
+                .name           = "LTTD800480070-L2RT @ 55",
+                .refresh        = 55,
+                .xres           = 800,          .yres           = 480,
+                .pixclock       = KHZ2PICOS(30000),
+//Atmel calculates: Total Length = Hsync + left marging + picture + right_margin+1 (3+85+800+0+1=889)
+//Atmel calculates: Total Length = upper marging + picture + lower_margin (32+480+1=513) (25MHz / ( 889 * 513 ) = 54,8Hz
+                .left_margin    = 85,           .right_margin   = 1,
+                .upper_margin   = 32,           .lower_margin   = 1,
+                .hsync_len      = 3,            .vsync_len      = 3,
+                .sync           = 0,
+                .vmode          = FB_VMODE_NONINTERLACED,
+        },
+};
+
+static struct fb_videomode at91_tft_vga_modes_logic_240[] = {
+        {
+                .name           = "LTTD800480070-L2RT @ 60",
+                .refresh        = 60,
+                .xres           = 800,          .yres           = 480,
+                .pixclock       = KHZ2PICOS(30000),
+//Atmel calculates: Total Length = Hsync + left marging + picture + right_margin+1 (3+85+800+20+1=909)
+//Atmel calculates: Total Length = upper marging + picture + lower_margin (32+480+38=550) (30MHz / ( 909 * 550 ) = 60Hz
+                .left_margin    = 85,           .right_margin   = 20,
+                .upper_margin   = 32,           .lower_margin   = 38,
+                .hsync_len      = 3,            .vsync_len      = 3,
+                .sync           = 0,
+                .vmode          = FB_VMODE_NONINTERLACED,
+        },
+};
+
+static struct fb_monspecs at91fb_default_monspecs_seiko = {
+        .manufacturer   = "SEK",
+        .monitor        = "70WVW2AZ0",
+        .modedb         = at91_tft_vga_modes_seiko,
+        .modedb_len     = ARRAY_SIZE(at91_tft_vga_modes_seiko),
+        .hfmin          = 5000,
+        .hfmax          = 84000,
+        .vfmin          = 40,
+        .vfmax          = 200,
+        .dclkmax        = 40000000,
+};
+
+static struct fb_monspecs at91fb_default_monspecs_logic = {
+        .manufacturer   = "LOG",
+        .monitor        = "LTTD800480070",
+        .modedb         = at91_tft_vga_modes_logic,
+        .modedb_len     = ARRAY_SIZE(at91_tft_vga_modes_logic),
+        .hfmin          = 5000,
+        .hfmax          = 84000,
+        .vfmin          = 40,
+        .vfmax          = 200,
+        .dclkmax        = 40000000,
+};
+
+static struct fb_monspecs at91fb_default_monspecs_logic_240 = {
+        .manufacturer   = "LOG",
+        .monitor        = "LTTD800480070",
+        .modedb         = at91_tft_vga_modes_logic_240,
+        .modedb_len     = ARRAY_SIZE(at91_tft_vga_modes_logic_240),
+        .hfmin          = 5000,
+        .hfmax          = 84000,
+        .vfmin          = 40,
+        .vfmax          = 200,
+        .dclkmax        = 40000000,
+};
+#define AT91SAM9263_DEFAULT_LCDCON2     (ATMEL_LCDC_MEMOR_LITTLE \
+                                        | ATMEL_LCDC_DISTYPE_TFT \
+                                        | ATMEL_LCDC_CLKMOD_ALWAYSACTIVE)
+
+
+static void at91_lcdc_power_control(int on)
+{
+	at91_set_gpio_value(AT91_PIN_PA30, on);
+}
+
+/* Driver data */
+static struct atmel_lcdfb_info __initdata skovarm9_lcdc_data = {
+        .lcdcon_is_backlight            = true,
+                .default_bpp                    = 16,
+        .default_dmacon                 = ATMEL_LCDC_DMAEN,
+        .default_lcdcon2                = AT91SAM9263_DEFAULT_LCDCON2,
+        .default_monspecs               = &at91fb_default_monspecs_seiko,
+        .atmel_lcdfb_power_control      = at91_lcdc_power_control,
+        .guard_time                     = 1,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata skovarm9_lcdc_data;
+#endif
+
+
+/*
+ * GPIO Buttons
+ */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button skovarm9_buttons[] = {
+	{	/* BP1, "leftclic" */
+		.code		= BTN_LEFT,
+		.gpio		= AT91_PIN_PC5,
+		.active_low	= 1,
+		.desc		= "left_click",
+		.wakeup		= 1,
+	},
+	{	/* BP2, "rightclic" */
+		.code		= BTN_RIGHT,
+		.gpio		= AT91_PIN_PC4,
+		.active_low	= 1,
+		.desc		= "right_click",
+		.wakeup		= 1,
+	}
+};
+
+static struct gpio_keys_platform_data skovarm9_button_data = {
+	.buttons	= skovarm9_buttons,
+	.nbuttons	= ARRAY_SIZE(skovarm9_buttons),
+};
+
+static struct platform_device skovarm9_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &skovarm9_button_data,
+	}
+};
+
+static void __init skovarm9_add_device_buttons(void)
+{
+	at91_set_GPIO_periph(AT91_PIN_PC5, 1);	/* left button */
+	at91_set_deglitch(AT91_PIN_PC5, 1);
+	at91_set_GPIO_periph(AT91_PIN_PC4, 1);	/* right button */
+	at91_set_deglitch(AT91_PIN_PC4, 1);
+
+	platform_device_register(&skovarm9_button_device);
+}
+#else
+static void __init skovarm9_add_device_buttons(void) {}
+#endif
+
+/*
+ * Under Voltage Lock Out
+ */
+static struct under_voltage_data uv_data = {
+       .pin = AT91_PIN_PE14,
+};
+
+/*
+ * AC97
+ * reset_pin is not connected: NRST
+ */
+static struct ac97c_platform_data skovarm9_ac97_data = {
+};
+
+/*
+ * PWM
+ */
+static struct skov_pwm_dev_data skov_pwm_data = {
+  .pwm_len = 4,
+  .pwms = {
+    [0] = {
+      .startup = 0,
+      .state = 1,
+      .id = 0,
+      .period = 100,
+      .start_offset = 0,
+      .end_offset = 0,
+      .duty_cycle = 50,
+      .dev_name = "buzzer",
+      .periph = 'A',
+      .pin = AT91_PIN_PC28,
+      .pre_scaler = AT91_PWM_CMR_MCK256,
+    },
+    [1] = {
+      .startup = 1,
+      .state = 1,
+      .id = 1,
+      .period = 256,
+      .start_offset = 67, //distance from 0 to start
+      .end_offset = 89, //distance from end period
+      .duty_cycle = 78,
+      .dev_name = "tft_contrast",
+      .periph = 'B',
+      .pin = AT91_PIN_PB8,
+      .pre_scaler = AT91_PWM_CMR_MCK32,
+    },
+    [2] = {
+      .startup = 1,
+      .state = 1,
+      .id = 2,
+      .period = 500,
+      .start_offset = 60,
+      .end_offset = 340,
+      .duty_cycle = 110, // value about 22   (duty_cycle * 100 / period)
+      .dev_name = "lcd_contrast",
+      .periph = 'B',
+      .pin = AT91_PIN_PC29,
+      .pre_scaler = AT91_PWM_CMR_MCK512,
+    },
+    [3] = {
+      .startup = 1,
+      .state = 1,
+      .id = 3,
+      .period = 100,
+      .start_offset = 0,
+      .end_offset = 0,
+      .duty_cycle = 80,
+      .dev_name = "lcd_bglight",
+      .periph = 'B',
+      .pin = AT91_PIN_PE10,
+      .pre_scaler = AT91_PWM_CMR_MCK64,
+    },
+  },
+};
+
+/*
+ * LEDs ... these could all be PWM-driven, for variable brightness
+ */
+static struct gpio_led skovarm9_leds[] = {
+	{	/* "right" led, green, userled2 (could be driven by pwm2) */
+		.name			= "ds2",
+		.gpio			= AT91_PIN_PC29,
+		.active_low		= 1,
+		.default_trigger	= "nand-disk",
+	},
+	{	/* "power" led, yellow (could be driven by pwm0) */
+		.name			= "ds3",
+		.gpio			= AT91_PIN_PB7,
+		.default_trigger	= "heartbeat",
+	}
+};
+
+/*
+ * PWM Leds
+ */
+static struct gpio_led skovarm9_pwm_led[] = {
+	/* For now only DS1 is PWM-driven (by pwm1) */
+	{
+		.name			= "buzzer",
+		.gpio			= 1,	// is PWM channel number
+		.active_low		= 1,
+		.default_trigger	= "none",
+	},
+	{
+		.name                   = "lcd_contrast",
+		.gpio                   = 2,    // is PWM channel number
+		.active_low             = 1,
+		.default_trigger        = "none",
+        },
+        {
+                .name                   = "lcd_bglight",
+                .gpio                   = 3,    // is PWM channel number
+                .active_low             = 1,
+                .default_trigger        = "none",
+        }
+};
+
+/*
+ * MATRIX KBD
+ */
+static struct matrix_kbd_data kbd_data = {
+        .pio_map_ret = {
+                [0] = { .pin = AT91_PIN_PB25, }, // 1
+                [1] = { .pin = AT91_PIN_PB21, }, // 2
+                [2] = { .pin = AT91_PIN_PB16, }, // 3
+                [3] = { .pin = AT91_PIN_PB24, }, // 4
+                [4] = { .pin = AT91_PIN_PB12, }, // 5
+        },
+        .pio_map_ret_len = 5,
+        .pio_map_scan = {
+                [0] = { .pin = AT91_PIN_PB13, }, // 1
+                [1] = { .pin = AT91_PIN_PB17, }, // 2
+                [2] = { .pin = AT91_PIN_PA25, }, // 3
+                [3] = { .pin = AT91_PIN_PA21, }, // 4
+                [4] = { .pin = AT91_PIN_PA19, }, // 5
+                [5] = { .pin = AT91_PIN_PA18, }, // 6
+        },
+        .pio_map_scan_len = 6,
+};
+
+/*
+ * ENCODER
+ */
+static struct encoder_data enc_data = {
+        .pio_map = {
+                [ENC_ENABLE]  = { .pin = AT91_PIN_PC20, }, // 1 not used
+                [ENC_LEFT]    = { .pin = AT91_PIN_PB19, }, //20 2
+                [ENC_RIGHT]   = { .pin = AT91_PIN_PB20, }, //21 3
+                [ENC_CONFIRM] = { .pin = AT91_PIN_PB15, }, //22 4
+        },
+        .pio_map_len = 4,
+};
+
+
+/*
+ * LED
+ */
+static struct led_dev_data led_data = {
+        .leds = {
+                [0] = { .dev_name = "led_0",    }, // 1
+                [1] = { .dev_name = "led_1",    }, // 2
+                [2] = { .dev_name = "led_2",    }, // 3
+                [3] = { .dev_name = "led_3",    }, // 4
+                [4] = { .dev_name = "led_4",    }, // 5
+                [5] = { .dev_name = "led_5",    }, // 6
+                [6] = { .dev_name = "led_6",    }, // 7
+                [7] = { .dev_name = "led_7",    }, // 8
+                [8] = { .dev_name = "led_DB0",  }, // 9
+                [9] = { .dev_name = "led_DB1",  }, // 10
+                [10]= { .dev_name = "led_DB2",  }, // 11
+        },
+        .pio_map = {
+                [0] = { .pin = AT91_PIN_PB14,   }, // 1
+                [1] = { .pin = AT91_PIN_PB23,   }, // 2
+                [2] = { .pin = AT91_PIN_PB18,   }, // 3
+                [3] = { .pin = AT91_PIN_PB22,   }, // 4
+                [4] = { .pin = AT91_PIN_PA22,   }, // 5
+                [5] = { .pin = AT91_PIN_PA23,   }, // 6
+                [6] = { .pin = AT91_PIN_PA24,   }, // 7
+                [7] = { .pin = AT91_PIN_PA20,   }, // 8
+                [8] = { .pin = AT91_PIN_PD0,    }, // 9
+                [9] = { .pin = AT91_PIN_PD1,    }, // 10
+                [10]= { .pin = AT91_PIN_PD7,    }, // 11
+        },
+        .led_len = 11,
+};
+
+/*
+ * LCD Controller
+ */
+static struct lcd_lc7981_data lc7981_data = {
+        .state  = 0,
+        .pio_map = {
+                [LCD_EN] = { .pin = AT91_PIN_PE8, },//  1
+                [LCD_RW] = { .pin = AT91_PIN_PE11,},//  2
+                [LCD_RS] = { .pin = AT91_PIN_PE12,},//  3
+                [LCD_CS] = { .pin = AT91_PIN_PE9, },//  4
+                [LCD_RST]= { .pin = AT91_PIN_PE13,},//  5
+
+                [LCD_B0] = { .pin = AT91_PIN_PE0, },//  6
+                [LCD_B1] = { .pin = AT91_PIN_PE1, },//  7
+                [LCD_B2] = { .pin = AT91_PIN_PE2, },//  8
+                [LCD_B3] = { .pin = AT91_PIN_PE3, },//  9
+                [LCD_B4] = { .pin = AT91_PIN_PE4, },// 10
+                [LCD_B5] = { .pin = AT91_PIN_PE5, },// 11
+                [LCD_B6] = { .pin = AT91_PIN_PE6, },// 12
+                [LCD_B7] = { .pin = AT91_PIN_PE7, },// 13
+        },
+        .pio_map_len = 13,
+};
+
+/*
+ * CAN
+ */
+static void sam9263ek_transceiver_switch(int on)
+{
+        if (on) {
+                at91_set_gpio_output(AT91_PIN_PA16, 1); /* CANRXEN */
+/* San Rose tristate the pin to reduce the eches */
+//                at91_set_gpio_output(AT91_PIN_PA17, 0); /* CANRS */
+		at91_set_gpio_input( AT91_PIN_PA17, 0 ); // set pin as input without pullup
+		at91_set_deglitch( AT91_PIN_PA17, 1 ); // enable glitch filter
+/* End San */
+        } else {
+                at91_set_gpio_output(AT91_PIN_PA16, 0); /* CANRXEN */
+                at91_set_gpio_output(AT91_PIN_PA17, 1); /* CANRS */
+        }
+}
+
+static struct at91_can_data skovarm9_can_data = {
+	.transceiver_switch = sam9263ek_transceiver_switch,
+};
+
+static struct bd_gpio_data gpio_data = {
+};
+
+static struct skov_gpio_data skov_gpio_data = {
+};
+
+/* --------------------------------------------------------------------
+ *  PWM
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_PWM_DEVICE) || defined(CONFIG_PWM_DEVICE_MODULE)
+
+static struct resource skov_pwm_resources[] = {
+    [0] = {
+        .start  = AT91SAM9263_BASE_PWMC,
+        .end    = AT91SAM9263_BASE_PWMC + SZ_16K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+};
+
+static struct platform_device skov_pwm_device = {
+    .name               = "pwm_device",
+    .id                 = -1,
+    .resource           = skov_pwm_resources,
+    .num_resources      = ARRAY_SIZE(skov_pwm_resources),
+};
+
+void __init at91_add_device_skov_pwm(struct skov_pwm_dev_data *data) {
+
+    if (!data) {
+        printk(KERN_ERR "Add pwm platform device failed ! (data = NULL)\n");
+        return;
+    }
+
+    skov_pwm_device.dev.platform_data = data;
+    platform_device_register(&skov_pwm_device);
+}
+#else
+void __init at91_add_device_skov_pwm(struct skov_pwm_dev_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  Matrix Keyboard
+ * -------------------------------------------------------------------- */
+#if defined(CONFIG_MATRIX_KBD_DEVICE) || defined(CONFIG_MATRIX_KBD_DEVICE_MODULE)
+
+static struct platform_device matrix_kbd_device = {
+        .name           = "matrix_kbd_device",
+        .id             = -1,
+        .num_resources  = 0,
+};
+
+void __init at91_add_device_matrix_kbd(struct matrix_kbd_data *data) {
+
+        unsigned      i = 0;
+        unsigned      pin;
+
+        if (!data) {
+                printk(KERN_ERR "Add Matrix Keyboard platform device failed ! (data = NULL)\n");
+                return;
+        }
+
+        for ( i=0; i < data->pio_map_scan_len; i++ ) {
+                pin = data->pio_map_scan[i].pin;
+                if ( pin > 0 ) {
+                        data->pio_map_scan[i].pio  = pin_to_controller( pin );
+                        data->pio_map_scan[i].mask = pin_to_mask( pin );
+                }
+                else {
+                        printk(KERN_ERR "Add Matrix Keyboard platform device failed ! (gpio pin configuration mismatch)\n");
+                        return;
+                }
+        }
+
+        for ( i=0; i < data->pio_map_ret_len; i++ ) {
+                pin = data->pio_map_ret[i].pin;
+                if ( pin > 0 ) {
+                        data->pio_map_ret[i].pio  = pin_to_controller( pin );
+                        data->pio_map_ret[i].mask = pin_to_mask( pin );
+                }
+                else {
+                        printk(KERN_ERR "Add Matrix Keyboard platform device failed ! (gpio pin configuration mismatch)\n");
+                        return;
+                }
+        }
+
+        data->keys_lock            = __SPIN_LOCK_UNLOCKED(old_style_spin_init);
+
+        matrix_kbd_device.dev.platform_data = data;
+        platform_device_register(&matrix_kbd_device);
+}
+#else
+void __init at91_add_device_matrix_kbd(struct matrix_kbd_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  Scroll wheel / Encoder
+ * -------------------------------------------------------------------- */
+#if defined(CONFIG_ENCODER_DEVICE) || defined(CONFIG_ENCODER_DEVICE_MODULE)
+
+static struct platform_device encoder_device = {
+        .name           = "encoder_device",
+        .id             = -1,
+        .num_resources  = 0,
+};
+
+void __init at91_add_device_encoder(struct encoder_data *data) {
+
+        unsigned      i = 0;
+        unsigned      pin;
+
+        if (!data) {
+                printk(KERN_ERR "Encoder: add platform device failed ! ( data == NULL )\n");
+                return;
+        }
+
+        for ( i=0; i < data->pio_map_len; i++ ) {
+                pin = data->pio_map[i].pin;
+                if ( pin > 0 ) {
+                        data->pio_map[i].pio  = pin_to_controller( pin );
+                        data->pio_map[i].mask = pin_to_mask( pin );
+                }
+                else {
+                        printk(KERN_ERR "Encoder: add platform device failed ! (gpio pin configuration mismatch)\n");
+                        return;
+                }
+        }
+
+        encoder_device.dev.platform_data = data;
+        platform_device_register(&encoder_device);
+}
+#else
+void __init at91_add_device_encoder(struct encoder_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  LED
+ * -------------------------------------------------------------------- */
+#if defined(CONFIG_LED_DEVICE) || defined(CONFIG_LED_DEVICE_MODULE)
+
+static struct platform_device led_device = {
+        .name           = "led_device",
+        .id             = -1,
+        .num_resources  = 0,
+};
+
+void __init at91_add_device_led(struct led_dev_data *data) {
+
+        int             i = 0;
+        unsigned int    pin;
+
+        if (!data) {
+                printk(KERN_ERR "LED: add platform device failed ! (data = NULL)\n");
+                return;
+        }
+
+        for ( i=0; i < data->led_len; i++ ) {
+                pin = data->pio_map[i].pin;
+                if ( pin > 0 ) {
+                        data->pio_map[i].pio  = pin_to_controller( pin );
+                        data->pio_map[i].mask = pin_to_mask( pin );
+                }
+                else {
+                        printk(KERN_ERR "LED: add platform device failed ! (gpio pin configuration mismatch)\n");
+                        return;
+                }
+        }
+
+        led_device.dev.platform_data = data;
+        platform_device_register(&led_device);
+}
+#else
+void __init at91_add_device_led(struct led_dev_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  LC7981 LCD Controller
+ * -------------------------------------------------------------------- */
+#if defined(CONFIG_LCD_LC7981_DEVICE) || defined(CONFIG_LCD_LC7981_DEVICE_MODULE)
+
+static struct platform_device lcd_lc7981_device = {
+        .name           = "lcd_lc7981_device",
+        .id             = -1,
+        .num_resources  = 0,
+};
+
+void __init at91_add_device_lc7981( struct lcd_lc7981_data *data)
+{
+        int i = 0;
+        unsigned pin = 0;
+        if (!data) {
+                printk(KERN_ERR "LC7981: add platform device failed ! (data = NULL)\n");
+                return;
+        }
+
+        for ( i=0; i < data->pio_map_len; i++ ) {
+                pin = data->pio_map[i].pin;
+                if ( pin > 0 ) {
+                        data->pio_map[i].pio  = pin_to_controller( pin );
+                        data->pio_map[i].mask = pin_to_mask( pin );
+                }
+                else {
+                        printk(KERN_ERR "LD7981: add platform device failed ! (gpio pin configuration mismatch)\n");
+                        return;
+                }
+        }
+
+        lcd_lc7981_device.dev.platform_data = data;
+        platform_device_register(&lcd_lc7981_device);
+}
+#else
+void __init at91_add_device_lc7981( struct lcd_lc7981_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  UnderVoltage LockOut
+ * -------------------------------------------------------------------- */
+#if defined(CONFIG_UNDER_VOLTAGE_DEVICE) || defined(CONFIG_UNDER_VOLTAGE_DEVICE_MODULE)
+
+static struct platform_device under_voltage_device = {
+        .name           = "under_voltage_device",
+        .id             = -1,
+        .num_resources  = 0,
+};
+
+void __init at91_add_device_under_voltage(struct under_voltage_data *data) {
+
+        if (!data) {
+                printk(KERN_ERR "Under_Voltage: add platform device failed ! ( data == NULL )\n");
+                return;
+        }
+
+        under_voltage_device.dev.platform_data = data;
+        platform_device_register(&under_voltage_device);
+}
+#else
+void __init at91_add_device_under_voltage(struct under_voltage_data *data) {}
+#endif
+
+/*
+ * San Rose Technology
+ */
+#if defined(CONFIG_BD_GPIO) || defined(CONFIG_BD_GPIO_MODULE)
+
+static struct platform_device bd_gpio_device = {
+        .name           = "bd_gpio",
+        .id             = -1,
+        .num_resources  = 0,
+};
+
+void __init at91_add_bd_gpio( struct bd_gpio_data *data) {
+	bd_gpio_device.dev.platform_data = data;
+	platform_device_register(&bd_gpio_device);
+}
+
+#endif
+
+#if defined(CONFIG_SKOV_GPIO) || defined(CONFIG_SKOV_GPIO_MODULE)
+
+static struct platform_device skov_gpio_device = {
+        .name           = "skov_gpio",
+        .id             = -1,
+        .num_resources  = 0,
+};
+
+void __init at91_add_skov_gpio( struct skov_gpio_data *data) {
+        skov_gpio_device.dev.platform_data = data;
+        platform_device_register(&skov_gpio_device);
+}
+
+#endif
+/* End San */
+
+
+static void __init skovarm9_board_init(void)
+{
+        struct clk *mck;
+	/* Serial */
+	at91_add_device_serial();
+	/* USB Host */
+	at91_add_device_usbh(&skovarm9_usbh_data);
+	/* USB Device */
+	at91_add_device_udc(&skovarm9_udc_data);
+	/* SPI */
+	at91_set_gpio_output(AT91_PIN_PE20, 1);		/* select spi0 clock */
+	at91_add_device_spi(skovarm9_spi_devices, ARRAY_SIZE(skovarm9_spi_devices));
+	/* Touchscreen */
+	skovarm9_add_device_ts();
+	/* MMC */
+	at91_add_device_mmc(1, &skovarm9_mmc_data);
+	/* Ethernet */
+	at91_add_device_eth(&skovarm9_macb_data);
+	/* NAND */
+	skovarm9_add_device_nand();
+	/* I2C */
+	at91_add_device_i2c(skovarm9_i2c_devices, ARRAY_SIZE(skovarm9_i2c_devices));
+        /* LCD Controller */
+        //ROSE/MAB: Added check to see if rev 2 of interface board is used, thus using the Logic Technology display
+        at91_set_gpio_input( AT91_PIN_PD2, 1 );
+        udelay(20); //make dure the pin is set up correctly before reading it
+        if (at91_get_gpio_value(AT91_PIN_PD2)) {
+                //This is the old interface board, as the pin is NC (using Seiko display)
+                // Do nothing it is setup this way by default.
+        }
+        else {
+                //This is the new interface board, as the pin is pulled down (using Logic display)
+                skovarm9_lcdc_data.default_monspecs = &at91fb_default_monspecs_logic;
+                mck = clk_get( 0, "mck" );
+                if ( IS_ERR( mck ) )
+                {
+                        printk( "no clock defined" );
+                }
+                else
+                {
+                        if (clk_get_rate(mck) == 120000000)
+                        {
+                                skovarm9_lcdc_data.default_monspecs = &at91fb_default_monspecs_logic_240;
+                        }
+                }
+        }
+	at91_add_device_lcdc(&skovarm9_lcdc_data);
+	/* Push Buttons */
+	skovarm9_add_device_buttons();
+	/* AC97 */
+	at91_add_device_ac97(&skovarm9_ac97_data);
+	/* LEDs */
+	at91_gpio_leds(skovarm9_leds, ARRAY_SIZE(skovarm9_leds));
+	at91_pwm_leds(skovarm9_pwm_led, ARRAY_SIZE(skovarm9_pwm_led));
+	/* CAN */
+	at91_add_device_can(&skovarm9_can_data);
+	/* Under Voltage */
+        at91_add_device_under_voltage(&uv_data);
+        /* PWM for LCD backlight and contrast */
+        at91_add_device_skov_pwm(&skov_pwm_data);
+        /* LCD Controller */
+        at91_add_device_lc7981(&lc7981_data);
+        /* Matrix Keyboard */
+	at91_add_device_matrix_kbd(&kbd_data);
+	/* Scroll wheel / Encoder */
+	at91_add_device_encoder(&enc_data);
+        /* LEDs */
+        at91_add_device_led(&led_data);
+        /* BD GPIO */
+	at91_add_bd_gpio(&gpio_data);
+	/* SKOV GPIO */
+        at91_add_skov_gpio(&skov_gpio_data);
+}
+
+MACHINE_START(AT91SAM9263EK, "Atmel AT91SAM9263-EK")
+	/* Maintainer: Atmel */
+	.timer		= &at91sam926x_timer,
+	.map_io		= at91_map_io,
+	.init_early	= skovarm9_init_early,
+	.init_irq	= at91_init_irq_default,
+	.init_machine	= skovarm9_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-at91/clock.c b/arch/arm/mach-at91/clock.c
index 61873f3..85c88d3 100644
--- a/arch/arm/mach-at91/clock.c
+++ b/arch/arm/mach-at91/clock.c
@@ -769,6 +769,9 @@ static int __init at91_clock_reset(void)
 
 		pr_debug("Clocks: disable unused %s\n", clk->name);
 	}
+	/* San Rose */
+	pcdr = 34048000; // Disable only the peripheral we dont use
+	/* End San  */
 
 	at91_sys_write(AT91_PMC_PCDR, pcdr);
 	at91_sys_write(AT91_PMC_SCDR, scdr);
diff --git a/arch/arm/mach-at91/include/mach/board.h b/arch/arm/mach-at91/include/mach/board.h
index eac92e9..d9112dc 100644
--- a/arch/arm/mach-at91/include/mach/board.h
+++ b/arch/arm/mach-at91/include/mach/board.h
@@ -213,4 +213,85 @@ extern void __init at91_pwm_leds(struct gpio_led *leds, int nr);
 /* FIXME: this needs a better location, but gets stuff building again */
 extern int at91_suspend_entering_slow_clock(void);
 
+/* Under Voltage Lock Out */
+struct under_voltage_data {
+        u8              pin;
+};
+
+/* PWM */
+#define PWM_MAX 4
+struct skov_pwm {
+        unsigned        state;
+        unsigned        startup;
+        unsigned        id;
+        unsigned        period;
+        unsigned        start_offset;
+        unsigned        end_offset;
+        unsigned        duty_cycle;
+        unsigned char   dev_name[13];
+        unsigned char   periph;
+        unsigned        pin;
+        unsigned        pre_scaler;
+};
+
+struct skov_pwm_dev_data {
+        short                pwm_len;
+        struct skov_pwm      pwms[PWM_MAX];
+};
+
+/* GPIO Map */
+struct gpio_pin_pio_map {
+        unsigned int    pin;
+        void __iomem    *pio;
+        unsigned int    mask;
+};
+
+/* Matrix keyboard */
+#define KBD_MAX_SCAN_PIO        10
+#define KBD_MAX_RET_PIO         10
+
+struct matrix_kbd_data {
+        spinlock_t              keys_lock;
+        short                   pio_map_scan_len;
+        short                   pio_map_ret_len;
+        struct gpio_pin_pio_map pio_map_scan[KBD_MAX_SCAN_PIO];
+        struct gpio_pin_pio_map pio_map_ret[KBD_MAX_RET_PIO];
+};
+
+/* Encoder (Scroll Wheel) */
+#define ENC_MAX_PIO     4
+
+struct encoder_data {
+        short                   pio_map_len;
+        struct gpio_pin_pio_map pio_map[ENC_MAX_PIO];
+};
+
+/* LED's */
+#define LED_MAX_PIO     11
+
+struct led {
+        short           state;
+        int             speed;
+        unsigned char   dev_name[13];
+};
+
+struct led_dev_data {
+        short                   led_len;
+        struct led              leds[LED_MAX_PIO];
+        struct gpio_pin_pio_map pio_map[LED_MAX_PIO];
+};
+
+/* LCD cl7981 Data */
+struct lcd_lc7981_data {
+        short                   state; // 0 off , 1 on
+        short                   pio_map_len;
+        struct gpio_pin_pio_map pio_map[24];
+};
+
+struct bd_gpio_data {
+};
+
+struct skov_gpio_data {
+};
+
 #endif
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index ccbe16f..37ff1d0 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -225,6 +225,7 @@ vstms			MACH_VSTMS		VSTMS			1140
 micro9m			MACH_MICRO9M		MICRO9M			1169
 bug			MACH_BUG		BUG			1179
 at91sam9263ek		MACH_AT91SAM9263EK	AT91SAM9263EK		1202
+skovarm9cpu		MACH_SKOVARM9CPU	SKOVARM9CPU		1203
 em7210			MACH_EM7210		EM7210			1212
 vpac270			MACH_VPAC270		VPAC270			1227
 treo680			MACH_TREO680		TREO680			1230
-- 
1.8.3.1

