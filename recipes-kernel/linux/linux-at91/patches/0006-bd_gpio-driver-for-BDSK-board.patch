From 2e7b2faa46d1f912b2e888fb6e96e06e4f9bb374 Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Sun, 1 Jan 2017 10:55:01 +0100
Subject: [PATCH] bd_gpio: driver for BDSK board

---
 drivers/Kconfig      |   2 +
 drivers/Makefile     |   4 +
 drivers/bd/Kconfig   |  13 ++
 drivers/bd/Makefile  |   5 +
 drivers/bd/bd_gpio.c | 570 +++++++++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 594 insertions(+)
 create mode 100644 drivers/bd/Kconfig
 create mode 100644 drivers/bd/Makefile
 create mode 100644 drivers/bd/bd_gpio.c

diff --git a/drivers/Kconfig b/drivers/Kconfig
index b5e6f24..34460e0 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -136,4 +136,6 @@ source "drivers/hv/Kconfig"
 
 source "drivers/devfreq/Kconfig"
 
+source "drivers/bd/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 1b31421..da20d1f 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -34,6 +34,10 @@ obj-$(CONFIG_REGULATOR)		+= regulator/
 obj-y				+= tty/
 obj-y				+= char/
 
+# Rose Technology
+obj-y                           += bd/
+# End Rose
+
 # gpu/ comes after char for AGP vs DRM startup
 obj-y				+= gpu/
 
diff --git a/drivers/bd/Kconfig b/drivers/bd/Kconfig
new file mode 100644
index 0000000..3b80ef6
--- /dev/null
+++ b/drivers/bd/Kconfig
@@ -0,0 +1,13 @@
+#
+# BD drivers
+#
+
+menu "BD Drivers"
+
+config BD_GPIO
+        tristate "BD GPIO"
+        default m
+        help
+          Driver for gpio signals on BD board.
+
+endmenu
diff --git a/drivers/bd/Makefile b/drivers/bd/Makefile
new file mode 100644
index 0000000..06e981c
--- /dev/null
+++ b/drivers/bd/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile BD board
+#
+
+obj-$(CONFIG_BD_GPIO)         += bd_gpio.o
diff --git a/drivers/bd/bd_gpio.c b/drivers/bd/bd_gpio.c
new file mode 100644
index 0000000..5d629ea
--- /dev/null
+++ b/drivers/bd/bd_gpio.c
@@ -0,0 +1,570 @@
+/*
+ * BD GPIO Driver
+ * San Rose technology
+ */
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/stat.h>
+#include <asm/uaccess.h>
+#include <linux/export.h>
+#include <linux/module.h>
+
+#ifdef	CONFIG_ARM
+#include <asm/mach-types.h>
+#endif
+
+#define PIN_NMI		AT91_PIN_PE17
+#define PIN_POWER_GOOD  AT91_PIN_PE15
+#define PIN_POWER_FAIL  AT91_PIN_PD4
+#define PIN_SW1		AT91_PIN_PB1
+#define PIN_SW2         AT91_PIN_PB2
+#define PIN_DCD0	AT91_PIN_PA31
+
+#define PIN_SAVE_DONE	AT91_PIN_PE16
+#define PIN_LED		AT91_PIN_PB0
+#define PIN_A7_FIQ      AT91_PIN_PC28
+#define PIN_DLED0	AT91_PIN_PE0
+#define PIN_DLED1       AT91_PIN_PE1
+#define PIN_DLED2       AT91_PIN_PE2
+
+#define PIN_AUX1	AT91_PIN_PE8
+#define PIN_AUX2        AT91_PIN_PE9
+#define PIN_AUX3        AT91_PIN_PE11
+#define PIN_AUX4        AT91_PIN_PB8
+
+#define BDIO_NAME "BDIO"
+#define err( fmt, arg... ) printk( KERN_ERR "%s: %s() " fmt "\n" , BDIO_NAME, __FUNCTION__, ## arg )
+
+#define SHOW0(name) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	int val; \
+	if(at91_get_gpio_value(PIN_NMI) == 1) { \
+		val = 1; \
+	} else { \
+		val = 0; \
+	} \
+	return sprintf( buf, "%i\n", val); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+SHOW0(NMI)
+
+#define SHOW1(name) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	int val; \
+	if(at91_get_gpio_value(PIN_POWER_GOOD) == 1) { \
+		val = 1; \
+	} else { \
+	        val = 0; \
+	} \
+	return sprintf( buf, "%i\n", val); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+SHOW1(PowerGood)
+
+#define SHOW2(name) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+        int val; \
+        if(at91_get_gpio_value(PIN_POWER_FAIL) == 1) { \
+		val = 1; \
+        } else { \
+                val = 0; \
+        } \
+        return sprintf( buf, "%i\n", val); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+SHOW2(PowerFail)
+
+
+#define SHOW3(name) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	int val; \
+	if(at91_get_gpio_value(PIN_SW1) == 1) { \
+	        val = 1; \
+	} else { \
+	        val = 0; \
+	} \
+	return sprintf( buf, "%i\n", val); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+SHOW3(SW1)
+
+#define SHOW4(name) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	int val; \
+	if(at91_get_gpio_value(PIN_SW2) == 1) { \
+	        val = 1; \
+	} else { \
+	        val = 0; \
+	} \
+	return sprintf( buf, "%i\n", val); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+SHOW4(SW2)
+
+#define SHOW5(name) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	int val; \
+        if(at91_get_gpio_value(PIN_DCD0) == 1) { \
+		val = 1; \
+        } else { \
+                val = 0; \
+        } \
+        return sprintf( buf, "%i\n", val); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+SHOW5(DCD0)
+
+#define SET1(name) static ssize_t \
+name ## _set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+	int len = strlen(buf); \
+	if(buf[len-1] == '\n') { \
+		len --; \
+	} \
+	if(buf[0] == '1') { \
+              at91_set_gpio_value(PIN_SAVE_DONE, 1); \
+        } \
+        else if(buf[0] == '0') { \
+              at91_set_gpio_value(PIN_SAVE_DONE, 0); \
+        } \
+        else { \
+              err("invalid value accept 0 or 1!"); \
+	} \
+	return strlen(buf); \
+} \
+static DEVICE_ATTR(name, S_IWUSR, NULL, name ## _set);
+
+SET1(SaveDone)
+
+#define SET2(name) static ssize_t \
+name ## _set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+	int len = strlen(buf); \
+        if(buf[len-1] == '\n') { \
+		len --; \
+        } \
+        if(buf[0] == '1') \
+               at91_set_gpio_value(PIN_LED, 1); \
+        else if(buf[0] == '0') \
+               at91_set_gpio_value(PIN_LED, 0); \
+        else \
+               err("invalid value accept 0 or 1!"); \
+        return strlen(buf); \
+} \
+static DEVICE_ATTR(name, S_IWUSR, NULL, name ## _set);
+
+SET2(LED)
+
+#define SET3(name) static ssize_t \
+name ## _set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+        int len = strlen(buf); \
+        if(buf[len-1] == '\n') { \
+                len --; \
+        } \
+        if(buf[0] == '1') \
+               at91_set_gpio_value(PIN_A7_FIQ, 1); \
+        else if(buf[0] == '0') \
+               at91_set_gpio_value(PIN_A7_FIQ, 0); \
+        else \
+               err("invalid value accept 0 or 1!"); \
+        return strlen(buf); \
+} \
+static DEVICE_ATTR(name, S_IWUSR, NULL, name ## _set);
+
+SET3(A7_FIQ)
+
+#define SET4(name) static ssize_t \
+name ## _set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+        int len = strlen(buf); \
+	if(buf[len-1] == '\n') { \
+                len --; \
+        } \
+        if(buf[0] == '1') \
+               at91_set_gpio_value(PIN_DLED0, 1); \
+        else if(buf[0] == '0') \
+               at91_set_gpio_value(PIN_DLED0, 0); \
+        else \
+               err("invalid value accept 0 or 1!"); \
+        return strlen(buf); \
+} \
+static DEVICE_ATTR(name, S_IWUSR, NULL, name ## _set);
+
+SET4(DLED0)
+
+#define SET5(name) static ssize_t \
+name ## _set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+	int len = strlen(buf); \
+        if(buf[len-1] == '\n') { \
+                len --; \
+        } \
+        if(buf[0] == '1') \
+               at91_set_gpio_value(PIN_DLED1, 1); \
+        else if(buf[0] == '0') \
+               at91_set_gpio_value(PIN_DLED1, 0); \
+        else \
+               err("invalid value accept 0 or 1!"); \
+        return strlen(buf); \
+} \
+static DEVICE_ATTR(name, S_IWUSR, NULL, name ## _set);
+
+SET5(DLED1)
+
+#define SET6(name) static ssize_t \
+name ## _set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) \
+{ \
+	int len = strlen(buf); \
+        if(buf[len-1] == '\n') { \
+                len --; \
+        } \
+        if(buf[0] == '1') \
+               at91_set_gpio_value(PIN_DLED2, 1); \
+        else if(buf[0] == '0') \
+               at91_set_gpio_value(PIN_DLED2, 0); \
+        else \
+               err("invalid value accept 0 or 1!"); \
+        return strlen(buf); \
+} \
+static DEVICE_ATTR(name, S_IWUSR, NULL, name ## _set);
+
+SET6(DLED2)
+
+static ssize_t aux1_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+        unsigned int val;
+        if(at91_get_gpio_value(PIN_AUX1) == 1) {
+		val = 1;
+        } else {
+                val = 0;
+        }
+        return sprintf( buf, "%u\n", val);
+}
+
+static ssize_t aux1_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int len = strlen(buf);
+        if(buf[len-1] == '\n') {
+                len --;
+        }
+        if(buf[0] == '1') {
+	       at91_set_gpio_value(PIN_AUX1, 1);
+        }
+        else if(buf[0] == '0') {
+               at91_set_gpio_value(PIN_AUX1, 0);
+        }
+        else if(buf[0] == 'O') {
+		at91_set_gpio_output(PIN_AUX1, 0);
+		at91_set_multi_drive(PIN_AUX1, 0);
+        }
+        else if(buf[0] == 'I') {
+		at91_set_gpio_input(PIN_AUX1, 0);
+		at91_set_deglitch(PIN_AUX1, 0);
+        }
+        else {
+               err("invalid value accept 0,1,I,O!");
+        }
+        return strlen(buf);
+}
+static DEVICE_ATTR(AUX1, S_IRUGO | S_IWUSR, aux1_read, aux1_write);
+
+static ssize_t aux2_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+        int val;
+        if(at91_get_gpio_value(PIN_AUX2) == 1) {
+                val = 1;
+        } else {
+		val = 0;
+        }
+        return sprintf( buf, "%i\n", val);
+}
+
+static ssize_t aux2_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int len = strlen(buf);
+        if(buf[len-1] == '\n') {
+                len --;
+        }
+        if(buf[0] == '1') {
+               at91_set_gpio_value(PIN_AUX2, 1);
+        }
+        else if(buf[0] == '0') {
+               at91_set_gpio_value(PIN_AUX2, 0);
+        }
+        else if(buf[0] == 'O') {
+                at91_set_gpio_output(PIN_AUX2, 0);
+                at91_set_multi_drive(PIN_AUX2, 0);
+        }
+        else if(buf[0] == 'I') {
+                at91_set_gpio_input(PIN_AUX2, 0);
+                at91_set_deglitch(PIN_AUX2, 0);
+        }
+        else {
+               err("invalid value accept 0,1,I,O!");
+        }
+        return strlen(buf);
+}
+static DEVICE_ATTR(AUX2, S_IRUGO | S_IWUSR, aux2_read, aux2_write);
+
+static ssize_t aux3_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+        unsigned int val;
+        if(at91_get_gpio_value(PIN_AUX3) == 1) {
+                val = 1;
+        } else {
+                val = 0;
+        }
+        return sprintf( buf, "%u\n", val);
+}
+
+static ssize_t aux3_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int len = strlen(buf);
+        if(buf[len-1] == '\n') {
+                len --;
+        }
+        if(buf[0] == '1') {
+               at91_set_gpio_value(PIN_AUX3, 1);
+        }
+        else if(buf[0] == '0') {
+               at91_set_gpio_value(PIN_AUX3, 0);
+        }
+        else if(buf[0] == 'O') {
+                at91_set_gpio_output(PIN_AUX3, 0);
+                at91_set_multi_drive(PIN_AUX3, 0);
+        }
+        else if(buf[0] == 'I') {
+                at91_set_gpio_input(PIN_AUX3, 0);
+                at91_set_deglitch(PIN_AUX3, 0);
+        }
+        else {
+               err("invalid value accept 0,1,I,O!");
+        }
+        return strlen(buf);
+}
+static DEVICE_ATTR(AUX3, S_IRUGO | S_IWUSR, aux3_read, aux3_write);
+
+static ssize_t aux4_read(struct device *dev, struct device_attribute *attr, char *buf)
+{
+        unsigned int val;
+        if(at91_get_gpio_value(PIN_AUX4) == 1) {
+                val = 1;
+        } else {
+                val = 0;
+        }
+        return sprintf( buf, "%u\n", val);
+}
+
+static ssize_t aux4_write(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int len = strlen(buf);
+        if(buf[len-1] == '\n') {
+                len --;
+        }
+        if(buf[0] == '1') {
+               at91_set_gpio_value(PIN_AUX4, 1);
+        }
+        else if(buf[0] == '0') {
+               at91_set_gpio_value(PIN_AUX4, 0);
+        }
+        else if(buf[0] == 'O') {
+                at91_set_gpio_output(PIN_AUX4, 0);
+                at91_set_multi_drive(PIN_AUX4, 0);
+        }
+        else if(buf[0] == 'I') {
+                at91_set_gpio_input(PIN_AUX4, 0);
+                at91_set_deglitch(PIN_AUX4, 0);
+        }
+        else {
+               err("invalid value accept 0,1,I,O!");
+        }
+        return strlen(buf);
+}
+static DEVICE_ATTR(AUX4, S_IRUGO | S_IWUSR, aux4_read, aux4_write);
+
+#define SHOW_ALL(name) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+        int val; \
+        if(at91_get_gpio_value(PIN_NMI) == 1) { \
+                val = 1; \
+        } else { \
+                val = 0; \
+        } \
+        if(at91_get_gpio_value(PIN_POWER_GOOD) == 1) { \
+		val += 2 ; \
+	} else { \
+		val = val; \
+	} \
+	if(at91_get_gpio_value(PIN_POWER_FAIL) == 1) { \
+		val += 4; \
+	} else { \
+	        val = val; \
+	} \
+	if(at91_get_gpio_value(PIN_SW1) == 1) { \
+	        val += 8; \
+	} else { \
+	        val = val; \
+	} \
+	if(at91_get_gpio_value(PIN_SW2) == 1) { \
+		val += 16; \
+        } else { \
+                val = val; \
+        } \
+	if(at91_get_gpio_value(PIN_AUX1) == 1) { \
+                val += 32; \
+        } else { \
+                val = val; \
+        } \
+	if(at91_get_gpio_value(PIN_AUX2) == 1) { \
+		val += 64; \
+	} else { \
+		val = val; \
+        } \
+	if(at91_get_gpio_value(PIN_AUX3) == 1) { \
+		val += 128; \
+        } else { \
+                val = val; \
+        } \
+	if(at91_get_gpio_value(PIN_AUX4) == 1) { \
+		val += 256; \
+        } else { \
+                val = val; \
+        } \
+        if(at91_get_gpio_value(PIN_DCD0) == 1) { \
+		val += 512; \
+        } else { \
+                val = val; \
+        } \
+        return sprintf( buf, "%i\n", val); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+SHOW_ALL(input_parallel)
+
+
+static int __devinit bd_gpio_probe( struct platform_device *pdev )
+{
+	int err;
+	/* Input */
+	at91_set_gpio_input(PIN_NMI, 0);
+	at91_set_gpio_input(PIN_POWER_GOOD, 0);
+	at91_set_gpio_input(PIN_POWER_FAIL, 0);
+	at91_set_gpio_input(PIN_SW1, 0);
+	at91_set_gpio_input(PIN_SW2, 0);
+	at91_set_gpio_input(PIN_DCD0, 0);
+	at91_set_deglitch(PIN_NMI, 0);
+	at91_set_deglitch(PIN_POWER_GOOD, 0);
+	at91_set_deglitch(PIN_POWER_FAIL, 0);
+	at91_set_deglitch(PIN_SW1, 0);
+	at91_set_deglitch(PIN_SW2, 0);
+	at91_set_deglitch(PIN_DCD0, 0);
+	/* Output */
+	at91_set_gpio_output(PIN_SAVE_DONE, 0);
+	at91_set_gpio_output(PIN_LED, 0);
+	at91_set_gpio_output(PIN_A7_FIQ, 0);
+	at91_set_gpio_output(PIN_DLED0, 0);
+	at91_set_gpio_output(PIN_DLED1, 0);
+	at91_set_gpio_output(PIN_DLED2, 0);
+	at91_set_multi_drive(PIN_SAVE_DONE, 0);
+	at91_set_multi_drive(PIN_LED, 0);
+	at91_set_multi_drive(PIN_A7_FIQ, 0);
+	at91_set_multi_drive(PIN_DLED0, 0);
+	at91_set_multi_drive(PIN_DLED1, 0);
+	at91_set_multi_drive(PIN_DLED2, 0);
+	/* AUX */
+	at91_set_gpio_input(PIN_AUX1, 0);
+	at91_set_gpio_input(PIN_AUX2, 0);
+	at91_set_gpio_input(PIN_AUX3, 0);
+	at91_set_gpio_input(PIN_AUX4, 0);
+
+        /* input */
+        err = device_create_file(&pdev->dev, &dev_attr_NMI);
+        err = device_create_file(&pdev->dev, &dev_attr_PowerGood);
+        err = device_create_file(&pdev->dev, &dev_attr_PowerFail);
+        err = device_create_file(&pdev->dev, &dev_attr_SW1);
+        err = device_create_file(&pdev->dev, &dev_attr_SW2);
+        err = device_create_file(&pdev->dev, &dev_attr_DCD0);
+        /* output */
+        err = device_create_file(&pdev->dev, &dev_attr_SaveDone);
+        err = device_create_file(&pdev->dev, &dev_attr_LED);
+        err = device_create_file(&pdev->dev, &dev_attr_A7_FIQ);
+        err = device_create_file(&pdev->dev, &dev_attr_DLED0);
+        err = device_create_file(&pdev->dev, &dev_attr_DLED1);
+        err = device_create_file(&pdev->dev, &dev_attr_DLED2);
+        /* AUX */
+        err = device_create_file(&pdev->dev, &dev_attr_AUX1);
+        err = device_create_file(&pdev->dev, &dev_attr_AUX2);
+        err = device_create_file(&pdev->dev, &dev_attr_AUX3);
+        err = device_create_file(&pdev->dev, &dev_attr_AUX4);
+        /* Show all input */
+        err = device_create_file(&pdev->dev, &dev_attr_input_parallel);
+
+        return err;
+}
+
+static int __devexit bd_gpio_remove(struct platform_device *pdev)
+{
+	device_remove_file(&pdev->dev, &dev_attr_NMI);
+	device_remove_file(&pdev->dev, &dev_attr_PowerGood);
+	device_remove_file(&pdev->dev, &dev_attr_PowerFail);
+	device_remove_file(&pdev->dev, &dev_attr_SW1);
+	device_remove_file(&pdev->dev, &dev_attr_SW2);
+	device_remove_file(&pdev->dev, &dev_attr_DCD0);
+	device_remove_file(&pdev->dev, &dev_attr_SaveDone);
+	device_remove_file(&pdev->dev, &dev_attr_LED);
+	device_remove_file(&pdev->dev, &dev_attr_A7_FIQ);
+	device_remove_file(&pdev->dev, &dev_attr_DLED0);
+	device_remove_file(&pdev->dev, &dev_attr_DLED1);
+	device_remove_file(&pdev->dev, &dev_attr_DLED2);
+	device_remove_file(&pdev->dev, &dev_attr_AUX1);
+	device_remove_file(&pdev->dev, &dev_attr_AUX2);
+	device_remove_file(&pdev->dev, &dev_attr_AUX3);
+	device_remove_file(&pdev->dev, &dev_attr_AUX4);
+	device_remove_file(&pdev->dev, &dev_attr_input_parallel);
+	return 0;
+}
+
+struct platform_driver bd_gpio_driver =
+{
+        .remove         = __exit_p( bd_gpio_remove ),
+	.probe          = bd_gpio_probe,
+        .driver         = {
+                .name   = "bd_gpio",
+                .owner  = THIS_MODULE,
+        }
+};
+
+
+static int __init bd_gpio_init(void)
+{
+	return platform_driver_register( &bd_gpio_driver );
+}
+
+static void __exit bd_gpio_exit(void)
+{
+	platform_driver_unregister( &bd_gpio_driver );
+}
+
+module_init(bd_gpio_init);
+module_exit(bd_gpio_exit);
+
+MODULE_DESCRIPTION("BD GPIO driver");
+MODULE_LICENSE("GPL");
+
-- 
1.8.3.1

