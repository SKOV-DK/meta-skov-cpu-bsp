From: =?UTF-8?q?Ulrich=20=C3=96lmann?= <u.oelmann@pengutronix.de>
Date: Fri, 13 Nov 2015 10:12:01 +0100
Subject: [PATCH] Skov: add support for base platform and board variants 19 &
 20
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The Skov platform potentially consists of many variants of CPUs (i.MX6S/DL and
i.MX6D/Q), NAND memories (size differs from 256 MiB to 8 GiB) and populated
SDRAM (256 MiB up to 2 GiB). All these variants share one PCB.

The devicetrees are based upon the original Skov/AS IMX6 trees and have been
modified in a way that all needed hardware (SD card, RTC, switch, display panel
etc.) is operational. Some bootstrap resistors are provided which decode the
variant and which allow for it's detection at runtime. This information is
needed to choose the bootspec entry with the matching devicetree to boot the
system. Based upon this mechanism usage of a single Barebox image and Linux root
filesystem for all known board variants is made possible.

Signed-off-by: Ulrich Ölmann <u.oelmann@pengutronix.de>
Signed-off-by: Juergen Borleis <jbe@pengutronix.de>
Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
Signed-off-by: Søren Andersen <san@skov.dk>
[Note: this commit results of squashing commits v4.4..4f1fe9dae5c0]
---
 .../panel/logictechnologies,lttd800480070-l2rt.txt |   7 +
 .../devicetree/bindings/vendor-prefixes.txt        |   1 +
 arch/arm/boot/dts/Makefile                         |   1 +
 arch/arm/boot/dts/imx6dl-skov-imx6-revC.dts        |  23 +
 arch/arm/boot/dts/imx6q-skov-imx6-revC.dts         |  36 ++
 arch/arm/boot/dts/imx6qdl-cpu.dtsi                 | 662 +++++++++++++++++++++
 arch/arm/boot/dts/imx6qdl-cpuC.dtsi                |  80 +++
 drivers/Kconfig                                    |   2 +
 drivers/Makefile                                   |   1 +
 drivers/gpu/drm/imx/ipuv3-crtc.c                   |   2 +-
 drivers/gpu/drm/panel/panel-simple.c               |  38 ++
 drivers/rtc/rtc-pcf85063.c                         |  40 ++
 drivers/skov/Kconfig                               |  18 +
 drivers/skov/Makefile                              |   2 +
 drivers/skov/mem_peek.c                            | 163 +++++
 drivers/skov/skov_version.c                        | 305 ++++++++++
 16 files changed, 1380 insertions(+), 1 deletion(-)
 create mode 100644 Documentation/devicetree/bindings/panel/logictechnologies,lttd800480070-l2rt.txt
 create mode 100644 arch/arm/boot/dts/imx6dl-skov-imx6-revC.dts
 create mode 100644 arch/arm/boot/dts/imx6q-skov-imx6-revC.dts
 create mode 100644 arch/arm/boot/dts/imx6qdl-cpu.dtsi
 create mode 100644 arch/arm/boot/dts/imx6qdl-cpuC.dtsi
 create mode 100644 drivers/skov/Kconfig
 create mode 100644 drivers/skov/Makefile
 create mode 100644 drivers/skov/mem_peek.c
 create mode 100644 drivers/skov/skov_version.c

diff --git a/Documentation/devicetree/bindings/panel/logictechnologies,lttd800480070-l2rt.txt b/Documentation/devicetree/bindings/panel/logictechnologies,lttd800480070-l2rt.txt
new file mode 100644
index 000000000000..ed05dc15cb97
--- /dev/null
+++ b/Documentation/devicetree/bindings/panel/logictechnologies,lttd800480070-l2rt.txt
@@ -0,0 +1,7 @@
+Logic Technologies LTTD800480070-L2RT 7.0" WVGA TFT LCD panel
+
+Required properties:
+- compatible: should be "logictechnologies,lttd800480070-l2rt"
+
+This binding is compatible with the simple-panel binding, which is specified
+in simple-panel.txt in this directory.
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.txt b/Documentation/devicetree/bindings/vendor-prefixes.txt
index 55df1d444e9f..d4e9037932ee 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.txt
+++ b/Documentation/devicetree/bindings/vendor-prefixes.txt
@@ -130,6 +130,7 @@ lg	LG Corporation
 linux	Linux-specific binding
 lsi	LSI Corp. (LSI Logic)
 lltc	Linear Technology Corporation
+logictechnologies	Logic Technologies Ltd.
 marvell	Marvell Technology Group Ltd.
 maxim	Maxim Integrated Products
 mediatek	MediaTek Inc.
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 30bbc3746130..b7c7cd9a72e6 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -331,6 +331,8 @@ dtb-$(CONFIG_SOC_IMX6Q) += \
 	imx6q-sabrelite.dtb \
 	imx6q-sabresd.dtb \
 	imx6q-sbc6x.dtb \
+	imx6q-skov-imx6-revC.dtb \
+	imx6q-skov-imx6-revC6L.dtb \
 	imx6q-tbs2910.dtb \
 	imx6q-tx6q-1010.dtb \
 	imx6q-tx6q-1010-comtft.dtb \
diff --git a/arch/arm/boot/dts/imx6dl-skov-imx6-revC.dts b/arch/arm/boot/dts/imx6dl-skov-imx6-revC.dts
new file mode 100644
index 000000000000..a7333f06f932
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-skov-imx6-revC.dts
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 Rose Technology
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "imx6dl.dtsi"
+#include "imx6qdl-cpu.dtsi"
+#include "imx6qdl-cpuC.dtsi"
+
+/ {
+	model = "Freescale i.MX6 SKOV Solo Board";
+	compatible = "skov,imx6-imxdl-revC", "skov,imx6", "fsl,imx6dl";
+};
diff --git a/arch/arm/boot/dts/imx6q-skov-imx6-revC.dts b/arch/arm/boot/dts/imx6q-skov-imx6-revC.dts
new file mode 100644
index 000000000000..81730c79fd0c
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-skov-imx6-revC.dts
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 Rose Technology
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "imx6q.dtsi"
+#include "imx6qdl-cpu.dtsi"
+#include "imx6qdl-cpuC.dtsi"
+
+/ {
+	model = "Freescale i.MX6 SKOV Quad Board";
+	compatible = "skov,imx6-imxq-revC", "skov,imx6", "fsl,imx6q";
+};
+
+&sata {
+	status = "disabled";
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+	ddc-i2c-bus = <&i2c2>;
+};
diff --git a/arch/arm/boot/dts/imx6qdl-cpu.dtsi b/arch/arm/boot/dts/imx6qdl-cpu.dtsi
new file mode 100644
index 000000000000..f6d8d65252dc
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qdl-cpu.dtsi
@@ -0,0 +1,662 @@
+/*
+ * Copyright 2014 Rose Technology.
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	chosen {
+		stdout-path = &uart2;
+	};
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	aliases {
+		can0 = &can1;
+		can1 = &can2;
+		led0 = &led0;
+		led1 = &led1;
+		led2 = &led2;
+		nand = &gpmi;
+		usb0 = &usbh1;
+		usb1 = &usbotg;
+		rtc0 = &i2c_rtc;
+		rtc1 = &snvs;
+	        mdio-gpio0 = &mdio0;
+		micrel-smi0 = &micrel0;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led0: D1 {
+			label = "D1";
+			gpios = <&gpio1 2 0>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+
+		led1: D2 {
+			label = "D2";
+			gpios = <&gpio1 0 0>;
+			default-state = "off";
+		};
+
+		led2: D3 {
+                        label = "D3";
+                        gpios = <&gpio1 4 0>;
+                        default-state = "on";
+                };
+	};
+
+	mdio0: mdio {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mdio_1>;
+		compatible = "virtual,mdio-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		gpios = <&gpio1 31 0
+			 &gpio1 22 0>;
+
+		micrelswitch: ethernet-phy@3 {
+			reg = <3>;
+		};
+	};
+
+	micrel0: micrel_smi0 {
+		compatible = "micrel,ksz8873";
+		phy-handle = <&micrelswitch>;
+	};
+
+	skov_version {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_skov_version>;
+		compatible = "skov-version";
+		v0-gpio = <&gpio2 10 0>;
+		v1-gpio = <&gpio2 15 0>;
+		v2-gpio = <&gpio2 8 0>;
+		v3-gpio = <&gpio2 9 0>;
+		v4-gpio = <&gpio2 12 0>;
+		v5-gpio = <&gpio2 14 0>;
+		v6-gpio = <&gpio2 11 0>;
+		v7-gpio = <&gpio2 13 0>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		/* power in from 24 V */
+		reg_24p0v: 24p0v {
+			compatible = "regulator-fixed";
+			regulator-name = "24P0V";
+			regulator-min-microvolt = <24000000>;
+			regulator-max-microvolt = <24000000>;
+			regulator-always-on;
+		};
+
+		reg_5p0v: 5p0v {
+			compatible = "regulator-fixed";
+			regulator-name = "5P0V";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+
+		reg_1p2v: 1p2v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "1P2V";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-always-on;
+		};
+
+		reg_1p5v: 1p5v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "1P5V";
+			regulator-min-microvolt = <1500000>;
+			regulator-max-microvolt = <1500000>;
+			regulator-always-on;
+		};
+
+		reg_2p5v: 2p5v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "2P5V";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_vref: vref {
+			compatible = "regulator-fixed";
+			regulator-name = "vref";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+
+		reg_usb_h1_vbus: usb_h1_vbus {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+
+		/* MMC power supply */
+		vcc_mmc: sdcard_power_supply {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_3p3v>;
+			regulator-name = "mmc_vcc_supply";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+		/* MMC IO voltage select */
+		iovcc_mmc: sdcard_io_supply {
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_io_vcc_mmc>;
+			compatible = "regulator-gpio";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "mmc_io_supply";
+			regulator-type = "voltage";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3300000>;
+			gpios = <&gpio7 13 GPIO_ACTIVE_HIGH>;
+			states = <1800000 0x1
+				  3300000 0x0>;
+			startup-delay-us = <100>;
+		};
+	};
+
+	display@di0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		status = "okay";
+		compatible = "fsl,imx-parallel-display";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_4>;
+
+		port@0 {
+			reg = <0>;
+
+			display0_in: endpoint {
+				remote-endpoint = <&ipu1_di0_disp0>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			display0_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+
+	backlight_lcd: backlight_lcd {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 20000>;
+		brightness-levels = <0 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240 255>;
+		default-brightness-level = <8>;
+		power-supply = <&reg_24p0v>;
+		status = "okay";
+	};
+
+	panel {
+		compatible = "logictechnologies,lttd800480070-l2rt";
+		backlight = <&backlight_lcd>;
+		power-supply = <&reg_3p3v>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&display0_out>;
+			};
+		};
+	};
+};
+
+&ipu1_di0_disp0 {
+	remote-endpoint = <&display0_in>;
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 24 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_1>;
+	status = "okay";
+
+	flash: m25p80@0 {
+		compatible = "n25q064";
+		spi-max-frequency = <54000000>;
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&ecspi2 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio2 26 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2_1>;
+	status = "okay";
+
+	mcp3x0x@0 {
+		compatible = "mcp3002";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+	};
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_1>;
+	status = "okay";
+
+	ads7846: ads7846@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+		vcc-supply  = <&reg_3p3v>;
+
+		ti,x-min = /bits/ 16 <800>;
+		ti,x-max = /bits/ 16 <3400>;
+		ti,y-min = /bits/ 16 <500>;
+		ti,y-max = /bits/ 16 <3400>;
+		ti,x-plate-ohms = /bits/ 16 <642>;
+		ti,y-plate-ohms = /bits/ 16 <295>;
+		ti,pressure-max = /bits/ 16 <1500>;
+		ti,vref-delay-usecs = /bits/ 16 <300>;
+		ti,debounce-max = /bits/ 16 <100>;
+		ti,debounce-tol = /bits/ 16 <(~0)>;
+		ti,debounce-rep = /bits/ 16 <8>;
+
+		linux,wakeup;
+	};
+};
+
+&fec {
+	compatible = "fsl,imx6q-fec";
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_4>;
+	phy-mode = "rmii";
+	phy-handle = <&micrelswitch>;
+	phy-reset-gpios = <&gpio1 5 0>;
+	phy-reset-duration = "100";
+	phy-supply = <&reg_3p3v>;
+	#address-cells = <0>;
+	#size-cells = <1>;
+
+	/*
+	 * MDIO phy#1 is port 1 e.g. LAN1
+	 * MDIO phy#2 is port 2 e.g. LAN2
+	 * MDIO phy#2 is port 2 e.g. RMII port, with no real and usable
+	 * phy emulation
+	 */
+};
+
+/* signal "active link" on the RMII to the ethernet switch */
+&gpio1 {
+	active_rmii_link {
+		gpio-hog;
+		gpios = <&gpio1 24 GPIO_ACTIVE_LOW>;
+		output-low;
+		line-name = "rmii-active-link";
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_2>;
+};
+
+&i2c3 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_2>;
+
+	i2c_rtc: pcf85063@51 {
+		compatible = "nxp,pcf85063";
+		reg = <0x51>;
+		quartz_load = "12.5pF";
+	};
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand_2>;
+	nand-on-flash-bbt;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	pinctrl_board: skov_imx6_grp {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* external pull up */
+				MX6QDL_PAD_EIM_D30__GPIO3_IO30		0xb0		/* ethernet phy interrupt */
+			>;
+		};
+
+		pinctrl_skov_version: skov_version_pins {
+			fsl,pins = <
+				/* never changing input pins */
+				MX6QDL_PAD_SD4_DAT0__GPIO2_IO08		0x1b040		/* VC0 */
+				MX6QDL_PAD_SD4_DAT1__GPIO2_IO09		0x1b040		/* VC1 */
+				MX6QDL_PAD_SD4_DAT2__GPIO2_IO10		0x1b040		/* VC2 */
+				MX6QDL_PAD_SD4_DAT3__GPIO2_IO11		0x1b040		/* VC3 */
+				MX6QDL_PAD_SD4_DAT4__GPIO2_IO12		0x1b040		/* VC4 */
+				MX6QDL_PAD_SD4_DAT5__GPIO2_IO13		0x1b040		/* VC5 */
+				MX6QDL_PAD_SD4_DAT6__GPIO2_IO14		0x1b040		/* VC6 */
+				MX6QDL_PAD_SD4_DAT7__GPIO2_IO15		0x1b040		/* VC7 */
+			>;
+		};
+
+		pinctrl_io_vcc_mmc: vcc_io_mmc_grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_18__GPIO7_IO13		0x40000058	/* MMC IO Supply Select */
+			>;
+		};
+
+		pinctrl_ecspi1_1: ecspi1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO		0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI		0x000b1
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK		0x000b1
+				/* *no* external pull up */
+				MX6QDL_PAD_EIM_D24__GPIO3_IO24		0x40000058	/* spi-nor CS */
+			>;
+		};
+
+		pinctrl_ecspi2_1: ecspi2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_OE__ECSPI2_MISO		0x100b1
+				MX6QDL_PAD_EIM_CS1__ECSPI2_MOSI		0x000b1
+				MX6QDL_PAD_EIM_CS0__ECSPI2_SCLK 	0x000b1
+				/* external pull up */
+				MX6QDL_PAD_EIM_RW__GPIO2_IO26		0x40000058	/* mcp2003 CS */
+			>;
+		};
+
+		pinctrl_ecspi4_1: ecspi4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI 	0x100b1
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO 	0x000b1
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK 	0x000b1
+				/* *no* external pull up */
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x40000058	/* TSC2046 CS */
+			>;
+		};
+
+		pinctrl_mdio_1: mdio-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__GPIO1_IO22	0x100b1
+				MX6QDL_PAD_ENET_MDC__GPIO1_IO31		0x000b1
+			>;
+		};
+
+		pinctrl_enet_4: enetgrp-4 {
+			fsl,pins = <
+				/* RMII 50 MHz */
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN	0x100f5
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN	0x100f5
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0	0x100c0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1	0x100c0
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0	0x100f5
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1	0x100f5
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x40010040
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05		0x40000058
+				/* GPIO for "link active" */
+				MX6QDL_PAD_ENET_RX_ER__GPIO1_IO24	0x40000058
+			>;
+		};
+
+		pinctrl_pwm2_2: pwm2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__PWM2_OUT		0x00058
+			>;
+		};
+
+		pinctrl_pwm3_2: pwm3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT1__PWM3_OUT		0x00058
+			>;
+		};
+
+		pinctrl_flexcan1_3: flexcan1grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__FLEXCAN1_TX		0x80000000
+				MX6QDL_PAD_GPIO_8__FLEXCAN1_RX		0x80000000
+				MX6QDL_PAD_EIM_D31__GPIO3_IO31		0x13000		/* CAN RS */
+			>;
+		};
+
+		pinctrl_usdhc3_2: usdhc3grp-2 {
+			fsl,pins = <
+				/* SoC internal pull up required */
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17059
+				/* SoC internal pull up required */
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x4001b040	/* WP */
+				/* SoC internal pull up required */
+				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x4001b040	/* CD */
+			>;
+		};
+
+		pinctrl_usdhc3_100mhz: usdhc3grp100mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x170b9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x100b9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x170b9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x170b9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x170b9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x170b9
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x4001b040
+				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x4001b040
+			>;
+		};
+
+		pinctrl_usdhc3_200mhz: usdhc3grp200mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x170f9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x100f9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x170f9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x170f9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x170f9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x170f9
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x4001b040
+				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x4001b040
+			>;
+		};
+
+		pinctrl_i2c2_2: i2c2grp-2 {
+			fsl,pins = <
+				/* internal 22 k pull up required */
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001F878
+				/* internal 22 k pull up required */
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001F878
+			>;
+		};
+
+		pinctrl_i2c3_2: i2c3grp-2 {
+			fsl,pins = <
+				/* external 10 k pull up */
+				MX6QDL_PAD_GPIO_3__I2C3_SCL		0x40010878
+				/* external 10 k pull up */
+				MX6QDL_PAD_GPIO_6__I2C3_SDA		0x40010878
+			>;
+		};
+
+		pinctrl_ipu1_4: ipu1grp-4 {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK	0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15		0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02		0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03		0x10
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00	0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01	0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02	0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03	0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04	0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05	0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06	0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07	0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08	0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09	0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10	0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11	0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12	0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13	0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14	0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15	0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16	0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17	0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18	0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19	0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20	0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21	0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22	0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23	0x10
+			>;
+		};
+
+		pinctrl_uart2_1: uart2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_gpmi_nand_2: gpmi-nand-2 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE		0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B	0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B	0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B	0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B		0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B		0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00	0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01	0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02	0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03	0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04	0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05	0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06	0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07	0xb0b1
+			>;
+		};
+	};
+};
+
+&pwm2 {
+	/* used for backlight brightness */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2_2>;
+	status = "okay";
+};
+
+&pwm3 {
+	/* used for LCD contrast control */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm3_2>;
+	status = "okay";
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_3>;
+	xceiver-supply = <&reg_3p3v>;
+	status = "okay";
+};
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	disable-over-current;
+        status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	disable-over-current;
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_1>;
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3_2>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	wp-gpios = <&gpio7 1 GPIO_ACTIVE_HIGH>; /* e.g. low if not 'locked' */
+	cd-gpios = <&gpio7 0 GPIO_ACTIVE_LOW>; /* e.g. high if no card is plugged in */
+	status = "okay";
+	cap-power-off-card;
+	full-pwr-cycle;
+	bus-width = <4>;
+	max-frequency = <50000000>;
+	cap-sd-highspeed;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	sd-uhs-ddr50;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	vmmc-supply = <&vcc_mmc>;
+	vqmmc-supply = <&iovcc_mmc>;
+	fsl,delay-line;
+};
diff --git a/arch/arm/boot/dts/imx6qdl-cpuC.dtsi b/arch/arm/boot/dts/imx6qdl-cpuC.dtsi
new file mode 100644
index 000000000000..97284a974c1c
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qdl-cpuC.dtsi
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2014 Rose Technology.
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+&pinctrl_board {
+	pinctrl_flexcan2_1: flexcan2grp-1 {
+		fsl,pins = <
+			MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX 	0x80000000
+			MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX 	0x80000000
+		>;
+	};
+
+	pinctrl_ads7846: ads7846grp {
+		fsl,pins = <
+			/* external pull up */
+			MX6QDL_PAD_EIM_D19__GPIO3_IO19		0x10040		/* TSC2046 Pen down irq */
+		>;
+	};
+
+	pinctrl_backlight: backlight_grp {
+		fsl,pins = <
+			MX6QDL_PAD_RGMII_TD3__GPIO6_IO23	0x40000058
+		>;
+	};
+
+	pinctrl_vcc_mmc: vcc_mmc_grp {
+		fsl,pins = <
+			MX6QDL_PAD_SD3_RST__GPIO7_IO08		0x40000058	/* MMC Power Supply Switch */
+		>;
+	};
+};
+
+&backlight_lcd {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_backlight>;
+	enable-gpios = <&gpio6 23 GPIO_ACTIVE_LOW>;
+};
+
+&gpio6 {
+	backlight {
+		gpios = <23 0>; /* initially switch off the panel backlight */
+		output-high;
+		gpio-initval;
+	};
+};
+
+&ads7846 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ads7846>;
+	pendown-gpio = <&gpio3 19 0>;
+	interrupt-parent = <&gpio3>;
+	interrupts = <19 IRQ_TYPE_LEVEL_LOW>;
+};
+
+&can2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2_1>;
+	xceiver-supply = <&reg_3p3v>;
+	status = "okay";
+};
+
+&vcc_mmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_vcc_mmc>;
+	gpio = <&gpio7 8 GPIO_ACTIVE_HIGH>;
+	enable-active-high;
+	startup-delay-us = <100>;
+	/* don't switch off the SD card automatically */
+	regulator-always-on;
+	regulator-boot-on;
+};
diff --git a/drivers/Kconfig b/drivers/Kconfig
index d2ac339de85f..aed39ec953b9 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -198,4 +198,6 @@ source "drivers/hwtracing/intel_th/Kconfig"
 
 source "drivers/fpga/Kconfig"
 
+source "drivers/skov/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 795d0ca714bf..d3efe14ea9a7 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -172,3 +172,4 @@ obj-$(CONFIG_STM)		+= hwtracing/stm/
 obj-$(CONFIG_ANDROID)		+= android/
 obj-$(CONFIG_NVMEM)		+= nvmem/
 obj-$(CONFIG_FPGA)		+= fpga/
+obj-y				+= skov/
diff --git a/drivers/gpu/drm/imx/ipuv3-crtc.c b/drivers/gpu/drm/imx/ipuv3-crtc.c
index 4ab841eebee1..21b99eb78271 100644
--- a/drivers/gpu/drm/imx/ipuv3-crtc.c
+++ b/drivers/gpu/drm/imx/ipuv3-crtc.c
@@ -173,7 +173,7 @@ static int ipu_crtc_mode_set(struct drm_crtc *crtc,
 		sig_cfg.clkflags = 0;
 
 	sig_cfg.enable_pol = 1;
-	sig_cfg.clk_pol = 0;
+	sig_cfg.clk_pol = 1;
 	sig_cfg.bus_format = ipu_crtc->bus_format;
 	sig_cfg.v_to_h_sync = 0;
 	sig_cfg.hsync_pin = ipu_crtc->di_hsync_pin;
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index f97b73ec4713..c1bf9f33860b 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -44,6 +44,10 @@ struct panel_desc {
 
 	unsigned int bpc;
 
+	/**
+	 * @width: the width of the panel (in millimeters)
+	 * @height: the height of the panel (in millimeters)
+	 */
 	struct {
 		unsigned int width;
 		unsigned int height;
@@ -949,6 +953,68 @@ static const struct panel_desc lg_lp129qe = {
 	},
 };
 
+static const struct drm_display_mode logic_techno_lttd800480070_l2rt_mode  = {
+	.clock = 33000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 112,
+	.hsync_end = 800 + 112 + 3,
+	.htotal = 800 + 112 + 3 + 85,
+	.vdisplay = 480,
+	.vsync_start = 480 + 38,
+	.vsync_end = 480 + 38 + 3,
+	.vtotal = 480 + 38 + 3 + 29,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc logic_techno_lttd800480070_l2rt = {
+	.modes = &logic_techno_lttd800480070_l2rt_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 154,
+		.height = 86,
+	},
+	.delay = {
+		.prepare = 45,
+		.enable = 100,
+		.disable = 100,
+		.unprepare = 45
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode logic_techno_lttd800480070_l6wh_rt_mode  = {
+	.clock = 33000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 154,
+	.hsync_end = 800 + 154 + 3,
+	.htotal = 800 + 112 + 3 + 43,
+	.vdisplay = 480,
+	.vsync_start = 480 + 47,
+	.vsync_end = 480 + 38 + 3,
+	.vtotal = 480 + 47 + 3 + 20,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc logic_techno_lttd800480070_l6wh_rt = {
+	.modes = &logic_techno_lttd800480070_l6wh_rt_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 154,
+		.height = 86,
+	},
+	.delay = {
+		.prepare = 45,
+		.enable = 100,
+		.disable = 100,
+		.unprepare = 45
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
 static const struct drm_display_mode nec_nl4827hc19_05b_mode = {
 	.clock = 10870,
 	.hdisplay = 480,
@@ -1173,6 +1239,12 @@ static const struct of_device_id platform_of_match[] = {
 		.compatible = "lg,lp129qe",
 		.data = &lg_lp129qe,
 	}, {
+		.compatible = "logictechnologies,lttd800480070-l2rt",
+		.data = &logic_techno_lttd800480070_l2rt,
+	}, {
+		.compatible = "logictechnologies,lttd800480070-l6wh-rt",
+		.data = &logic_techno_lttd800480070_l6wh_rt,
+	}, {
 		.compatible = "nec,nl4827hc19-05b",
 		.data = &nec_nl4827hc19_05b,
 	}, {
diff --git a/drivers/rtc/rtc-pcf85063.c b/drivers/rtc/rtc-pcf85063.c
index 0150e93043c1..ce9055a5ae8f 100644
--- a/drivers/rtc/rtc-pcf85063.c
+++ b/drivers/rtc/rtc-pcf85063.c
@@ -20,7 +20,10 @@
 
 #define PCF85063_REG_CTRL1		0x00 /* status */
 #define PCF85063_REG_CTRL1_STOP		BIT(5)
+#define PCF85063_REG_CTRL1_CAP_SEL	BIT(0)
 #define PCF85063_REG_CTRL2		0x01
+#define PCF85063_REG_CTRL2_COF_OFF	0x07
+#define PCF85063_REG_OFFSET		0x02
 
 #define PCF85063_REG_SC			0x04 /* datetime */
 #define PCF85063_REG_SC_OS		0x80
@@ -215,6 +218,39 @@ static const struct rtc_class_ops pcf85063_rtc_ops = {
 	.set_time	= pcf85063_rtc_set_time
 };
 
+/* Board specific setup for Skov IMX6 */
+static int pcf85063_init_for_skov(struct i2c_client *client)
+{
+	int rc;
+	u8 data[4] = {
+		PCF85063_REG_CTRL1, /* where to start to write */
+		0x00, /* default */
+		PCF85063_REG_CTRL2_COF_OFF, /* disable clock out */
+		0x00, /* disable any offset corrections */
+	};
+
+	/*
+	 * there are no external capacitors populated to define the load of
+	 * the used 32,786 Hz crystal. We use the device's internal capacitor
+	 * load instead.
+	 */
+	if (of_property_match_string(client->dev.of_node,
+				     "quartz_load", "12.5pF") == 0)
+		data[1] |= PCF85063_REG_CTRL1_CAP_SEL;
+
+	if (of_property_match_string(client->dev.of_node,
+				     "quartz_load", "7pF") == 0)
+		data[1] &= ~PCF85063_REG_CTRL1_CAP_SEL;
+
+	rc = i2c_master_send(client, data, sizeof(data));
+	if (rc != sizeof(data)) {
+		dev_err(&client->dev, "Failing to configure device\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
 static int pcf85063_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
 {
@@ -234,6 +270,10 @@ static int pcf85063_probe(struct i2c_client *client,
 
 	i2c_set_clientdata(client, pcf85063);
 
+	if (pcf85063_init_for_skov(client) < 0)
+		dev_warn(&client->dev,
+			 "Board specific setup failed. Trying to continue\n");
+
 	pcf85063->rtc = devm_rtc_device_register(&client->dev,
 				pcf85063_driver.driver.name,
 				&pcf85063_rtc_ops, THIS_MODULE);
diff --git a/drivers/skov/Kconfig b/drivers/skov/Kconfig
new file mode 100644
index 000000000000..1845410e364b
--- /dev/null
+++ b/drivers/skov/Kconfig
@@ -0,0 +1,18 @@
+menu "Drivers for SKOV"
+
+config MEM_PEEK
+	bool "Mem registers"
+	default y
+	help
+	  Enable to read from registers.
+
+config SKOV_VERSION
+        tristate "SKOV Vesion"
+        default y
+        help
+          Driver for the version Input pins.
+          This driver has a database over the various Skov HW
+          configurations. If it shows unknown the kernel is too old and a
+          newer kernel with an updated database need to be installed.
+
+endmenu
diff --git a/drivers/skov/Makefile b/drivers/skov/Makefile
new file mode 100644
index 000000000000..9925771b0e0b
--- /dev/null
+++ b/drivers/skov/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MEM_PEEK)		+= mem_peek.o
+obj-$(CONFIG_SKOV_VERSION)      += skov_version.o
diff --git a/drivers/skov/mem_peek.c b/drivers/skov/mem_peek.c
new file mode 100644
index 000000000000..61e82b4592df
--- /dev/null
+++ b/drivers/skov/mem_peek.c
@@ -0,0 +1,163 @@
+/*
+ * mem_peek.c
+ * (c) Martin Bjærre
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+
+#define err( fmt, arg... ) printk( KERN_ERR "mem_peek: %s() " fmt "\n" , __FUNCTION__, ## arg )
+#define deb( fmt, arg... ) 
+// pr_info( "DBUG mem_peek: %s() " fmt "\n" , __FUNCTION__, ## arg )
+
+static struct proc_dir_entry *pde_mem_peek_dir;
+static struct proc_dir_entry *pde_reg;
+static struct proc_dir_entry *pde_addr;
+
+static u32 reg_addr = 0x1E000000;
+
+/********************************************************************************/
+/*************************   proc_read_reg **************************/
+/********************************************************************************/
+
+static int proc_reg_show(struct seq_file *m, void *v)
+{
+	int val;
+	u32 *mapped;
+
+	mapped = ioremap(reg_addr, SZ_4K);
+	if (mapped== 0)
+		return 0;
+	val = __raw_readl(mapped);
+
+	iounmap(mapped);
+
+	seq_printf(m, "Addr=0x%08xh\tData=0x%08xh\n", reg_addr, val);
+
+	return 0;
+}
+
+static int proc_open_reg(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_reg_show, NULL);
+}
+
+/*************************************************************************/
+/*********************** proc_write_reg *****************************/
+/*************************************************************************/
+static int proc_write_reg(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	u32 val;
+	u32 *mapped;
+
+	sscanf(buf, "%x", &val);
+
+	mapped = ioremap(reg_addr, SZ_4K);
+
+	if (mapped== 0)
+		return 0;
+	__raw_writel(val, mapped);
+
+	iounmap(mapped);	
+	
+	return count;
+}
+
+/********************************************************************************/
+/*************************   proc_read_addr *************************************/
+/********************************************************************************/
+
+static int proc_addr_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "Addr=0x%08xh\n", reg_addr);
+
+	return 0;
+}
+
+static int proc_open_addr(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_addr_show, NULL);
+}
+
+/*************************************************************************/
+/*********************** proc_write_addr *********************************/
+/*************************************************************************/
+static int proc_write_addr(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	sscanf(buf, "%x", &reg_addr);
+
+	return count;
+}
+
+static const struct file_operations mem_peek_addr_fops = {
+	.open=proc_open_addr,
+	.llseek=seq_lseek,
+	.read=seq_read,
+	.write=proc_write_addr,
+	.release = single_release
+};
+
+static const struct file_operations mem_peek_reg_fops = {     
+	.open=proc_open_reg,
+	.llseek=seq_lseek,
+	.read=seq_read,  
+	.write=proc_write_reg,
+	.release = single_release
+};
+
+
+/*************************************************************************/
+/*************************   init_proc   *********************************/
+/*************************************************************************/
+void init_proc(void)
+{
+	/* create directory */
+	pde_mem_peek_dir = proc_mkdir("mem_peek", NULL);
+	if (pde_mem_peek_dir==NULL)
+		return;
+
+	pde_reg=proc_create("reg", 0666, pde_mem_peek_dir, &mem_peek_reg_fops);
+	if (pde_reg==NULL) {
+		printk("mem_peek: Error creating proc entry reg\n");
+	}
+
+	pde_addr=proc_create("addr", 0666, pde_mem_peek_dir, &mem_peek_addr_fops);
+	if (pde_addr==NULL) {
+		printk("mem_peek: Error creating proc entry addr\n");
+	}
+}
+
+/********************************************************************/
+/*************************   init   *********************************/
+/********************************************************************/
+static int __init mem_peek_init(void)
+{
+	init_proc();
+	return 0;
+}
+
+/********************************************************************/
+/*************************   exit   *********************************/
+/********************************************************************/
+static void __exit mem_peek_exit(void)
+{
+	remove_proc_entry("reg", pde_mem_peek_dir);
+	remove_proc_entry("addr", pde_mem_peek_dir);
+
+	remove_proc_entry("mem_peek", NULL);
+	printk("mem_peek: goodbye!\n");
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("ROSE");
+MODULE_DESCRIPTION("mem peek imx53");
+
+//EXPORT_NO_SYMBOLS;
+
+module_init(mem_peek_init);
+module_exit(mem_peek_exit);
+
diff --git a/drivers/skov/skov_version.c b/drivers/skov/skov_version.c
new file mode 100644
index 000000000000..f6178256a2c7
--- /dev/null
+++ b/drivers/skov/skov_version.c
@@ -0,0 +1,315 @@
+/*
+ * Skov version driver
+ *
+ * Copyright (C) 2013 Søren Andersen <san@rosetechnology.dk>
+ * Copyright (C) 2015-2016 Søren Andersen <san@skov.dk> Skov A/S.
+ *
+ * Various SKOV boards and there version control configuration
+ * Resistors    - Version -         		Rev - Ram    - Flash
+ * 00000000     - High Performance   	 	 A    1024MB -  1024MB
+ * 00000001     - Low Cost           	 	 A    512 MB -  256 MB
+ * 00000100     - Low Cost           	 	 A    512 MB -  256 MB
+ * 00000010	- High Performance   	 	 A    1024MB -  512 MB
+ * 00001000	- High Performance   	 	 A    1024MB -  512 MB
+ * 00001001	- Minium Cost	     	 	 B    256 MB -   16 MB
+ * 00001010	- Low Cost	     	 	 B    256 MB -  256 MB
+ * 00001011	- High Performance   	 	 B    1024MB -  256 MB
+ * 00001100	- Max  Performance   	 	 B    2028MB - 16384MB
+ * 00001101	- Low Cost	     	 	 C    256 MB -  256 MB
+ * 00001110	- High Performance   	 	 C    1024MB -  256 MB
+ * 00001111	- Middle Performance		 C    512 MB -  256 MB
+ * 00010000	- i.MX6 CPU SoloCore		 C    512 MB -  4096MB
+ * 00010001	- i.MX6 CPU QuadCore		 C    2048MB -  8192MB
+ * 00010010	- i.MX6 CPU QuadCore+		 C    4192MB - 16384MB
+ * 00010011	- i.MX6 CPU SoloCore		 C    512 MB -  2048MB
+ * 00010100	- i.MX6 CPU QuadCore		 C    1024MB -  4096MB
+ * 00010101    - i.MX6 CPU SoloCore             C    512 MB -  2048MB
+ * 00010110    - i.MX6 CPU QuadCore             C    1024MB -  4096MB
+ */
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+
+struct skov_version_platform_data {
+	unsigned int vc0;
+	unsigned int vc1;
+	unsigned int vc2;
+	unsigned int vc3;
+	unsigned int vc4;
+	unsigned int vc5;
+	unsigned int vc6;
+	unsigned int vc7;
+	unsigned int var;
+};
+
+struct pltfm_imx_data {
+	struct clk *clk_per;
+	struct skov_version_platform_data boarddata;
+	const struct skov_version_data *socdata;
+};
+
+static const char *description[] = {
+	"Minimum Cost",
+	"Low Cost",
+	"High Performance",
+	"Maximum Performance",
+	"Middle Performance",
+	"i.MX6 CPU SoloCore",
+	"i.MX6 CPU QuadCore",
+	"i.MX6 CPU QuadCore+"
+};
+
+static const unsigned int mem[] = {
+	256,
+	512,
+	1024,
+	2048,
+	3840,
+	0
+};
+
+static const char *rev[] = {
+	"A",
+	"B",
+	"C",
+	"D",
+	"E",
+	"F",
+	"G",
+	"H",
+	"I",
+	"J",
+	"K",
+};
+
+static const unsigned int nand[] = {
+	16,
+	32,
+	64,
+	128,
+	256,
+	512,
+	1024,
+	2048,
+	4096,
+	8192,
+	16384,
+	32768
+};
+
+/*
+ *
+ */
+static ssize_t show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct skov_version_platform_data *svpd = dev_get_drvdata(dev);
+
+	if (strcmp(attr->attr.name, "mem") == 0) {
+		switch(svpd->var ) {
+		case 19:
+		case 21:
+			return sprintf(buf, "%u\n", mem[1]);
+		case 20:
+		case 22:
+			return sprintf(buf, "%u\n", mem[2]);
+		default:
+			return sprintf(buf, "Unsupported board revision: 0x%x\n", svpd->var);
+		}
+	} else if (strcmp(attr->attr.name, "rev") == 0) {
+		switch(svpd->var){
+		case 19:
+		case 20:
+		case 21:
+		case 22:
+			return sprintf(buf, "%s\n", rev[2]);
+		default:
+			return sprintf(buf, "Unsupported board revision: 0x%x\n", svpd->var);
+		}
+	} else if (strcmp(attr->attr.name, "description") == 0) {
+		switch(svpd->var) {
+		case 19:
+		case 21:
+			return sprintf(buf, "%s\n", description[5]);
+		case 20:
+		case 22:
+			return sprintf(buf, "%s\n", description[6]);
+		default:
+			return sprintf(buf, "Unsupported board revision: 0x%x\n", svpd->var);
+		}
+	} else if (strcmp(attr->attr.name, "nand") == 0) {
+		switch(svpd->var) {
+		case 19:
+		case 21:
+			return sprintf(buf, "%u\n", nand[7]);
+		case 20:
+		case 22:
+			return sprintf(buf, "%u\n", nand[8]);
+		default:
+			return sprintf(buf, "Unsupported board revision: 0x%x\n", svpd->var);
+		}
+	} else if (strcmp(attr->attr.name, "raw") == 0) {
+		return sprintf(buf, "%u\n", svpd->var);
+
+	} else { /* Try to read Undefined sysfs file */
+		return sprintf(buf, "%s\n", "Requested file not found");
+	}
+
+	return sprintf(buf, "%u\n", svpd->var);
+}
+
+static struct device_attribute mem_attribute = __ATTR(mem, 0444, show, NULL);
+static struct device_attribute rev_attribute = __ATTR(rev, 0444, show, NULL);
+static struct device_attribute raw_attribute = __ATTR(raw, 0444, show, NULL);
+static struct device_attribute nand_attribute = __ATTR(nand, 0444, show, NULL);
+static struct device_attribute description_attribute =
+                                        __ATTR(description, 0444, show, NULL);
+
+/*
+ * Create a group of attributes so that we can create and destory them all
+ * at once.
+*/
+
+static struct attribute *attrs[] = {
+	&mem_attribute.attr,
+	&rev_attribute.attr,
+	&raw_attribute.attr,
+	&description_attribute.attr,
+	&nand_attribute.attr,
+	NULL,   /* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory.  If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static const struct of_device_id skov_version_dt_ids[] = {
+	{ .compatible = "skov-version" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, skov_version_dt_ids);
+
+#ifdef CONFIG_OF
+static int skov_version_probe_dt(struct platform_device *pdev,
+			struct skov_version_platform_data *boarddata)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np)
+		return -ENODEV;
+
+	boarddata->vc0 = of_get_named_gpio(np, "v0-gpio", 0);
+	boarddata->vc1 = of_get_named_gpio(np, "v1-gpio", 0);
+	boarddata->vc2 = of_get_named_gpio(np, "v2-gpio", 0);
+	boarddata->vc3 = of_get_named_gpio(np, "v3-gpio", 0);
+	boarddata->vc4 = of_get_named_gpio(np, "v4-gpio", 0);
+	boarddata->vc5 = of_get_named_gpio(np, "v5-gpio", 0);
+	boarddata->vc6 = of_get_named_gpio(np, "v6-gpio", 0);
+	boarddata->vc7 = of_get_named_gpio(np, "v7-gpio", 0);
+
+	return 0;
+}
+#else
+static inline int skov_version_probe_dt(struct platform_device *pdev,
+					struct skov_version_data *boarddata)
+{
+	return -ENODEV;
+}
+#endif
+
+static int skov_version_probe(struct platform_device *pdev)
+{
+	int retval = 0;
+	int var = 0;
+	int err;
+	const struct of_device_id *of_id =
+		of_match_device(skov_version_dt_ids, &pdev->dev);
+	struct skov_version_platform_data *boarddata;
+	struct pltfm_imx_data *imx_data;
+
+	imx_data = devm_kzalloc(&pdev->dev, sizeof(*imx_data), GFP_KERNEL);
+	if (!imx_data) {
+		err = -ENOMEM;
+		goto free_skov_ver;
+	}
+	imx_data->socdata = of_id ? of_id->data : (struct skov_version_data *)
+                                                    pdev->id_entry->driver_data;
+
+	boarddata = &imx_data->boarddata;
+	skov_version_probe_dt(pdev, boarddata);
+
+	gpio_request(boarddata->vc0, "VERSION0");
+	gpio_request(boarddata->vc1, "VERSION1");
+	gpio_request(boarddata->vc2, "VERSION2");
+	gpio_request(boarddata->vc3, "VERSION3");
+	gpio_request(boarddata->vc4, "VERSION4");
+	gpio_request(boarddata->vc5, "VERSION5");
+	gpio_request(boarddata->vc6, "VERSION6");
+	gpio_request(boarddata->vc7, "VERSION7");
+
+	gpio_direction_input(boarddata->vc0);
+	gpio_direction_input(boarddata->vc1);
+	gpio_direction_input(boarddata->vc2);
+	gpio_direction_input(boarddata->vc3);
+	gpio_direction_input(boarddata->vc4);
+	gpio_direction_input(boarddata->vc5);
+	gpio_direction_input(boarddata->vc6);
+	gpio_direction_input(boarddata->vc7);
+
+	var = (!gpio_get_value(boarddata->vc0));
+	var |= (!gpio_get_value(boarddata->vc1) << 1);
+	var |= (!gpio_get_value(boarddata->vc2) << 2);
+	var |= (!gpio_get_value(boarddata->vc3) << 3);
+	var |= (!gpio_get_value(boarddata->vc4) << 4);
+	var |= (!gpio_get_value(boarddata->vc5) << 5);
+	var |= (!gpio_get_value(boarddata->vc6) << 6);
+	var |= (!gpio_get_value(boarddata->vc7) << 7);
+
+	boarddata->var = var;
+	platform_set_drvdata(pdev, boarddata);
+
+	retval = sysfs_create_group(&pdev->dev.kobj, &attr_group);
+
+	return retval;
+
+free_skov_ver:
+	return err;
+}
+
+static int skov_version_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &attr_group);
+
+	return 0;
+}
+
+static struct platform_driver skov_version_driver = {
+	.driver = {
+		.name = "skov_version",
+		.owner = THIS_MODULE,
+		.of_match_table = skov_version_dt_ids,
+	},
+	.probe = skov_version_probe,
+	.remove = skov_version_remove,
+};
+
+module_platform_driver(skov_version_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Søren Andersen <san@rosetechnology.dk");
+MODULE_DESCRIPTION("Version Control");
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-skov-imx6-revC6L.dts
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 Rose Technology
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "imx6dl.dtsi"
+#include "imx6qdl-cpu-6L.dtsi"
+#include "imx6qdl-cpuC.dtsi"
+
+/ {
+	model = "Freescale i.MX6 SKOV Solo Board";
+	compatible = "skov,imx6-imxdl-revC", "skov,imx6", "fsl,imx6dl";
+};
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-skov-imx6-revC6L.dts
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 Rose Technology
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "imx6q.dtsi"
+#include "imx6qdl-cpu-6L.dtsi"
+#include "imx6qdl-cpuC.dtsi"
+
+/ {
+	model = "Freescale i.MX6 SKOV Quad Board";
+	compatible = "skov,imx6-imxq-revC", "skov,imx6", "fsl,imx6q";
+};
+
+&sata {
+	status = "disabled";
+};
+
+&i2c2 {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+	ddc-i2c-bus = <&i2c2>;
+};
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qdl-cpu-6L.dtsi
@@ -0,0 +1,662 @@
+/*
+ * Copyright 2014 Rose Technology.
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	chosen {
+		stdout-path = &uart2;
+	};
+
+	memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	aliases {
+		can0 = &can1;
+		can1 = &can2;
+		led0 = &led0;
+		led1 = &led1;
+		led2 = &led2;
+		nand = &gpmi;
+		usb0 = &usbh1;
+		usb1 = &usbotg;
+		rtc0 = &i2c_rtc;
+		rtc1 = &snvs;
+	        mdio-gpio0 = &mdio0;
+		micrel-smi0 = &micrel0;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led0: D1 {
+			label = "D1";
+			gpios = <&gpio1 2 0>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+
+		led1: D2 {
+			label = "D2";
+			gpios = <&gpio1 0 0>;
+			default-state = "off";
+		};
+
+		led2: D3 {
+                        label = "D3";
+                        gpios = <&gpio1 4 0>;
+                        default-state = "on";
+                };
+	};
+
+	mdio0: mdio {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_mdio_1>;
+		compatible = "virtual,mdio-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		gpios = <&gpio1 31 0
+			 &gpio1 22 0>;
+
+		micrelswitch: ethernet-phy@3 {
+			reg = <3>;
+		};
+	};
+
+	micrel0: micrel_smi0 {
+		compatible = "micrel,ksz8873";
+		phy-handle = <&micrelswitch>;
+	};
+
+	skov_version {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_skov_version>;
+		compatible = "skov-version";
+		v0-gpio = <&gpio2 10 0>;
+		v1-gpio = <&gpio2 15 0>;
+		v2-gpio = <&gpio2 8 0>;
+		v3-gpio = <&gpio2 9 0>;
+		v4-gpio = <&gpio2 12 0>;
+		v5-gpio = <&gpio2 14 0>;
+		v6-gpio = <&gpio2 11 0>;
+		v7-gpio = <&gpio2 13 0>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+
+		/* power in from 24 V */
+		reg_24p0v: 24p0v {
+			compatible = "regulator-fixed";
+			regulator-name = "24P0V";
+			regulator-min-microvolt = <24000000>;
+			regulator-max-microvolt = <24000000>;
+			regulator-always-on;
+		};
+
+		reg_5p0v: 5p0v {
+			compatible = "regulator-fixed";
+			regulator-name = "5P0V";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+
+		reg_1p2v: 1p2v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "1P2V";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-always-on;
+		};
+
+		reg_1p5v: 1p5v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "1P5V";
+			regulator-min-microvolt = <1500000>;
+			regulator-max-microvolt = <1500000>;
+			regulator-always-on;
+		};
+
+		reg_2p5v: 2p5v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "2P5V";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: 3p3v {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_vref: vref {
+			compatible = "regulator-fixed";
+			regulator-name = "vref";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: usb_otg_vbus {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+
+		reg_usb_h1_vbus: usb_h1_vbus {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+
+		/* MMC power supply */
+		vcc_mmc: sdcard_power_supply {
+			compatible = "regulator-fixed";
+			vin-supply = <&reg_3p3v>;
+			regulator-name = "mmc_vcc_supply";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+
+		/* MMC IO voltage select */
+		iovcc_mmc: sdcard_io_supply {
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_io_vcc_mmc>;
+			compatible = "regulator-gpio";
+			vin-supply = <&reg_5p0v>;
+			regulator-name = "mmc_io_supply";
+			regulator-type = "voltage";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3300000>;
+			gpios = <&gpio7 13 GPIO_ACTIVE_HIGH>;
+			states = <1800000 0x1
+				  3300000 0x0>;
+			startup-delay-us = <100>;
+		};
+	};
+
+	display@di0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		status = "okay";
+		compatible = "fsl,imx-parallel-display";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_4>;
+
+		port@0 {
+			reg = <0>;
+
+			display0_in: endpoint {
+				remote-endpoint = <&ipu1_di0_disp0>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+
+			display0_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+
+	backlight_lcd: backlight_lcd {
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 20000>;
+		brightness-levels = <0 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240 255>;
+		default-brightness-level = <8>;
+		power-supply = <&reg_24p0v>;
+		status = "okay";
+	};
+
+	panel {
+		compatible = "logictechnologies,lttd800480070-l6wh-rt";
+		backlight = <&backlight_lcd>;
+		power-supply = <&reg_3p3v>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&display0_out>;
+			};
+		};
+	};
+};
+
+&ipu1_di0_disp0 {
+	remote-endpoint = <&display0_in>;
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 24 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1_1>;
+	status = "okay";
+
+	flash: m25p80@0 {
+		compatible = "n25q064";
+		spi-max-frequency = <54000000>;
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&ecspi2 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio2 26 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2_1>;
+	status = "okay";
+
+	mcp3x0x@0 {
+		compatible = "mcp3002";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+	};
+};
+
+&ecspi4 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 20 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4_1>;
+	status = "okay";
+
+	ads7846: ads7846@0 {
+		compatible = "ti,tsc2046";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+		vcc-supply  = <&reg_3p3v>;
+
+		ti,x-min = /bits/ 16 <800>;
+		ti,x-max = /bits/ 16 <3400>;
+		ti,y-min = /bits/ 16 <500>;
+		ti,y-max = /bits/ 16 <3400>;
+		ti,x-plate-ohms = /bits/ 16 <642>;
+		ti,y-plate-ohms = /bits/ 16 <295>;
+		ti,pressure-max = /bits/ 16 <1500>;
+		ti,vref-delay-usecs = /bits/ 16 <300>;
+		ti,debounce-max = /bits/ 16 <100>;
+		ti,debounce-tol = /bits/ 16 <(~0)>;
+		ti,debounce-rep = /bits/ 16 <8>;
+
+		linux,wakeup;
+	};
+};
+
+&fec {
+	compatible = "fsl,imx6q-fec";
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet_4>;
+	phy-mode = "rmii";
+	phy-handle = <&micrelswitch>;
+	phy-reset-gpios = <&gpio1 5 0>;
+	phy-reset-duration = "100";
+	phy-supply = <&reg_3p3v>;
+	#address-cells = <0>;
+	#size-cells = <1>;
+
+	/*
+	 * MDIO phy#1 is port 1 e.g. LAN1
+	 * MDIO phy#2 is port 2 e.g. LAN2
+	 * MDIO phy#2 is port 2 e.g. RMII port, with no real and usable
+	 * phy emulation
+	 */
+};
+
+/* signal "active link" on the RMII to the ethernet switch */
+&gpio1 {
+	active_rmii_link {
+		gpio-hog;
+		gpios = <&gpio1 24 GPIO_ACTIVE_LOW>;
+		output-low;
+		line-name = "rmii-active-link";
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2_2>;
+};
+
+&i2c3 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3_2>;
+
+	i2c_rtc: pcf85063@51 {
+		compatible = "nxp,pcf85063";
+		reg = <0x51>;
+		quartz_load = "12.5pF";
+	};
+};
+
+&gpmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpmi_nand_2>;
+	nand-on-flash-bbt;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	pinctrl_board: skov_imx6_grp {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* external pull up */
+				MX6QDL_PAD_EIM_D30__GPIO3_IO30		0xb0		/* ethernet phy interrupt */
+			>;
+		};
+
+		pinctrl_skov_version: skov_version_pins {
+			fsl,pins = <
+				/* never changing input pins */
+				MX6QDL_PAD_SD4_DAT0__GPIO2_IO08		0x1b040		/* VC0 */
+				MX6QDL_PAD_SD4_DAT1__GPIO2_IO09		0x1b040		/* VC1 */
+				MX6QDL_PAD_SD4_DAT2__GPIO2_IO10		0x1b040		/* VC2 */
+				MX6QDL_PAD_SD4_DAT3__GPIO2_IO11		0x1b040		/* VC3 */
+				MX6QDL_PAD_SD4_DAT4__GPIO2_IO12		0x1b040		/* VC4 */
+				MX6QDL_PAD_SD4_DAT5__GPIO2_IO13		0x1b040		/* VC5 */
+				MX6QDL_PAD_SD4_DAT6__GPIO2_IO14		0x1b040		/* VC6 */
+				MX6QDL_PAD_SD4_DAT7__GPIO2_IO15		0x1b040		/* VC7 */
+			>;
+		};
+
+		pinctrl_io_vcc_mmc: vcc_io_mmc_grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_18__GPIO7_IO13		0x40000058	/* MMC IO Supply Select */
+			>;
+		};
+
+		pinctrl_ecspi1_1: ecspi1grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO		0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI		0x000b1
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK		0x000b1
+				/* *no* external pull up */
+				MX6QDL_PAD_EIM_D24__GPIO3_IO24		0x40000058	/* spi-nor CS */
+			>;
+		};
+
+		pinctrl_ecspi2_1: ecspi2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_OE__ECSPI2_MISO		0x100b1
+				MX6QDL_PAD_EIM_CS1__ECSPI2_MOSI		0x000b1
+				MX6QDL_PAD_EIM_CS0__ECSPI2_SCLK 	0x000b1
+				/* external pull up */
+				MX6QDL_PAD_EIM_RW__GPIO2_IO26		0x40000058	/* mcp2003 CS */
+			>;
+		};
+
+		pinctrl_ecspi4_1: ecspi4grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI 	0x100b1
+				MX6QDL_PAD_EIM_D22__ECSPI4_MISO 	0x000b1
+				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK 	0x000b1
+				/* *no* external pull up */
+				MX6QDL_PAD_EIM_D20__GPIO3_IO20		0x40000058	/* TSC2046 CS */
+			>;
+		};
+
+		pinctrl_mdio_1: mdio-1 {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__GPIO1_IO22	0x100b1
+				MX6QDL_PAD_ENET_MDC__GPIO1_IO31		0x000b1
+			>;
+		};
+
+		pinctrl_enet_4: enetgrp-4 {
+			fsl,pins = <
+				/* RMII 50 MHz */
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN	0x100f5
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN	0x100f5
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0	0x100c0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1	0x100c0
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0	0x100f5
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1	0x100f5
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x40010040
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05		0x40000058
+				/* GPIO for "link active" */
+				MX6QDL_PAD_ENET_RX_ER__GPIO1_IO24	0x40000058
+			>;
+		};
+
+		pinctrl_pwm2_2: pwm2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_1__PWM2_OUT		0x00058
+			>;
+		};
+
+		pinctrl_pwm3_2: pwm3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT1__PWM3_OUT		0x00058
+			>;
+		};
+
+		pinctrl_flexcan1_3: flexcan1grp-3 {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_7__FLEXCAN1_TX		0x80000000
+				MX6QDL_PAD_GPIO_8__FLEXCAN1_RX		0x80000000
+				MX6QDL_PAD_EIM_D31__GPIO3_IO31		0x13000		/* CAN RS */
+			>;
+		};
+
+		pinctrl_usdhc3_2: usdhc3grp-2 {
+			fsl,pins = <
+				/* SoC internal pull up required */
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17059
+				/* SoC internal pull up required */
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x4001b040	/* WP */
+				/* SoC internal pull up required */
+				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x4001b040	/* CD */
+			>;
+		};
+
+		pinctrl_usdhc3_100mhz: usdhc3grp100mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x170b9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x100b9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x170b9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x170b9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x170b9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x170b9
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x4001b040
+				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x4001b040
+			>;
+		};
+
+		pinctrl_usdhc3_200mhz: usdhc3grp200mhz {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x170f9
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x100f9
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x170f9
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x170f9
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x170f9
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x170f9
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01		0x4001b040
+				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00		0x4001b040
+			>;
+		};
+
+		pinctrl_i2c2_2: i2c2grp-2 {
+			fsl,pins = <
+				/* internal 22 k pull up required */
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001F878
+				/* internal 22 k pull up required */
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001F878
+			>;
+		};
+
+		pinctrl_i2c3_2: i2c3grp-2 {
+			fsl,pins = <
+				/* external 10 k pull up */
+				MX6QDL_PAD_GPIO_3__I2C3_SCL		0x40010878
+				/* external 10 k pull up */
+				MX6QDL_PAD_GPIO_6__I2C3_SDA		0x40010878
+			>;
+		};
+
+		pinctrl_ipu1_4: ipu1grp-4 {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK	0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15		0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02		0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03		0x10
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00	0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01	0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02	0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03	0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04	0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05	0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06	0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07	0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08	0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09	0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10	0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11	0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12	0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13	0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14	0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15	0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16	0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17	0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18	0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19	0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20	0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21	0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22	0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23	0x10
+			>;
+		};
+
+		pinctrl_uart2_1: uart2grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA	0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_gpmi_nand_2: gpmi-nand-2 {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_CLE__NAND_CLE		0xb0b1
+				MX6QDL_PAD_NANDF_ALE__NAND_ALE		0xb0b1
+				MX6QDL_PAD_NANDF_RB0__NAND_READY_B	0xb000
+				MX6QDL_PAD_NANDF_CS0__NAND_CE0_B	0xb0b1
+				MX6QDL_PAD_NANDF_CS1__NAND_CE1_B	0xb0b1
+				MX6QDL_PAD_SD4_CMD__NAND_RE_B		0xb0b1
+				MX6QDL_PAD_SD4_CLK__NAND_WE_B		0xb0b1
+				MX6QDL_PAD_NANDF_D0__NAND_DATA00	0xb0b1
+				MX6QDL_PAD_NANDF_D1__NAND_DATA01	0xb0b1
+				MX6QDL_PAD_NANDF_D2__NAND_DATA02	0xb0b1
+				MX6QDL_PAD_NANDF_D3__NAND_DATA03	0xb0b1
+				MX6QDL_PAD_NANDF_D4__NAND_DATA04	0xb0b1
+				MX6QDL_PAD_NANDF_D5__NAND_DATA05	0xb0b1
+				MX6QDL_PAD_NANDF_D6__NAND_DATA06	0xb0b1
+				MX6QDL_PAD_NANDF_D7__NAND_DATA07	0xb0b1
+			>;
+		};
+	};
+};
+
+&pwm2 {
+	/* used for backlight brightness */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2_2>;
+	status = "okay";
+};
+
+&pwm3 {
+	/* used for LCD contrast control */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm3_2>;
+	status = "okay";
+};
+
+&can1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1_3>;
+	xceiver-supply = <&reg_3p3v>;
+	status = "okay";
+};
+
+&usbh1 {
+	vbus-supply = <&reg_usb_h1_vbus>;
+	disable-over-current;
+        status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	disable-over-current;
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2_1>;
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3_2>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	wp-gpios = <&gpio7 1 GPIO_ACTIVE_HIGH>; /* e.g. low if not 'locked' */
+	cd-gpios = <&gpio7 0 GPIO_ACTIVE_LOW>; /* e.g. high if no card is plugged in */
+	status = "okay";
+	cap-power-off-card;
+	full-pwr-cycle;
+	bus-width = <4>;
+	max-frequency = <50000000>;
+	cap-sd-highspeed;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	sd-uhs-ddr50;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+	vmmc-supply = <&vcc_mmc>;
+	vqmmc-supply = <&iovcc_mmc>;
+	fsl,delay-line;
+};
