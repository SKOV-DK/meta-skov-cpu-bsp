From 6968a93200d8a27cc6443f7dae4212dfc0f404c3 Mon Sep 17 00:00:00 2001
From: Sam Ravnborg <srn@skov.dk>
Date: Sat, 28 Jan 2017 16:15:26 +0100
Subject: [PATCH] micrel: support write to registers via regmap

Update the existing regmap support to support writes to
the micrel phy registers.

- Enable write support in regmap
- in mdio-bitbang update SMI0 support
  - Encode phy + reg from the reg parameter alone
    With this change callers do not need to use the
    phy parameter to specify read/write, and existing
    helper methods can be used to read/write
- micrel-smi updated to utilize the helper methods
  and simplified the code in the process
- fixed write support
- added list of RO registers

Sigend-off-by: Sam Ravnborg <sam@ravnborg.org>
---
 drivers/base/regmap/regmap-debugfs.c |  2 +-
 drivers/net/phy/mdio-bitbang.c       | 23 ++++++++++-
 drivers/net/phy/micrel-smi.c         | 78 ++++++++++++++++++++----------------
 include/linux/phy.h                  |  1 +
 4 files changed, 67 insertions(+), 37 deletions(-)

diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index 3f0a7e2..2437186 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -259,7 +259,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
 				   count, ppos);
 }
 
-#undef REGMAP_ALLOW_WRITE_DEBUGFS
+#define REGMAP_ALLOW_WRITE_DEBUGFS
 #ifdef REGMAP_ALLOW_WRITE_DEBUGFS
 /*
  * This can be dangerous especially when we have clients such as
diff --git a/drivers/net/phy/mdio-bitbang.c b/drivers/net/phy/mdio-bitbang.c
index b118236..5e0bbf7 100644
--- a/drivers/net/phy/mdio-bitbang.c
+++ b/drivers/net/phy/mdio-bitbang.c
@@ -25,6 +25,10 @@
 #define MDIO_READ 2
 #define MDIO_WRITE 1
 
+#define SMI0_RW_OPCODE	0
+#define SMI0_READ_PHY	(1 << 4)
+#define SMI0_WRITE_PHY	(0 << 4)
+
 #define MDIO_C45 (1<<15)
 #define MDIO_C45_ADDR (MDIO_C45 | 0)
 #define MDIO_C45_READ (MDIO_C45 | 3)
@@ -152,6 +156,21 @@ static int mdiobb_cmd_addr(struct mdiobb_ctrl *ctrl, int phy, u32 addr)
 	return dev_addr;
 }
 
+/* Serial Management Interface (SMI) uses the following frame format:
+ *
+ *       preamble|start|Read/Write|  PHY   |  REG  |TA|   Data bits      | Idle
+ *               |frame| OP code  |address |address|  |                  |
+ * read | 32x1´s | 01  |    00    | 1xRRR  | RRRRR |Z0| 00000000DDDDDDDD |  Z
+ * write| 32x1´s | 01  |    00    | 0xRRR  | RRRRR |10| xxxxxxxxDDDDDDDD |  Z
+ *
+ * The register number is encoded with the 5 least significant bits in REG
+ * and the 3 most significant bits in PHY
+ */
+static int smi0_phy(int reg, int rw)
+{
+	return ((reg & 0xE0) >> 5) | rw;
+}
+
 static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 {
 	struct mdiobb_ctrl *ctrl = bus->priv;
@@ -161,7 +180,7 @@ static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_READ, phy, reg);
 	} else if (reg & MII_ADDR_SMI0) {
-		mdiobb_cmd(ctrl, 0, phy, reg);
+		mdiobb_cmd(ctrl, SMI0_RW_OPCODE, smi0_phy(reg, SMI0_READ_PHY), reg);
 	} else
 		mdiobb_cmd(ctrl, MDIO_READ, phy, reg);
 
@@ -194,7 +213,7 @@ static int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_WRITE, phy, reg);
 	} else if (reg & MII_ADDR_SMI0) {
-		mdiobb_cmd(ctrl, 0, phy, reg);
+		mdiobb_cmd(ctrl, SMI0_RW_OPCODE, smi0_phy(reg, SMI0_WRITE_PHY), reg);
 	} else
 		mdiobb_cmd(ctrl, MDIO_WRITE, phy, reg);
 
diff --git a/drivers/net/phy/micrel-smi.c b/drivers/net/phy/micrel-smi.c
index 143a1ec..4e74e76 100644
--- a/drivers/net/phy/micrel-smi.c
+++ b/drivers/net/phy/micrel-smi.c
@@ -38,74 +38,84 @@ struct ksz8873_priv {
 	unsigned int nregs;
 };
 
-static int micrel_ksz8873_read(void *context, const void *reg, size_t reg_size,
-			  void *val, size_t val_size)
+static int ksz8873_read(void *context,
+			const void *reg_buf, size_t reg_size,
+			void *val_buf, size_t val_size)
 {
 	struct ksz8873_priv *priv = context;
-	struct phy_device *phydev = priv->phydev;
-	unsigned int offset = *(u32 *)reg;
-	unsigned int phy;
+	unsigned int reg = *(u32 *)reg_buf;
 	int ret;
 
-	phy = (offset >> 5);
-	/* read needs first phy bit to be 1 */
-	phy |= 0x10;
-
-	offset &= 0x1f;
-	/* we flag the reg value with SMI0 to get opcode 0 */
-	offset |= MII_ADDR_SMI0;
-
-	ret = mdiobus_read(phydev->bus, phy, offset);
+	ret = phy_read(priv->phydev, reg | MII_ADDR_SMI0);
 	if (ret < 0)
 		return ret;
 
-	*(u8 *)val = ret;
+	*(u8 *)val_buf = ret;
 
 	return 0;
 }
 
-static int micrel_ksz8873_write(void *context, const void *data, size_t count)
+static int ksz8873_write(void *context, const void *data, size_t count)
 {
 	struct ksz8873_priv *priv = context;
-	struct phy_device *phydev = priv->phydev;
-	unsigned int phy;
 	int ret;
-	u16 *dout = (u16 *)data;
-	u16 reg = dout[0];
-	++dout;
-	--count;
-
-	phy = (reg >> 5);
+	u8 *buf;
 
-	reg &= 0x1f;
-	/* we flag the reg value with SMI0 to get opcode 0 */
-	reg |= MII_ADDR_SMI0;
-
-	ret = mdiobus_write(phydev->bus, phy, reg, *dout);
+	/* buf[0] is the register
+	 * buf[2] is data to write
+	 */
+	buf = (u8 *)data;
+	ret = phy_write(priv->phydev, buf[0] | MII_ADDR_SMI0, buf[2]);
 	if (ret < 0)
 		return ret;
 
-	/* Not implemented */
 	return 0;
 }
 
 static struct regmap_bus micrel_ksz8873_bus = {
-	.read = micrel_ksz8873_read,
-	.write = micrel_ksz8873_write,
+	.read = ksz8873_read,
+	.write = ksz8873_write,
 	.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,
 	.val_format_endian_default = REGMAP_ENDIAN_NATIVE,
 };
 
 static bool micrel_ksz8873_writeable_reg(struct device *dev, unsigned int reg)
 {
-	return false;
+	switch (reg) {
+		case REG_SWITCH_ID:
+		case REG_SWITCH_CTRL_5 + 1: /* Global Control 6 */
+		case REG_SWITCH_CTRL_5 + 2: /* Global Control 7 */
+		case REG_SWITCH_CTRL_5 + 3: /* Global Control 8 */
+		case REG_PORT_1_LINK_MD_CTRL:
+		case REG_PORT_1_LINK_MD_CTRL + REG_PORT_CTRL_OFFSET:
+		case REG_PORT_1_LINK_MD_CTRL + 2 * REG_PORT_CTRL_OFFSET:
+		case REG_PORT_1_LINK_MD_STATUS:
+		case REG_PORT_1_LINK_MD_STATUS + REG_PORT_CTRL_OFFSET:
+		case REG_PORT_1_LINK_MD_STATUS + 2 * REG_PORT_CTRL_OFFSET:
+		case REG_PORT_1_STATUS1:
+		case REG_PORT_1_STATUS1 + REG_PORT_CTRL_OFFSET:
+		case REG_PORT_1_STATUS1 + 2 * REG_PORT_CTRL_OFFSET:
+		case REG_IND_DATA_8:
+		case REG_SWITCH_MODE_STATUS:
+		case 0xA7: /* High-Priority Packet Buffet Reserved for Q3 */
+		case 0xA8: /* High-Priority Packet Buffet Reserved for Q2 */
+		case 0xA9: /* High-Priority Packet Buffet Reserved for Q1 */
+		case 0xAA: /* High-Priority Packet Buffet Reserved for Q0 */
+		case 0xAB: /* PM Usage Flow Control Select Mode 1 */
+		case 0xAC: /* PM Usage Flow Control Select Mode 2 */
+		case 0xAD: /* PM Usage Flow Control Select Mode 3 */
+		case 0xAE: /* PM Usage Flow Control Select Mode 4 */
+			return false;
+	}
+
+	return true;
 }
 
 static struct regmap_config micrel_ksz8873_regmap_config = {
 	.reg_bits = 16,
 	.val_bits = 8,
 	.reg_stride = 1,
-	.cache_type = REGCACHE_RBTREE,
+	.cache_type = REGCACHE_NONE,
 	.writeable_reg = micrel_ksz8873_writeable_reg,
 	.name = "micrel-ksz8873",
 };
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 97e33c4..4b2301f 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -146,6 +146,7 @@ static inline const char *phy_modes(phy_interface_t interface)
    IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */
 #define MII_ADDR_C45 (1<<30)
 
+/* Support for Serial Management Interface (SMI) */
 #define MII_ADDR_SMI0 (1<<31)
 
 struct device;
-- 
1.8.3.1

