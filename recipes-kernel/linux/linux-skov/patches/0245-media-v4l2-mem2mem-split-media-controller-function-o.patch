From: Philipp Zabel <p.zabel@pengutronix.de>
Date: Thu, 25 Nov 2021 16:30:15 +0100
Subject: [PATCH] media: v4l2-mem2mem: split media controller function out of
 v4l2_m2m_dev

Move the media controller structures out of struct v4l2_m2m_dev into
a new struct v4l2_m2m_func to support mem2mem devices with multiple
functions that have to share a single v4l2_m2m_dev, such as coda and
hantro.

struct v4l2_m2m_dev is made public so these drivers can integrate it
into their driver structures.

This adds new API v4l2_m2m_(un)register_media_function(). While at it,
drop an unreachable return 0 from v4l2_m2m_register_media_controller().

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 drivers/media/v4l2-core/v4l2-mem2mem.c | 140 +++++++++++++++++----------------
 include/media/v4l2-mem2mem.h           |  38 +++++++++
 2 files changed, 109 insertions(+), 69 deletions(-)

diff --git a/drivers/media/v4l2-core/v4l2-mem2mem.c b/drivers/media/v4l2-core/v4l2-mem2mem.c
index 675e22895ebe..422c93a47307 100644
--- a/drivers/media/v4l2-core/v4l2-mem2mem.c
+++ b/drivers/media/v4l2-core/v4l2-mem2mem.c
@@ -66,25 +66,10 @@ static const char * const m2m_entity_name[] = {
 
 /**
  * struct v4l2_m2m_dev - per-device context
- * @source:		&struct media_entity pointer with the source entity
- *			Used only when the M2M device is registered via
- *			v4l2_m2m_unregister_media_controller().
- * @source_pad:		&struct media_pad with the source pad.
- *			Used only when the M2M device is registered via
- *			v4l2_m2m_unregister_media_controller().
- * @sink:		&struct media_entity pointer with the sink entity
- *			Used only when the M2M device is registered via
- *			v4l2_m2m_unregister_media_controller().
- * @sink_pad:		&struct media_pad with the sink pad.
- *			Used only when the M2M device is registered via
- *			v4l2_m2m_unregister_media_controller().
- * @proc:		&struct media_entity pointer with the M2M device itself.
- * @proc_pads:		&struct media_pad with the @proc pads.
- *			Used only when the M2M device is registered via
- *			v4l2_m2m_unregister_media_controller().
- * @intf_devnode:	&struct media_intf devnode pointer with the interface
- *			with controls the M2M device.
  * @curr_ctx:		currently running instance
+ * @m2m_func:		media controller function entities
+ *			Used only when the M2M device is registered via
+ *			v4l2_m2m_register_media_controller().
  * @job_queue:		instances queued to run
  * @job_spinlock:	protects job_queue
  * @job_work:		worker to run queued jobs.
@@ -94,13 +79,7 @@ static const char * const m2m_entity_name[] = {
 struct v4l2_m2m_dev {
 	struct v4l2_m2m_ctx	*curr_ctx;
 #ifdef CONFIG_MEDIA_CONTROLLER
-	struct media_entity	*source;
-	struct media_pad	source_pad;
-	struct media_entity	sink;
-	struct media_pad	sink_pad;
-	struct media_entity	proc;
-	struct media_pad	proc_pads[2];
-	struct media_intf_devnode *intf_devnode;
+	struct v4l2_m2m_func	*m2m_func;
 #endif
 
 	struct list_head	job_queue;
@@ -1017,25 +996,32 @@ EXPORT_SYMBOL_GPL(v4l2_m2m_get_unmapped_area);
 #endif
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
-void v4l2_m2m_unregister_media_controller(struct v4l2_m2m_dev *m2m_dev)
+void v4l2_m2m_unregister_media_function(struct v4l2_m2m_func *m2m_func)
 {
-	media_remove_intf_links(&m2m_dev->intf_devnode->intf);
-	media_devnode_remove(m2m_dev->intf_devnode);
+	media_remove_intf_links(&m2m_func->intf_devnode->intf);
+	media_devnode_remove(m2m_func->intf_devnode);
 
-	media_entity_remove_links(m2m_dev->source);
-	media_entity_remove_links(&m2m_dev->sink);
-	media_entity_remove_links(&m2m_dev->proc);
-	media_device_unregister_entity(m2m_dev->source);
-	media_device_unregister_entity(&m2m_dev->sink);
-	media_device_unregister_entity(&m2m_dev->proc);
-	kfree(m2m_dev->source->name);
-	kfree(m2m_dev->sink.name);
-	kfree(m2m_dev->proc.name);
+	media_entity_remove_links(m2m_func->source);
+	media_entity_remove_links(&m2m_func->sink);
+	media_entity_remove_links(&m2m_func->proc);
+	media_device_unregister_entity(m2m_func->source);
+	media_device_unregister_entity(&m2m_func->sink);
+	media_device_unregister_entity(&m2m_func->proc);
+	kfree(m2m_func->source->name);
+	kfree(m2m_func->sink.name);
+	kfree(m2m_func->proc.name);
+}
+EXPORT_SYMBOL_GPL(v4l2_m2m_unregister_media_function);
+
+void v4l2_m2m_unregister_media_controller(struct v4l2_m2m_dev *m2m_dev)
+{
+	v4l2_m2m_unregister_media_function(m2m_dev->m2m_func);
+	kfree(m2m_dev->m2m_func);
 }
 EXPORT_SYMBOL_GPL(v4l2_m2m_unregister_media_controller);
 
 static int v4l2_m2m_register_entity(struct media_device *mdev,
-	struct v4l2_m2m_dev *m2m_dev, enum v4l2_m2m_entity_type type,
+	struct v4l2_m2m_func *m2m_func, enum v4l2_m2m_entity_type type,
 	struct video_device *vdev, int function)
 {
 	struct media_entity *entity;
@@ -1047,20 +1033,20 @@ static int v4l2_m2m_register_entity(struct media_device *mdev,
 
 	switch (type) {
 	case MEM2MEM_ENT_TYPE_SOURCE:
-		entity = m2m_dev->source;
-		pads = &m2m_dev->source_pad;
+		entity = m2m_func->source;
+		pads = &m2m_func->source_pad;
 		pads[0].flags = MEDIA_PAD_FL_SOURCE;
 		num_pads = 1;
 		break;
 	case MEM2MEM_ENT_TYPE_SINK:
-		entity = &m2m_dev->sink;
-		pads = &m2m_dev->sink_pad;
+		entity = &m2m_func->sink;
+		pads = &m2m_func->sink_pad;
 		pads[0].flags = MEDIA_PAD_FL_SINK;
 		num_pads = 1;
 		break;
 	case MEM2MEM_ENT_TYPE_PROC:
-		entity = &m2m_dev->proc;
-		pads = m2m_dev->proc_pads;
+		entity = &m2m_func->proc;
+		pads = m2m_func->proc_pads;
 		pads[0].flags = MEDIA_PAD_FL_SINK;
 		pads[1].flags = MEDIA_PAD_FL_SOURCE;
 		num_pads = 2;
@@ -1092,7 +1078,7 @@ static int v4l2_m2m_register_entity(struct media_device *mdev,
 	return 0;
 }
 
-int v4l2_m2m_register_media_controller(struct v4l2_m2m_dev *m2m_dev,
+int v4l2_m2m_register_media_function(struct v4l2_m2m_func *m2m_func,
 		struct video_device *vdev, int function)
 {
 	struct media_device *mdev = vdev->v4l2_dev->mdev;
@@ -1108,51 +1094,51 @@ int v4l2_m2m_register_media_controller(struct v4l2_m2m_dev *m2m_dev,
 	 */
 
 	/* Create the three entities with their pads */
-	m2m_dev->source = &vdev->entity;
-	ret = v4l2_m2m_register_entity(mdev, m2m_dev,
+	m2m_func->source = &vdev->entity;
+	ret = v4l2_m2m_register_entity(mdev, m2m_func,
 			MEM2MEM_ENT_TYPE_SOURCE, vdev, MEDIA_ENT_F_IO_V4L);
 	if (ret)
 		return ret;
-	ret = v4l2_m2m_register_entity(mdev, m2m_dev,
+	ret = v4l2_m2m_register_entity(mdev, m2m_func,
 			MEM2MEM_ENT_TYPE_PROC, vdev, function);
 	if (ret)
 		goto err_rel_entity0;
-	ret = v4l2_m2m_register_entity(mdev, m2m_dev,
+	ret = v4l2_m2m_register_entity(mdev, m2m_func,
 			MEM2MEM_ENT_TYPE_SINK, vdev, MEDIA_ENT_F_IO_V4L);
 	if (ret)
 		goto err_rel_entity1;
 
 	/* Connect the three entities */
-	ret = media_create_pad_link(m2m_dev->source, 0, &m2m_dev->proc, 0,
+	ret = media_create_pad_link(m2m_func->source, 0, &m2m_func->proc, 0,
 			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
 	if (ret)
 		goto err_rel_entity2;
 
-	ret = media_create_pad_link(&m2m_dev->proc, 1, &m2m_dev->sink, 0,
+	ret = media_create_pad_link(&m2m_func->proc, 1, &m2m_func->sink, 0,
 			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
 	if (ret)
 		goto err_rm_links0;
 
 	/* Create video interface */
-	m2m_dev->intf_devnode = media_devnode_create(mdev,
+	m2m_func->intf_devnode = media_devnode_create(mdev,
 			MEDIA_INTF_T_V4L_VIDEO, 0,
 			VIDEO_MAJOR, vdev->minor);
-	if (!m2m_dev->intf_devnode) {
+	if (!m2m_func->intf_devnode) {
 		ret = -ENOMEM;
 		goto err_rm_links1;
 	}
 
 	/* Connect the two DMA engines to the interface */
-	link = media_create_intf_link(m2m_dev->source,
-			&m2m_dev->intf_devnode->intf,
+	link = media_create_intf_link(m2m_func->source,
+			&m2m_func->intf_devnode->intf,
 			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
 	if (!link) {
 		ret = -ENOMEM;
 		goto err_rm_devnode;
 	}
 
-	link = media_create_intf_link(&m2m_dev->sink,
-			&m2m_dev->intf_devnode->intf,
+	link = media_create_intf_link(&m2m_func->sink,
+			&m2m_func->intf_devnode->intf,
 			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
 	if (!link) {
 		ret = -ENOMEM;
@@ -1161,25 +1147,41 @@ int v4l2_m2m_register_media_controller(struct v4l2_m2m_dev *m2m_dev,
 	return 0;
 
 err_rm_intf_link:
-	media_remove_intf_links(&m2m_dev->intf_devnode->intf);
+	media_remove_intf_links(&m2m_func->intf_devnode->intf);
 err_rm_devnode:
-	media_devnode_remove(m2m_dev->intf_devnode);
+	media_devnode_remove(m2m_func->intf_devnode);
 err_rm_links1:
-	media_entity_remove_links(&m2m_dev->sink);
+	media_entity_remove_links(&m2m_func->sink);
 err_rm_links0:
-	media_entity_remove_links(&m2m_dev->proc);
-	media_entity_remove_links(m2m_dev->source);
+	media_entity_remove_links(&m2m_func->proc);
+	media_entity_remove_links(m2m_func->source);
 err_rel_entity2:
-	media_device_unregister_entity(&m2m_dev->proc);
-	kfree(m2m_dev->proc.name);
+	media_device_unregister_entity(&m2m_func->proc);
+	kfree(m2m_func->proc.name);
 err_rel_entity1:
-	media_device_unregister_entity(&m2m_dev->sink);
-	kfree(m2m_dev->sink.name);
+	media_device_unregister_entity(&m2m_func->sink);
+	kfree(m2m_func->sink.name);
 err_rel_entity0:
-	media_device_unregister_entity(m2m_dev->source);
-	kfree(m2m_dev->source->name);
+	media_device_unregister_entity(m2m_func->source);
+	kfree(m2m_func->source->name);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(v4l2_m2m_register_media_function);
+
+int v4l2_m2m_register_media_controller(struct v4l2_m2m_dev *m2m_dev,
+		struct video_device *vdev, int function)
+{
+	int ret;
+
+	m2m_dev->m2m_func = kzalloc(sizeof(*m2m_dev->m2m_func), GFP_KERNEL);
+	if (!m2m_dev->m2m_func)
+		return -ENOMEM;
+
+	ret = v4l2_m2m_register_media_function(m2m_dev->m2m_func, vdev, function);
+	if (ret)
+		kfree(m2m_dev->m2m_func);
+
 	return ret;
-	return 0;
 }
 EXPORT_SYMBOL_GPL(v4l2_m2m_register_media_controller);
 #endif
diff --git a/include/media/v4l2-mem2mem.h b/include/media/v4l2-mem2mem.h
index fdbd5257e020..017cbb9dd5f7 100644
--- a/include/media/v4l2-mem2mem.h
+++ b/include/media/v4l2-mem2mem.h
@@ -13,6 +13,7 @@
 #ifndef _MEDIA_V4L2_MEM2MEM_H
 #define _MEDIA_V4L2_MEM2MEM_H
 
+#include <media/media-entity.h>
 #include <media/videobuf2-v4l2.h>
 
 /**
@@ -47,6 +48,7 @@ struct v4l2_m2m_ops {
 
 struct video_device;
 struct v4l2_m2m_dev;
+struct v4l2_m2m_func;
 
 /**
  * struct v4l2_m2m_queue_ctx - represents a queue for buffers ready to be
@@ -133,6 +135,27 @@ struct v4l2_m2m_buffer {
 	struct list_head	list;
 };
 
+/**
+ * struct v4l2_m2m_func - per-function media controller context
+ * @source:		&struct media_entity pointer with the source entity
+ * @source_pad:		&struct media_pad with the source pad.
+ * @sink:		&struct media_entity pointer with the sink entity
+ * @sink_pad:		&struct media_pad with the sink pad.
+ * @proc:		&struct media_entity pointer with the M2M device itself.
+ * @proc_pads:		&struct media_pad with the @proc pads.
+ * @intf_devnode:	&struct media_intf devnode pointer with the interface
+ *			with controls the M2M device.
+ */
+struct v4l2_m2m_func {
+	struct media_entity	*source;
+	struct media_pad	source_pad;
+	struct media_entity	sink;
+	struct media_pad	sink_pad;
+	struct media_entity	proc;
+	struct media_pad	proc_pads[2];
+	struct media_intf_devnode *intf_devnode;
+};
+
 /**
  * v4l2_m2m_get_curr_priv() - return driver private data for the currently
  * running instance or NULL if no instance is running
@@ -513,20 +536,35 @@ struct v4l2_m2m_dev *v4l2_m2m_init(const struct v4l2_m2m_ops *m2m_ops);
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
 void v4l2_m2m_unregister_media_controller(struct v4l2_m2m_dev *m2m_dev);
+void v4l2_m2m_unregister_media_function(struct v4l2_m2m_func *m2m_func);
 int v4l2_m2m_register_media_controller(struct v4l2_m2m_dev *m2m_dev,
 			struct video_device *vdev, int function);
+int v4l2_m2m_register_media_function(struct v4l2_m2m_func *m2m_func,
+			struct video_device *vdev, int function);
 #else
 static inline void
 v4l2_m2m_unregister_media_controller(struct v4l2_m2m_dev *m2m_dev)
 {
 }
 
+static inline void
+v4l2_m2m_unregister_media_function(struct v4l2_m2m_func *m2m_func)
+{
+}
+
 static inline int
 v4l2_m2m_register_media_controller(struct v4l2_m2m_dev *m2m_dev,
 		struct video_device *vdev, int function)
 {
 	return 0;
 }
+
+static inline int
+v4l2_m2m_register_media_function(struct v4l2_m2m_func *m2m_func,
+		struct video_device *vdev, int function)
+{
+	return 0;
+}
 #endif
 
 /**
