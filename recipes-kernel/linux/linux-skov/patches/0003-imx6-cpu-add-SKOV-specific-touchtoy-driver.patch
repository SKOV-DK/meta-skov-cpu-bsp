From: Kim Christensen <kch@skov.dk>
Date: Fri, 13 Sep 2019 08:55:50 +0200
Subject: [PATCH] imx6-cpu: add SKOV specific touchtoy driver

This driver's purpose is to test the application receiving touch events.

Signed-off-by: Kim Christensen <kch@skov.dk>
---
 drivers/skov/Kconfig    |  16 ++++
 drivers/skov/Makefile   |   1 +
 drivers/skov/touchtoy.c | 205 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 222 insertions(+)
 create mode 100644 drivers/skov/touchtoy.c

diff --git a/drivers/skov/Kconfig b/drivers/skov/Kconfig
index c7d0b7e0c32a..021db21bf754 100644
--- a/drivers/skov/Kconfig
+++ b/drivers/skov/Kconfig
@@ -9,4 +9,20 @@ config SKOV_VERSION
           configurations. If it shows unknown the kernel is too old and a
           newer kernel with an updated database need to be installed.
 
+config TOUCHTOY
+        tristate "Touch driver to test application receiving touch events"
+        default m
+        help
+          How to use touchtoy:
+          modprobe touchtoy
+
+          send data:
+          echo <x> <y> <pressure> > /dev/touchtoy
+          <pressure>: 0 .. 100, 0 is finger up, != 0 is finger down
+
+          Finger press example
+          echo 50 100 50 > /dev/touchtoy
+          sleep(100ms)
+          echo 50 100 0 > /dev/touchtoyDriver for the version Input pins.
+
 endmenu
diff --git a/drivers/skov/Makefile b/drivers/skov/Makefile
index d6068949425b..d08bedefab90 100644
--- a/drivers/skov/Makefile
+++ b/drivers/skov/Makefile
@@ -1 +1,2 @@
 obj-$(CONFIG_SKOV_VERSION)      += skov_version.o
+obj-$(CONFIG_TOUCHTOY)          += touchtoy.o
diff --git a/drivers/skov/touchtoy.c b/drivers/skov/touchtoy.c
new file mode 100644
index 000000000000..633572083169
--- /dev/null
+++ b/drivers/skov/touchtoy.c
@@ -0,0 +1,205 @@
+/*
+ * Touch driver to test application receiving touch events
+ *
+ * Copyright (C) 2019 SKOV A/S Denmark
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Send feedback to <cwe@skov.com>
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+
+MODULE_AUTHOR("Christian Wendt <cwe@skov.com>");
+MODULE_LICENSE("GPL");
+
+typedef struct {
+	struct input_dev	*input;
+	bool			pendown;
+} touchtoy_t;
+
+static touchtoy_t *tt;
+
+static int touchtoy_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static int touchtoy_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t touchtoy_write(struct file *filp, const char __user *ubuf, size_t count, loff_t *f_pos)
+{
+	char buffer[128 + 1];
+	char *x_s, *y_s, *p_s, *q_s;
+	u16 x, y, p;
+	ssize_t ret;
+
+	if (count > sizeof(buffer) - 1) {
+		count = sizeof(buffer) - 1;
+	}
+
+	ret = copy_from_user(buffer, ubuf, count);
+	if (ret) {
+		printk("%s:%u: %d\n", __FUNCTION__, __LINE__, ret);
+		return ret;
+	}
+	buffer[count] = '\0';
+
+	x_s = buffer;
+	y_s = strchr(x_s, ' ');
+	if (!y_s) {
+		printk("%s:%u: %d\n", __FUNCTION__, __LINE__, -EINVAL);
+		return -EINVAL;
+	} else {
+		*y_s++ = '\0';
+	}
+	p_s = strchr(y_s, ' ');
+	if (!p_s) {
+		printk("%s:%u: %d\n", __FUNCTION__, __LINE__, -EINVAL);
+		return -EINVAL;
+	} else {
+		*p_s++ = '\0';
+	}
+	q_s = strchr(p_s, '\n');
+	if (q_s) {
+		*q_s = '\0';
+	}
+
+	ret = kstrtou16(x_s, 10, &x);
+	if (ret < 0) {
+		printk("%s:%u: %d\n", __FUNCTION__, __LINE__, -EINVAL);
+		return ret;
+	}
+	ret = kstrtou16(y_s, 10, &y);
+	if (ret < 0) {
+		printk("%s:%u: %d\n", __FUNCTION__, __LINE__, -EINVAL);
+		return ret;
+	}
+	ret = kstrtou16(p_s, 10, &p);
+	if (ret < 0) {
+		printk("%s:%u: %d\n", __FUNCTION__, __LINE__, -EINVAL);
+		return ret;
+	}
+
+	if (p > 0) {
+		if (!tt->pendown) {
+			input_report_key(tt->input, BTN_TOUCH, 1);
+			tt->pendown = true;
+		}
+		input_report_abs(tt->input, ABS_X, x);
+		input_report_abs(tt->input, ABS_Y, y);
+		input_report_abs(tt->input, ABS_PRESSURE, p);
+		input_sync(tt->input);
+	} else {
+		if (tt->pendown) {
+			input_report_key(tt->input, BTN_TOUCH, 0);
+			input_report_abs(tt->input, ABS_PRESSURE, 0);
+			input_sync(tt->input);
+			tt->pendown = false;
+		}
+	}
+
+	return count;
+}
+
+static const struct file_operations touchtoy_fops = {
+	.write = touchtoy_write,
+	.open = touchtoy_open,
+	.release = touchtoy_release,
+	.llseek = noop_llseek,
+
+};
+
+static struct miscdevice touchtoy_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "touchtoy",
+	.fops = &touchtoy_fops,
+};
+
+static int __init touchtoy_init(void)
+{
+	struct input_dev *input = NULL;
+	int err;
+
+	tt = kzalloc(sizeof(touchtoy_t), GFP_KERNEL);
+	if (!tt) {
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	input = input_allocate_device();
+	if (!input) {
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	tt->input = input;
+
+	input->name = "TouchToy";
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(input, ABS_X, 0, 1280, 0, 0);
+	input_set_abs_params(input, ABS_Y, 0,  800, 0, 0);
+	input_set_abs_params(input, ABS_PRESSURE, 0, 100, 0, 0);
+
+	err = input_register_device(input);
+	if (err < 0) {
+		printk(KERN_ERR "touchtoy: misc_register returns %d.\n", err);
+		goto err_input_register;
+	}
+
+	err = misc_register(&touchtoy_miscdev);
+	if (err < 0) {
+		printk(KERN_ERR "touchtoy: misc_register returns %d.\n", err);
+		goto err_misc_register;
+	}
+
+	return 0;
+
+err_misc_register:
+	input_unregister_device(input);
+err_input_register:
+err_free_mem:
+	kfree(tt->input);
+	kfree(tt);
+	return err;
+}
+
+static void __exit touchtoy_cleanup(void)
+{
+	misc_deregister(&touchtoy_miscdev);
+	input_unregister_device(tt->input);
+	kfree(tt->input);
+	kfree(tt);
+}
+
+module_init(touchtoy_init);
+module_exit(touchtoy_cleanup);
