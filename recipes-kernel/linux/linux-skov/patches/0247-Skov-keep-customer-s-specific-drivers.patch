From: =?UTF-8?q?S=C3=B8ren=20Andersen?= <san@rosetechnology.dk>
Date: Mon, 7 Dec 2015 13:17:54 +0100
Subject: [PATCH] Skov: keep customer's specific drivers

Acked-by: Juergen Borleis <jbe@pengutronix.de>
---
 drivers/Kconfig             |   2 +
 drivers/Makefile            |   1 +
 drivers/skov/Kconfig        |  18 +++
 drivers/skov/Makefile       |   2 +
 drivers/skov/mem_peek.c     | 163 +++++++++++++++++++++
 drivers/skov/skov_version.c | 341 ++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 527 insertions(+)
 create mode 100644 drivers/skov/Kconfig
 create mode 100644 drivers/skov/Makefile
 create mode 100644 drivers/skov/mem_peek.c
 create mode 100644 drivers/skov/skov_version.c

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 46b4a8e0f859..8ded344dc992 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -188,4 +188,6 @@ source "drivers/nvdimm/Kconfig"
 
 source "drivers/nvmem/Kconfig"
 
+source "drivers/skov/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index b250b36b54f2..03d49c2cce1f 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -167,3 +167,4 @@ obj-$(CONFIG_THUNDERBOLT)	+= thunderbolt/
 obj-$(CONFIG_CORESIGHT)		+= hwtracing/coresight/
 obj-$(CONFIG_ANDROID)		+= android/
 obj-$(CONFIG_NVMEM)		+= nvmem/
+obj-y				+= skov/
diff --git a/drivers/skov/Kconfig b/drivers/skov/Kconfig
new file mode 100644
index 000000000000..1845410e364b
--- /dev/null
+++ b/drivers/skov/Kconfig
@@ -0,0 +1,18 @@
+menu "Drivers for SKOV"
+
+config MEM_PEEK
+	bool "Mem registers"
+	default y
+	help
+	  Enable to read from registers.
+
+config SKOV_VERSION
+        tristate "SKOV Vesion"
+        default y
+        help
+          Driver for the version Input pins.
+          This driver has a database over the various Skov HW
+          configurations. If it shows unknown the kernel is too old and a
+          newer kernel with an updated database need to be installed.
+
+endmenu
diff --git a/drivers/skov/Makefile b/drivers/skov/Makefile
new file mode 100644
index 000000000000..9925771b0e0b
--- /dev/null
+++ b/drivers/skov/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_MEM_PEEK)		+= mem_peek.o
+obj-$(CONFIG_SKOV_VERSION)      += skov_version.o
diff --git a/drivers/skov/mem_peek.c b/drivers/skov/mem_peek.c
new file mode 100644
index 000000000000..61e82b4592df
--- /dev/null
+++ b/drivers/skov/mem_peek.c
@@ -0,0 +1,163 @@
+/*
+ * mem_peek.c
+ * (c) Martin Bjærre
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+
+#define err( fmt, arg... ) printk( KERN_ERR "mem_peek: %s() " fmt "\n" , __FUNCTION__, ## arg )
+#define deb( fmt, arg... ) 
+// pr_info( "DBUG mem_peek: %s() " fmt "\n" , __FUNCTION__, ## arg )
+
+static struct proc_dir_entry *pde_mem_peek_dir;
+static struct proc_dir_entry *pde_reg;
+static struct proc_dir_entry *pde_addr;
+
+static u32 reg_addr = 0x1E000000;
+
+/********************************************************************************/
+/*************************   proc_read_reg **************************/
+/********************************************************************************/
+
+static int proc_reg_show(struct seq_file *m, void *v)
+{
+	int val;
+	u32 *mapped;
+
+	mapped = ioremap(reg_addr, SZ_4K);
+	if (mapped== 0)
+		return 0;
+	val = __raw_readl(mapped);
+
+	iounmap(mapped);
+
+	seq_printf(m, "Addr=0x%08xh\tData=0x%08xh\n", reg_addr, val);
+
+	return 0;
+}
+
+static int proc_open_reg(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_reg_show, NULL);
+}
+
+/*************************************************************************/
+/*********************** proc_write_reg *****************************/
+/*************************************************************************/
+static int proc_write_reg(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	u32 val;
+	u32 *mapped;
+
+	sscanf(buf, "%x", &val);
+
+	mapped = ioremap(reg_addr, SZ_4K);
+
+	if (mapped== 0)
+		return 0;
+	__raw_writel(val, mapped);
+
+	iounmap(mapped);	
+	
+	return count;
+}
+
+/********************************************************************************/
+/*************************   proc_read_addr *************************************/
+/********************************************************************************/
+
+static int proc_addr_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "Addr=0x%08xh\n", reg_addr);
+
+	return 0;
+}
+
+static int proc_open_addr(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_addr_show, NULL);
+}
+
+/*************************************************************************/
+/*********************** proc_write_addr *********************************/
+/*************************************************************************/
+static int proc_write_addr(struct file *fp, const char __user *buf, size_t count, loff_t *pos)
+{
+	sscanf(buf, "%x", &reg_addr);
+
+	return count;
+}
+
+static const struct file_operations mem_peek_addr_fops = {
+	.open=proc_open_addr,
+	.llseek=seq_lseek,
+	.read=seq_read,
+	.write=proc_write_addr,
+	.release = single_release
+};
+
+static const struct file_operations mem_peek_reg_fops = {     
+	.open=proc_open_reg,
+	.llseek=seq_lseek,
+	.read=seq_read,  
+	.write=proc_write_reg,
+	.release = single_release
+};
+
+
+/*************************************************************************/
+/*************************   init_proc   *********************************/
+/*************************************************************************/
+void init_proc(void)
+{
+	/* create directory */
+	pde_mem_peek_dir = proc_mkdir("mem_peek", NULL);
+	if (pde_mem_peek_dir==NULL)
+		return;
+
+	pde_reg=proc_create("reg", 0666, pde_mem_peek_dir, &mem_peek_reg_fops);
+	if (pde_reg==NULL) {
+		printk("mem_peek: Error creating proc entry reg\n");
+	}
+
+	pde_addr=proc_create("addr", 0666, pde_mem_peek_dir, &mem_peek_addr_fops);
+	if (pde_addr==NULL) {
+		printk("mem_peek: Error creating proc entry addr\n");
+	}
+}
+
+/********************************************************************/
+/*************************   init   *********************************/
+/********************************************************************/
+static int __init mem_peek_init(void)
+{
+	init_proc();
+	return 0;
+}
+
+/********************************************************************/
+/*************************   exit   *********************************/
+/********************************************************************/
+static void __exit mem_peek_exit(void)
+{
+	remove_proc_entry("reg", pde_mem_peek_dir);
+	remove_proc_entry("addr", pde_mem_peek_dir);
+
+	remove_proc_entry("mem_peek", NULL);
+	printk("mem_peek: goodbye!\n");
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("ROSE");
+MODULE_DESCRIPTION("mem peek imx53");
+
+//EXPORT_NO_SYMBOLS;
+
+module_init(mem_peek_init);
+module_exit(mem_peek_exit);
+
diff --git a/drivers/skov/skov_version.c b/drivers/skov/skov_version.c
new file mode 100644
index 000000000000..b8417a333999
--- /dev/null
+++ b/drivers/skov/skov_version.c
@@ -0,0 +1,341 @@
+/*
+ * Skov version driver
+ *
+ * Copyright (C) 2013 Søren Andersen <san@rosetechnology.dk>
+ * Copyright (C) 2013 Rose Technology.
+ *
+ * Various SKOV boards and there version control configuration
+ * Resistors    - Version -         Rev - Ram    - Flash
+ * 00000000     - High Performance   A    1024MB -  1024MB
+ * 00000001     - Low Cost           A    512 MB -  256 MB - Old count
+ * 00000100     - Low Cost           A    512 MB -  256 MB - New count
+ * 00000010	- High Performance   A    1024MB -  512 MB - Old count
+ * 00001000	- High Performance   A    1024MB -  512 MB - New count
+ * 00001001	- Minium Cost	     B	  256 MB -   16 MB
+ * 00001010	- Low Cost	     B    256 MB -  256 MB
+ * 00001011	- High Performance   B	  1024MB -  256 MB
+ * 00001100	- Max  Performance   B    2028MB - 16384MB
+ * 00001101	- Low Cost	     C    256 MB -  256 MB
+ * 00001110	- High Performance   C    1024MB -  256 MB
+ *
+ */
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+
+struct skov_version_platform_data {
+	unsigned int vc0;
+	unsigned int vc1;
+	unsigned int vc2;
+	unsigned int vc3;
+	unsigned int vc4;
+	unsigned int vc5;
+	unsigned int vc6;
+	unsigned int vc7;
+	unsigned int var;
+};
+
+struct pltfm_imx_data {
+	struct clk *clk_per;
+	struct skov_version_platform_data boarddata;
+	const struct skov_version_data *socdata;
+};
+
+static const char *description[] = {
+	"Minimum Cost",
+	"Low Cost",
+	"High Performance",
+	"Maximum Performance"
+};
+
+static const unsigned int mem[] = {
+	256,
+	512,
+	1024,
+	2048,
+	3840,
+	0
+};
+
+static const char *rev[] = {
+	"A",
+	"B",
+	"C",
+	"D",
+	"E",
+	"F",
+	"G",
+	"H",
+	"I",
+	"J",
+	"K",
+};
+
+static const unsigned int nand[] = {
+	16,
+	32,
+	64,
+	128,
+	256,
+	512,
+	1024,
+	2048,
+	4096,
+	8192,
+	16384,
+	32768
+};
+
+/*
+ *
+ */
+static ssize_t show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct skov_version_platform_data *svpd = dev_get_drvdata(dev);
+
+	if (strcmp(attr->attr.name, "mem") == 0) {
+		switch(svpd->var ) {
+		case 12:
+			return sprintf(buf, "%u\n", mem[3]);
+		case 0:
+		case 2:
+		case 8:
+		case 11:
+		case 14:
+			return sprintf(buf, "%u\n", mem[2]);
+		case 1:
+		case 4:
+			return sprintf(buf, "%u\n", mem[1]);
+		case 9:
+		case 10:
+		case 13:
+			return sprintf(buf, "%u\n", mem[0]);
+		default:
+			return sprintf(buf, "%s\n", "Board type can not be detected");
+		}
+	} else if (strcmp(attr->attr.name, "rev") == 0) {
+		switch(svpd->var){
+		case 0:
+		case 1:
+		case 2:
+		case 4:
+		case 8:
+			return sprintf(buf, "%s\n", rev[0]);
+		case 9:
+		case 10:
+		case 11:
+		case 12:
+			return sprintf(buf, "%s\n", rev[1]);
+		case 13:
+		case 14:
+			return sprintf(buf, "%s\n", rev[2]);
+		default:
+                	return sprintf(buf, "%s\n", "Board type can not be detected");
+		}
+	} else if (strcmp(attr->attr.name, "description") == 0) {
+		switch(svpd->var) {
+		case 12:
+			return sprintf(buf, "%s\n", description[3]);
+		case 0:
+		case 2:
+		case 8:
+		case 11:
+		case 14:
+			return sprintf(buf, "%s\n", description[2]);
+		case 1:
+		case 4:
+		case 10:
+		case 13:
+			return sprintf(buf, "%s\n", description[1]);
+		case 9:
+			return sprintf(buf, "%s\n", description[0]);
+		default:
+			return sprintf(buf, "%s\n", "Board type can not be detected");        
+		}
+	} else if (strcmp(attr->attr.name, "nand") == 0) {
+		switch(svpd->var) {
+		case 12:
+			return sprintf(buf, "%u\n", nand[10]);
+		case 0:
+			return sprintf(buf, "%u\n", nand[6]);
+		case 1:
+		case 4:
+		case 10:
+		case 11:
+		case 13:
+		case 14:
+			return sprintf(buf, "%u\n", nand[4]);
+		case 2:
+		case 8:
+			return sprintf(buf, "%u\n", nand[5]);
+		case 9:
+			return sprintf(buf, "%u\n", nand[0]);
+		default:
+			return sprintf(buf, "%s\n", "Board type can not be detected");
+		}
+	} else if (strcmp(attr->attr.name, "raw") == 0) {
+		return sprintf(buf, "%u\n", svpd->var);
+
+	} else { /* Try to read Undefined sysfs file */
+		return sprintf(buf, "%s\n", "Requested file not found");
+	}
+
+	return sprintf(buf, "%u\n", svpd->var);
+}
+
+static struct device_attribute mem_attribute = __ATTR(mem, 0444, show, NULL);
+static struct device_attribute rev_attribute = __ATTR(rev, 0444, show, NULL);
+static struct device_attribute raw_attribute = __ATTR(raw, 0444, show, NULL);
+static struct device_attribute nand_attribute = __ATTR(nand, 0444, show, NULL);
+static struct device_attribute description_attribute =
+                                        __ATTR(description, 0444, show, NULL);
+
+/*
+ * Create a group of attributes so that we can create and destory them all
+ * at once.
+*/
+
+static struct attribute *attrs[] = {
+	&mem_attribute.attr,
+	&rev_attribute.attr,
+	&raw_attribute.attr,
+	&description_attribute.attr,
+	&nand_attribute.attr,
+	NULL,   /* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory.  If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static const struct of_device_id skov_version_dt_ids[] = {
+	{ .compatible = "skov-version" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, skov_version_dt_ids);
+
+#ifdef CONFIG_OF
+static int skov_version_probe_dt(struct platform_device *pdev,
+			struct skov_version_platform_data *boarddata)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np)
+		return -ENODEV;
+
+	boarddata->vc0 = of_get_named_gpio(np, "v0-gpio", 0);
+	boarddata->vc1 = of_get_named_gpio(np, "v1-gpio", 0);
+	boarddata->vc2 = of_get_named_gpio(np, "v2-gpio", 0);
+	boarddata->vc3 = of_get_named_gpio(np, "v3-gpio", 0);
+	boarddata->vc4 = of_get_named_gpio(np, "v4-gpio", 0);
+	boarddata->vc5 = of_get_named_gpio(np, "v5-gpio", 0);
+	boarddata->vc6 = of_get_named_gpio(np, "v6-gpio", 0);
+	boarddata->vc7 = of_get_named_gpio(np, "v7-gpio", 0);
+
+	return 0;
+}
+#else
+static inline int skov_version_probe_dt(struct platform_device *pdev,
+					struct skov_version_data *boarddata)
+{
+	return -ENODEV;
+}
+#endif
+
+static int skov_version_probe(struct platform_device *pdev)
+{
+	int retval = 0;
+	int var = 0;
+	int err;
+	const struct of_device_id *of_id =
+		of_match_device(skov_version_dt_ids, &pdev->dev);
+	struct skov_version_platform_data *boarddata;
+	struct pltfm_imx_data *imx_data;
+
+	imx_data = devm_kzalloc(&pdev->dev, sizeof(*imx_data), GFP_KERNEL);
+	if (!imx_data) {
+		err = -ENOMEM;
+		goto free_skov_ver;
+	}
+	imx_data->socdata = of_id ? of_id->data : (struct skov_version_data *)
+                                                    pdev->id_entry->driver_data;
+
+	boarddata = &imx_data->boarddata;
+	skov_version_probe_dt(pdev, boarddata);
+
+	gpio_request(boarddata->vc0, "VERSION0");
+	gpio_request(boarddata->vc1, "VERSION1");
+	gpio_request(boarddata->vc2, "VERSION2");
+	gpio_request(boarddata->vc3, "VERSION3");
+	gpio_request(boarddata->vc4, "VERSION4");
+	gpio_request(boarddata->vc5, "VERSION5");
+	gpio_request(boarddata->vc6, "VERSION6");
+	gpio_request(boarddata->vc7, "VERSION7");
+
+	gpio_direction_input(boarddata->vc0);
+	gpio_direction_input(boarddata->vc1);
+	gpio_direction_input(boarddata->vc2);
+	gpio_direction_input(boarddata->vc3);
+	gpio_direction_input(boarddata->vc4);
+	gpio_direction_input(boarddata->vc5);
+	gpio_direction_input(boarddata->vc6);
+	gpio_direction_input(boarddata->vc7);
+
+	var = (!gpio_get_value(boarddata->vc0));
+	var |= (!gpio_get_value(boarddata->vc1) << 1);
+	var |= (!gpio_get_value(boarddata->vc2) << 2);
+	var |= (!gpio_get_value(boarddata->vc3) << 3);
+	var |= (!gpio_get_value(boarddata->vc4) << 4);
+	var |= (!gpio_get_value(boarddata->vc5) << 5);
+	var |= (!gpio_get_value(boarddata->vc6) << 6);
+	var |= (!gpio_get_value(boarddata->vc7) << 7);
+
+	boarddata->var = var;
+	platform_set_drvdata(pdev, boarddata);
+
+	retval = sysfs_create_group(&pdev->dev.kobj, &attr_group);
+
+	return retval;
+
+free_skov_ver:
+	return err;
+}
+
+static int skov_version_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &attr_group);
+
+	return 0;
+}
+
+static struct platform_driver skov_version_driver = {
+	.driver = {
+		.name = "skov_version",
+		.owner = THIS_MODULE,
+		.of_match_table = skov_version_dt_ids,
+	},
+	.probe = skov_version_probe,
+	.remove = skov_version_remove,
+};
+
+module_platform_driver(skov_version_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Søren Andersen <san@rosetechnology.dk");
+MODULE_DESCRIPTION("Version Control");
