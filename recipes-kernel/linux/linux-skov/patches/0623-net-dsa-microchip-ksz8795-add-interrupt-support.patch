From: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date: Thu, 16 Jul 2020 17:37:05 +0200
Subject: [PATCH] net: dsa: microchip: ksz8795: add interrupt support

Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
---
 drivers/net/dsa/microchip/ksz8.h        |   3 +
 drivers/net/dsa/microchip/ksz8795.c     | 191 ++++++++++++++++++++++++++++++++
 drivers/net/dsa/microchip/ksz8795_reg.h |   3 -
 drivers/net/dsa/microchip/ksz_common.h  |   2 +
 4 files changed, 196 insertions(+), 3 deletions(-)

diff --git a/drivers/net/dsa/microchip/ksz8.h b/drivers/net/dsa/microchip/ksz8.h
index d3e89c27e22a..38a397ee3aa6 100644
--- a/drivers/net/dsa/microchip/ksz8.h
+++ b/drivers/net/dsa/microchip/ksz8.h
@@ -23,6 +23,8 @@ enum ksz_regs {
 	P_REMOTE_STATUS,
 	P_SPEED_STATUS,
 	S_TAIL_TAG_CTRL,
+	REG_INT_ENABLE,
+	REG_INT_STATUS,
 };
 
 enum ksz_masks {
@@ -63,6 +65,7 @@ struct ksz8 {
 	const u8 *regs;
 	const u32 *masks;
 	const u8 *shifts;
+	int irq_masked;
 	void *priv;
 };
 
diff --git a/drivers/net/dsa/microchip/ksz8795.c b/drivers/net/dsa/microchip/ksz8795.c
index b14cbc113bfd..5541c7e7a4b3 100644
--- a/drivers/net/dsa/microchip/ksz8795.c
+++ b/drivers/net/dsa/microchip/ksz8795.c
@@ -14,7 +14,10 @@
 #include <linux/platform_data/microchip-ksz.h>
 #include <linux/phy.h>
 #include <linux/etherdevice.h>
+#include <linux/of_irq.h>
 #include <linux/if_bridge.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
 #include <net/dsa.h>
 #include <net/switchdev.h>
 #include <linux/micrel_phy.h>
@@ -38,6 +41,8 @@ static const u8 ksz8795_regs[] = {
 	[P_REMOTE_STATUS]	= 0x08,
 	[P_SPEED_STATUS]	= 0x09,
 	[S_TAIL_TAG_CTRL]	= 0x0C,
+	[REG_INT_ENABLE]	= 0x7D,
+	[REG_INT_STATUS]	= 0x7C,
 };
 
 static const u32 ksz8795_masks[] = {
@@ -88,6 +93,8 @@ static const u8 ksz8863_regs[] = {
 	[P_REMOTE_STATUS]		= 0x0E,
 	[P_SPEED_STATUS]		= 0x0F,
 	[S_TAIL_TAG_CTRL]		= 0x03,
+	[REG_INT_ENABLE]		= 0xBB,
+	[REG_INT_STATUS]		= 0xBC,
 };
 
 static const u32 ksz8863_masks[] = {
@@ -1333,6 +1340,186 @@ static void ksz8_config_cpu_port(struct dsa_switch *ds)
 	}
 }
 
+static void ksz8_mask_irq(struct irq_data *d)
+{
+	struct ksz_device *dev = irq_data_get_irq_chip_data(d);
+	struct ksz8 *ksz8 = dev->priv;
+
+	ksz8->irq_masked &= ~BIT(irqd_to_hwirq(d));
+}
+
+static void ksz8_unmask_irq(struct irq_data *d)
+{
+	struct ksz_device *dev = irq_data_get_irq_chip_data(d);
+	struct ksz8 *ksz8 = dev->priv;
+
+	ksz8->irq_masked |= BIT(irqd_to_hwirq(d));
+}
+
+static irqreturn_t ksz8_irq(int irq, void *data)
+{
+	struct ksz_device *dev = data;
+	struct ksz8 *ksz8 = dev->priv;
+	const u8 *regs = ksz8->regs;
+	u8 stat;
+	int ret;
+
+	/* This clears the IRQ status register */
+	ret = ksz_read8(dev, regs[REG_INT_STATUS], &stat);
+	if (ret) {
+		dev_err(dev->dev, "can't read interrupt status\n");
+		return IRQ_NONE;
+	}
+
+	ret = ksz_write8(dev, regs[REG_INT_STATUS], GENMASK(7,0));
+	if (ret) {
+		dev_err(dev->dev, "can't write back interrupt status\n");
+		return IRQ_NONE;
+	}
+
+	stat &= GENMASK(1,0);
+
+	if (!stat)
+		return IRQ_NONE;
+
+	while (stat) {
+		int line = __ffs(stat);
+		int child_irq;
+
+		stat &= ~BIT(line);
+
+		child_irq = irq_find_mapping(dev->irqdomain, line);
+		handle_nested_irq(child_irq);
+	}
+	return IRQ_HANDLED;
+}
+
+static void ksz8_irq_bus_lock(struct irq_data *d)
+{
+	struct ksz_device *dev = irq_data_get_irq_chip_data(d);
+
+	mutex_lock(&dev->dev_mutex);
+}
+
+static void ksz8_irq_bus_sync_unlock(struct irq_data *d)
+{
+	struct ksz_device *dev = irq_data_get_irq_chip_data(d);
+	struct ksz8 *ksz8 = dev->priv;
+	const u8 *regs = ksz8->regs;
+	int ret;
+
+	ret = ksz_cfg(dev, regs[REG_INT_ENABLE], GENMASK(2, 0),
+				 ksz8->irq_masked);
+	if (ret)
+		dev_err(dev->dev, "could not unmask IRQ\n");
+
+	mutex_unlock(&dev->dev_mutex);
+}
+
+static struct irq_chip ksz8_irq_chip = {
+	.name = "KSZ8",
+	.irq_mask		= ksz8_mask_irq,
+	.irq_unmask		= ksz8_unmask_irq,
+	.irq_bus_lock		= ksz8_irq_bus_lock,
+	.irq_bus_sync_unlock	= ksz8_irq_bus_sync_unlock,
+};
+
+static int ksz8_irq_map(struct irq_domain *domain, unsigned int irq,
+			     irq_hw_number_t hwirq)
+{
+	irq_set_chip_data(irq, domain->host_data);
+	irq_set_chip_and_handler(irq, &ksz8_irq_chip, handle_simple_irq);
+	irq_set_nested_thread(irq, 1);
+	irq_set_noprobe(irq);
+
+	return 0;
+}
+
+static void ksz8_irq_unmap(struct irq_domain *d, unsigned int irq)
+{
+	irq_set_nested_thread(irq, 0);
+	irq_set_chip_and_handler(irq, NULL, NULL);
+	irq_set_chip_data(irq, NULL);
+}
+
+static const struct irq_domain_ops ksz8_irqdomain_ops = {
+	.map	= ksz8_irq_map,
+	.unmap	= ksz8_irq_unmap,
+	.xlate	= irq_domain_xlate_onecell,
+};
+
+static int ksz8_setup_cascaded_irq(struct ksz_device *dev)
+{
+	struct device_node *intc;
+	struct ksz8 *ksz8 = dev->priv;
+	const u8 *regs = ksz8->regs;
+	unsigned long irq_trig;
+	int irq;
+	int ret;
+	u32 val;
+	int i;
+
+	intc = of_get_child_by_name(dev->dev->of_node, "interrupt-controller");
+	if (!intc) {
+		dev_err(dev->dev, "missing child interrupt-controller node\n");
+		return -EINVAL;
+	}
+
+	/* KSZ8 IRQs cascade off this one */
+	irq = of_irq_get(intc, 0);
+	if (irq <= 0) {
+		dev_err(dev->dev, "failed to get parent IRQ\n");
+		ret = irq ? irq : -EINVAL;
+		goto out_put_node;
+	}
+
+	/* This clears the IRQ status register */
+	ret = ksz_write8(dev, regs[REG_INT_STATUS], GENMASK(7,0));
+	if (ret) {
+		dev_err(dev->dev, "can't read interrupt status\n");
+		goto out_put_node;
+	}
+
+	/* Fetch IRQ edge information from the descriptor */
+	irq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));
+	switch (irq_trig) {
+	case IRQF_TRIGGER_RISING:
+	case IRQF_TRIGGER_HIGH:
+		dev_info(dev->dev, "active high/rising IRQ\n");
+		val = 0;
+		break;
+	case IRQF_TRIGGER_FALLING:
+	case IRQF_TRIGGER_LOW:
+		dev_info(dev->dev, "active low/falling IRQ\n");
+		break;
+	}
+
+	ret = devm_request_threaded_irq(dev->dev, irq, NULL,
+					ksz8_irq, IRQF_ONESHOT,
+					"KSZ8", dev);
+	if (ret) {
+		dev_err(dev->dev, "unable to request irq: %d\n", ret);
+		goto out_put_node;
+	}
+
+	dev->irqdomain = irq_domain_add_linear(intc,
+					       dev->phy_port_cnt,
+					       &ksz8_irqdomain_ops,
+					       dev);
+	if (!dev->irqdomain) {
+		dev_err(dev->dev, "failed to create IRQ domain\n");
+		ret = -EINVAL;
+		goto out_put_node;
+	}
+
+	for (i = 0; i < dev->phy_port_cnt; i++)
+		irq_set_parent(irq_create_mapping(dev->irqdomain, i), irq);
+
+out_put_node:
+	of_node_put(intc);
+	return ret;
+}
+
 static int ksz8_setup(struct dsa_switch *ds)
 {
 	struct ksz_device *dev = ds->priv;
@@ -1395,6 +1582,10 @@ static int ksz8_setup(struct dsa_switch *ds)
 
 	ksz_init_mib_timer(dev);
 
+	ret = ksz8_setup_cascaded_irq(dev);
+	if (ret)
+		dev_info(dev->dev, "no interrupt support\n");
+
 	return 0;
 }
 
diff --git a/drivers/net/dsa/microchip/ksz8795_reg.h b/drivers/net/dsa/microchip/ksz8795_reg.h
index 85016fc1f29e..4786297d6b03 100644
--- a/drivers/net/dsa/microchip/ksz8795_reg.h
+++ b/drivers/net/dsa/microchip/ksz8795_reg.h
@@ -392,9 +392,6 @@
 
 #define REG_IND_DATA_PME_EEE_ACL	0xA0
 
-#define REG_INT_STATUS			0x7C
-#define REG_INT_ENABLE			0x7D
-
 #define INT_PME				BIT(4)
 
 #define REG_ACL_INT_STATUS		0x7E
diff --git a/drivers/net/dsa/microchip/ksz_common.h b/drivers/net/dsa/microchip/ksz_common.h
index a516ea50bfe7..1687eb9a4ca5 100644
--- a/drivers/net/dsa/microchip/ksz_common.h
+++ b/drivers/net/dsa/microchip/ksz_common.h
@@ -52,6 +52,8 @@ struct ksz_device {
 	struct mutex vlan_mutex;	/* vlan access */
 	const struct ksz_dev_ops *dev_ops;
 
+	struct irq_domain	*irqdomain;
+
 	struct device *dev;
 	struct regmap *regmap[3];
 
