From: Lucas Stach <l.stach@pengutronix.de>
Date: Fri, 8 Jun 2018 18:42:59 +0200
Subject: [PATCH] drm/sched: add sysfs stats output

This adds a sysfs entry for the drm scheduler and exports the active times
of all scheduler instances.

Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
---
 drivers/gpu/drm/scheduler/Makefile        |   2 +-
 drivers/gpu/drm/scheduler/gpu_scheduler.c |  11 +-
 drivers/gpu/drm/scheduler/sched_fence.c   |  29 ++++-
 drivers/gpu/drm/scheduler/sched_stats.c   | 175 ++++++++++++++++++++++++++++++
 drivers/gpu/drm/scheduler/sched_stats.h   |  36 ++++++
 include/drm/gpu_scheduler.h               |  11 ++
 6 files changed, 259 insertions(+), 5 deletions(-)
 create mode 100644 drivers/gpu/drm/scheduler/sched_stats.c
 create mode 100644 drivers/gpu/drm/scheduler/sched_stats.h

diff --git a/drivers/gpu/drm/scheduler/Makefile b/drivers/gpu/drm/scheduler/Makefile
index 7665883f81d4..7fee9181f361 100644
--- a/drivers/gpu/drm/scheduler/Makefile
+++ b/drivers/gpu/drm/scheduler/Makefile
@@ -20,6 +20,6 @@
 # OTHER DEALINGS IN THE SOFTWARE.
 #
 #
-gpu-sched-y := gpu_scheduler.o sched_fence.o
+gpu-sched-y := gpu_scheduler.o sched_fence.o sched_stats.o
 
 obj-$(CONFIG_DRM_SCHED) += gpu-sched.o
diff --git a/drivers/gpu/drm/scheduler/gpu_scheduler.c b/drivers/gpu/drm/scheduler/gpu_scheduler.c
index 4fc211e19d6e..c977d5e06a9e 100644
--- a/drivers/gpu/drm/scheduler/gpu_scheduler.c
+++ b/drivers/gpu/drm/scheduler/gpu_scheduler.c
@@ -55,6 +55,8 @@
 #define CREATE_TRACE_POINTS
 #include "gpu_scheduler_trace.h"
 
+#include "sched_stats.h"
+
 #define to_drm_sched_job(sched_job)		\
 		container_of((sched_job), struct drm_sched_job, queue_node)
 
@@ -916,7 +918,7 @@ int drm_sched_init(struct drm_gpu_scheduler *sched,
 		   long timeout,
 		   const char *name)
 {
-	int i;
+	int i, ret;
 	sched->ops = ops;
 	sched->hw_submission_limit = hw_submission;
 	sched->name = name;
@@ -932,10 +934,15 @@ int drm_sched_init(struct drm_gpu_scheduler *sched,
 	atomic_set(&sched->hw_rq_count, 0);
 	atomic64_set(&sched->job_id_count, 0);
 
+	ret = drm_sched_stats_init(sched);
+	if (ret)
+		return ret;
+
 	/* Each scheduler will run on a seperate kernel thread */
 	sched->thread = kthread_run(drm_sched_main, sched, sched->name);
 	if (IS_ERR(sched->thread)) {
 		DRM_ERROR("Failed to create scheduler for %s.\n", name);
+		drm_sched_stats_fini(sched);
 		return PTR_ERR(sched->thread);
 	}
 
@@ -952,6 +959,8 @@ EXPORT_SYMBOL(drm_sched_init);
  */
 void drm_sched_fini(struct drm_gpu_scheduler *sched)
 {
+	drm_sched_stats_fini(sched);
+
 	if (sched->thread)
 		kthread_stop(sched->thread);
 }
diff --git a/drivers/gpu/drm/scheduler/sched_fence.c b/drivers/gpu/drm/scheduler/sched_fence.c
index d8d2dff9ea2f..acf6bf0e6ddf 100644
--- a/drivers/gpu/drm/scheduler/sched_fence.c
+++ b/drivers/gpu/drm/scheduler/sched_fence.c
@@ -27,6 +27,8 @@
 #include <drm/drmP.h>
 #include <drm/gpu_scheduler.h>
 
+#include "sched_stats.h"
+
 static struct kmem_cache *sched_fence_slab;
 
 static int __init drm_sched_fence_slab_init(void)
@@ -40,7 +42,7 @@ static int __init drm_sched_fence_slab_init(void)
 	return 0;
 }
 
-static void __exit drm_sched_fence_slab_fini(void)
+static void drm_sched_fence_slab_fini(void)
 {
 	rcu_barrier();
 	kmem_cache_destroy(sched_fence_slab);
@@ -173,8 +175,29 @@ struct drm_sched_fence *drm_sched_fence_create(struct drm_sched_entity *entity,
 	return fence;
 }
 
-module_init(drm_sched_fence_slab_init);
-module_exit(drm_sched_fence_slab_fini);
+static int __init drm_sched_modinit(void)
+{
+	int ret;
+
+	ret = drm_sched_fence_slab_init();
+	if (ret)
+		return ret;
+
+	ret = drm_sched_stats_class_init();
+	if (ret)
+		drm_sched_fence_slab_fini();
+
+	return ret;
+}
+
+static void __exit drm_sched_modexit(void)
+{
+	drm_sched_stats_class_fini();
+	drm_sched_fence_slab_fini();
+}
+
+module_init(drm_sched_modinit);
+module_exit(drm_sched_modexit);
 
 MODULE_DESCRIPTION("DRM GPU scheduler");
 MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/gpu/drm/scheduler/sched_stats.c b/drivers/gpu/drm/scheduler/sched_stats.c
new file mode 100644
index 000000000000..208edb807539
--- /dev/null
+++ b/drivers/gpu/drm/scheduler/sched_stats.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2018 Pengutronix
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <drm/drm_sysfs.h>
+#include <drm/gpu_scheduler.h>
+
+#include "sched_stats.h"
+
+struct drm_sched_stats_engines {
+	struct kobject		kobj;
+};
+
+static struct device_type drm_sched_class_type = {
+	.name = "scheduler",
+};
+
+static struct device drm_sched_class_device = {
+	.type = &drm_sched_class_type,
+};
+
+static void drm_sched_stats_rings_kobj_release(struct kobject *kobj)
+{
+	struct drm_sched_stats_engines *engines =
+		container_of(kobj, struct drm_sched_stats_engines, kobj);
+
+	kfree(engines);
+}
+
+static struct kobj_type drm_sched_rings_class_type = {
+	.release = &drm_sched_stats_rings_kobj_release,
+};
+
+static struct drm_sched_stats_engines *rings;
+
+
+static struct attribute drm_sched_stats_active = {
+	.name = "active_us",
+	.mode = S_IRUGO
+};
+
+static void drm_sched_stats_kobj_release(struct kobject *kobj)
+{
+	struct drm_gpu_scheduler_stats *stats =
+		container_of(kobj, struct drm_gpu_scheduler_stats, kobj);
+
+	kfree(stats);
+}
+
+static ssize_t drm_sched_stats_show(struct kobject *kobj,
+				 struct attribute *attr,
+				 char *buffer)
+{
+	struct drm_gpu_scheduler_stats *stats =
+		container_of(kobj, struct drm_gpu_scheduler_stats, kobj);
+	uint64_t val = 0;
+
+	spin_lock(&stats->lock);
+
+	val = stats->active_time_us;
+	if (stats->active)
+		val += ktime_to_us(ktime_sub(ktime_get(), stats->active_ts));
+
+	spin_unlock(&stats->lock);
+
+	return snprintf(buffer, PAGE_SIZE, "%llu\n", val);
+}
+static struct attribute *drm_sched_stats_attrs[] = {
+	&drm_sched_stats_active,
+	NULL
+};
+
+static const struct sysfs_ops drm_sched_stats_ops = {
+	.show = &drm_sched_stats_show,
+};
+
+static struct kobj_type drm_sched_stats_kobj_type = {
+	.release = drm_sched_stats_kobj_release,
+	.sysfs_ops = &drm_sched_stats_ops,
+	.default_attrs = drm_sched_stats_attrs,
+};
+
+int drm_sched_stats_init(struct drm_gpu_scheduler *sched)
+{
+	int ret;
+
+	sched->stats = kzalloc(sizeof(*sched->stats), GFP_KERNEL);
+	if (!sched->stats)
+		return -ENOMEM;
+
+	spin_lock_init(&sched->stats->lock);
+
+	ret = kobject_init_and_add(&sched->stats->kobj,
+				   &drm_sched_stats_kobj_type,
+				   &rings->kobj, "%s", sched->name);
+
+	if (ret) {
+		pr_warn("could not inititialize stats for drm scheduler %s\n",
+			sched->name);
+		kfree(sched->stats);
+		sched->stats = NULL;
+	}
+
+	return 0;
+}
+
+void drm_sched_stats_fini(struct drm_gpu_scheduler *sched)
+{
+	if (!sched->stats)
+		return;
+
+	kobject_put(&sched->stats->kobj);
+	sched->stats = NULL;
+}
+
+int __init drm_sched_stats_class_init(void)
+{
+	int ret;
+
+	ret = dev_set_name(&drm_sched_class_device, "scheduler");
+	if (ret)
+		return ret;
+
+	ret = drm_class_device_register(&drm_sched_class_device);
+	if (ret)
+		return ret;
+
+	rings = kzalloc(sizeof(*rings), GFP_KERNEL);
+	if (!rings) {
+		ret = -ENOMEM;
+		goto unregister_device;
+	}
+	ret = kobject_init_and_add(&rings->kobj,
+				   &drm_sched_rings_class_type,
+				   &drm_sched_class_device.kobj,
+				   "%s", "rings");
+	if (ret) {
+		kobject_put(&rings->kobj);
+		goto unregister_device;
+	}
+
+	return 0;
+
+unregister_device:
+	drm_class_device_unregister(&drm_sched_class_device);
+
+	return ret;
+}
+
+void __exit drm_sched_stats_class_fini(void)
+{
+	drm_class_device_unregister(&drm_sched_class_device);
+}
diff --git a/drivers/gpu/drm/scheduler/sched_stats.h b/drivers/gpu/drm/scheduler/sched_stats.h
new file mode 100644
index 000000000000..e3e3e73bf279
--- /dev/null
+++ b/drivers/gpu/drm/scheduler/sched_stats.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2018 Pengutronix
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _DRM_SCHED_STATS_H_
+#define _DRM_SCHED_STATS_H_
+
+#include <linux/init.h>
+#include <drm/gpu_scheduler.h>
+
+int drm_sched_stats_init(struct drm_gpu_scheduler *sched);
+void drm_sched_stats_fini(struct drm_gpu_scheduler *sched);
+
+int __init drm_sched_stats_class_init(void);
+void __exit drm_sched_stats_class_fini(void);
+
+#endif
diff --git a/include/drm/gpu_scheduler.h b/include/drm/gpu_scheduler.h
index 21c648b0b2a1..f21c945aea85 100644
--- a/include/drm/gpu_scheduler.h
+++ b/include/drm/gpu_scheduler.h
@@ -237,6 +237,16 @@ struct drm_sched_backend_ops {
 	void (*free_job)(struct drm_sched_job *sched_job);
 };
 
+struct drm_gpu_scheduler;
+
+struct drm_gpu_scheduler_stats {
+	struct kobject			kobj;
+	spinlock_t			lock;
+	uint64_t			active_time_us;
+	ktime_t				active_ts;
+	bool				active;
+};
+
 /**
  * struct drm_gpu_scheduler
  *
@@ -274,6 +284,7 @@ struct drm_gpu_scheduler {
 	struct list_head		ring_mirror_list;
 	spinlock_t			job_list_lock;
 	int				hang_limit;
+	struct drm_gpu_scheduler_stats	*stats;
 };
 
 int drm_sched_init(struct drm_gpu_scheduler *sched,
