From: Oleksij Rempel <o.rempel@pengutronix.de>
Date: Mon, 2 Oct 2023 12:44:43 +0200
Subject: [PATCH] WIP: mmc: implement emergency shutdown

This is currently work in progress, for now mostly based on bosch [1]
variant of under-voltage handling for eMMC.
Following changes should be made:
- register undervolatage handler in drivers/mmc/core/regulator.c
- block new requests in somewhere in drivers/mmc/core/*
- implement and verify sdhci specific code
- implement EXT_CSD_POWER_OFF_NOTIFICATION

[1] https://oss.bosch-cm.com/download/suz/1891_220407_SUZUKI_UG_EU_SOP10_Linux_22.0S01/OSS-DVD_Content-1891.zip

Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
---
 drivers/mmc/host/sdhci.c | 201 +++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/mmc/host.h |   1 +
 2 files changed, 202 insertions(+)

diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index ff41aa56564e..094fe23118b3 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -4219,6 +4219,203 @@ static inline bool sdhci_can_64bit_dma(struct sdhci_host *host)
 	return host->caps & SDHCI_CAN_64BIT;
 }
 
+static void
+sdhci_force_command(struct sdhci_host *host, struct mmc_command *cmd)
+{
+	int flags;
+
+	host->cmd = cmd;
+	sdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);
+	sdhci_set_transfer_mode(host, cmd);
+
+	if ((cmd->flags & MMC_RSP_136) && (cmd->flags & MMC_RSP_BUSY)) {
+		pr_err("%s: Unsupported response type!\n",
+			mmc_hostname(host->mmc));
+		cmd->error = -EINVAL;
+		return;
+	}
+
+	if (!(cmd->flags & MMC_RSP_PRESENT))
+		flags = SDHCI_CMD_RESP_NONE;
+	else if (cmd->flags & MMC_RSP_136)
+		flags = SDHCI_CMD_RESP_LONG;
+	else if (cmd->flags & MMC_RSP_BUSY)
+		flags = SDHCI_CMD_RESP_SHORT_BUSY;
+	else
+		flags = SDHCI_CMD_RESP_SHORT;
+
+	if (cmd->flags & MMC_RSP_CRC)
+		flags |= SDHCI_CMD_CRC;
+	if (cmd->flags & MMC_RSP_OPCODE)
+		flags |= SDHCI_CMD_INDEX;
+	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, flags), SDHCI_COMMAND);
+}
+
+/* In case of emergency reset/powerfailure shutdown, the eMMC chip
+ * should be taken out of programming state by a sending stop command.
+ * This command is sent directly via the SDHCI API due to the requirement
+ * to quickly interrupt an ongoing write/erase command.
+*/
+static inline void sdhci_send_stop(struct mmc_host *mmc, bool hpi)
+{
+	struct sdhci_host *host;
+
+	struct mmc_command cmd = {0};
+	unsigned int opcode;
+
+	host = mmc_priv(mmc);
+
+	if (hpi)
+		opcode = mmc->card->ext_csd.hpi_cmd;
+	else
+		opcode = MMC_STOP_TRANSMISSION;
+
+	if (opcode == MMC_STOP_TRANSMISSION)
+		cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
+	else if (opcode == MMC_SEND_STATUS)
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	cmd.opcode = opcode;
+	cmd.arg = mmc->card->rca << 16 | hpi;
+
+	sdhci_force_command(host, &cmd);
+}
+
+/* In case of shutdown (switch off the device), the eMMC chip
+ * should be notified.
+ * This command is sent directly via the SDHCI API to be able
+ * to send it as fast as possible. This is done to prevent any delay
+ * of the wakeup event occurring while the shutdown is already in
+ * progress.
+ */
+static inline void sdhci_send_pon(struct sdhci_host *host)
+{
+	struct mmc_command cmd = {0};
+
+	cmd.opcode = MMC_SWITCH;
+	cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+		  (EXT_CSD_POWER_OFF_NOTIFICATION << 16) |
+		  (EXT_CSD_POWER_OFF_SHORT << 8) | EXT_CSD_CMD_SET_NORMAL;
+	cmd.flags = MMC_CMD_AC | MMC_RSP_SPI_R1B | MMC_RSP_R1B;
+
+	sdhci_force_command(host, &cmd);
+}
+
+static inline	void sdhci_stop_bus(struct sdhci_host *host)
+{
+	sdhci_reset(host, SDHCI_RESET_DATA);
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+	free_irq(host->irq, host);
+	del_timer(&host->timer);
+////	tasklet_kill(&host->finish_tasklet);
+}
+
+static void sdhci_force_quiescent(struct mmc_host *mmc, bool pon)
+{
+	struct mmc_command *cmd;
+	struct sdhci_host *host;
+	unsigned long flags;
+	int locked, try = 5;
+
+	host = mmc_priv(mmc);
+
+	/* The host controller may be processing an async request
+	 * but this code cannot wait for completion of pending
+	 * requests due to imminent power loss.  Try to take the
+	 * &host->lock to prevent race conditions.  If the lock is
+	 * already held, taint the kernel because any oops which
+	 * occurs hereafter is suspect due to concurrent access to
+	 * the host controller while not holding the lock.
+	 */
+	do {
+		locked = spin_trylock_irqsave(&host->lock, flags);
+		if (locked)
+			break;
+		udelay(10);
+	} while (--try);
+
+//	if (!locked)
+//		add_taint(TAINT_UNSAFE_SMP, LOCKDEP_NOW_UNRELIABLE);
+
+//	mmc->state_quiescent = 1;
+
+	cmd = host->deferred_cmd;
+	if (cmd &&
+	   (cmd->opcode == MMC_WRITE_BLOCK ||
+	    cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||
+	    cmd->opcode == MMC_ERASE)) {
+
+		/*
+		 * send stop command to eMMC
+		 */
+		sdhci_send_stop(mmc, 0);
+		udelay(20);
+
+		/*
+		 * send stop cmd with hpi bit
+		 */
+		if (mmc->card->ext_csd.hpi) {
+			sdhci_send_stop(mmc, 1);
+			udelay(20);
+		}
+
+		pr_err("%s: request canceled due to power fail or shutdown\n",
+		       mmc_hostname(mmc));
+	} else {
+		pr_err("%s: quiescent: no ongoing data transfer\n",
+				mmc_hostname(mmc));
+	}
+
+	/*
+	 * send power off notification
+	 */
+	if (pon) {
+		sdhci_send_pon(host);
+		pr_err("%s: power off notify issued\n", mmc_hostname(mmc));
+	}
+
+	if (locked)
+		spin_unlock_irqrestore(&host->lock, flags);
+
+	sdhci_stop_bus(host);
+}
+
+static int sdhci_regulator_notifier(struct notifier_block *nb,
+				    unsigned long event, void *data)
+{
+	struct mmc_supply *supply = container_of(nb, struct mmc_supply, nb);
+	struct mmc_host *mmc = container_of(supply, struct mmc_host, supply);
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (event != REGULATOR_EVENT_UNDER_VOLTAGE_WARN &&
+	    event != REGULATOR_EVENT_UNDER_VOLTAGE)
+		return NOTIFY_OK;
+
+	pr_err("%s: %s\n", mmc_hostname(host->mmc), __func__);
+	sdhci_force_quiescent(mmc, 0);
+
+	return NOTIFY_OK;
+}
+
+static int sdhci_register_regulator_notifier(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	int ret;
+
+	pr_err("%s: %s\n", mmc_hostname(mmc), __func__);
+	mmc->supply.nb.notifier_call = sdhci_regulator_notifier;
+	ret = regulator_register_notifier(mmc->supply.vmmc, &mmc->supply.nb);
+	if (ret) {
+		pr_err("%s: failed to register regulator notifier\n",
+		       mmc_hostname(mmc));
+		return ret;
+	}
+	pr_err("%s: %s\n", mmc_hostname(mmc), __func__);
+
+	return 0;
+}
+
 int sdhci_setup_host(struct sdhci_host *host)
 {
 	struct mmc_host *mmc;
@@ -4624,8 +4821,12 @@ int sdhci_setup_host(struct sdhci_host *host)
 				FIELD_PREP(SDHCI_MAX_CURRENT_300_MASK, curr) |
 				FIELD_PREP(SDHCI_MAX_CURRENT_180_MASK, curr);
 		}
+
+		// attach 
 	}
 
+	sdhci_register_regulator_notifier(mmc);
+
 	if (host->caps & SDHCI_CAN_VDD_330) {
 		ocr_avail |= MMC_VDD_32_33 | MMC_VDD_33_34;
 
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 62a6847a3b6f..d6f4f6e3f965 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -311,6 +311,7 @@ struct mmc_pwrseq;
 struct mmc_supply {
 	struct regulator *vmmc;		/* Card power supply */
 	struct regulator *vqmmc;	/* Optional Vccq supply */
+	struct notifier_block nb;	/* notifier for vmmc changes */
 };
 
 struct mmc_ctx {
