From: Philipp Zabel <p.zabel@pengutronix.de>
Date: Mon, 10 Sep 2018 15:45:29 +0200
Subject: [PATCH] media: coda: track activity using v4l2-stats

Add simple time based activity tracking using v4l2-stats for the
BIT processor, JPEG encoder/decoder, and VDOA units.

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 drivers/media/platform/coda/coda-bit.c    |  3 +++
 drivers/media/platform/coda/coda-common.c | 15 +++++++++++++++
 drivers/media/platform/coda/coda-jpeg.c   |  3 +++
 drivers/media/platform/coda/coda.h        | 23 +++++++++++++++++++++++
 drivers/media/platform/coda/imx-vdoa.c    | 22 ++++++++++++++++++++++
 5 files changed, 66 insertions(+)

diff --git a/drivers/media/platform/coda/coda-bit.c b/drivers/media/platform/coda/coda-bit.c
index 8c6cac830cd9..ccc79135851f 100644
--- a/drivers/media/platform/coda/coda-bit.c
+++ b/drivers/media/platform/coda/coda-bit.c
@@ -102,6 +102,7 @@ static void coda_command_async(struct coda_ctx *ctx, int cmd)
 	coda_write(dev, ctx->params.codec_mode_aux, CODA7_REG_BIT_RUN_AUX_STD);
 
 	trace_coda_bit_run(ctx, cmd);
+	coda_stats_run(dev->bit_stats);
 
 	coda_write(dev, cmd, CODA_REG_BIT_RUN_COMMAND);
 }
@@ -116,6 +117,7 @@ static int coda_command_sync(struct coda_ctx *ctx, int cmd)
 	coda_command_async(ctx, cmd);
 	ret = coda_wait_timeout(dev);
 	trace_coda_bit_done(ctx);
+	coda_stats_done(dev->bit_stats);
 
 	return ret;
 }
@@ -2664,6 +2666,7 @@ irqreturn_t coda_irq_handler(int irq, void *data)
 	}
 
 	trace_coda_bit_done(ctx);
+	coda_stats_done(dev->bit_stats);
 
 	if (ctx->aborting) {
 		coda_dbg(1, ctx, "task has been aborted\n");
diff --git a/drivers/media/platform/coda/coda-common.c b/drivers/media/platform/coda/coda-common.c
index fc65534c204a..928a0f4d9402 100644
--- a/drivers/media/platform/coda/coda-common.c
+++ b/drivers/media/platform/coda/coda-common.c
@@ -2975,9 +2975,21 @@ static void coda_fw_callback(const struct firmware *fw, void *context)
 		}
 	}
 
+	dev->bit_stats = v4l2_register_stats("coda-bit");
+	if (IS_ERR(dev->bit_stats))
+		goto rel_vfd;
+
+	if (dev->devtype->product == CODA_960) {
+		dev->jpeg_stats = v4l2_register_stats("coda-jpeg");
+		if (IS_ERR(dev->jpeg_stats))
+			goto unreg_bit;
+	}
+
 	pm_runtime_put_sync(dev->dev);
 	return;
 
+unreg_bit:
+	v4l2_unregister_stats(dev->bit_stats);
 rel_vfd:
 	while (--i >= 0)
 		video_unregister_device(&dev->vfd[i]);
@@ -3267,6 +3279,9 @@ static int coda_remove(struct platform_device *pdev)
 	struct coda_dev *dev = platform_get_drvdata(pdev);
 	int i;
 
+	if (dev->devtype->product == CODA_960)
+		v4l2_unregister_stats(dev->jpeg_stats);
+	v4l2_unregister_stats(dev->bit_stats);
 	for (i = 0; i < ARRAY_SIZE(dev->vfd); i++) {
 		if (video_get_drvdata(&dev->vfd[i]))
 			video_unregister_device(&dev->vfd[i]);
diff --git a/drivers/media/platform/coda/coda-jpeg.c b/drivers/media/platform/coda/coda-jpeg.c
index f2ee958de3a1..1ba55a0b7eb6 100644
--- a/drivers/media/platform/coda/coda-jpeg.c
+++ b/drivers/media/platform/coda/coda-jpeg.c
@@ -1295,6 +1295,7 @@ static int coda9_jpeg_prepare_encode(struct coda_ctx *ctx)
 	coda_write(dev, 0, CODA9_GDI_WPROT_RGN_EN);
 
 	trace_coda_jpeg_run(ctx, src_buf);
+	coda_stats_run(dev->jpeg_stats);
 
 	coda_write(dev, 1, CODA9_REG_JPEG_PIC_START);
 
@@ -1621,6 +1622,8 @@ v4l2_err(&dev->v4l2_dev, "word_ptr = %d bit_ptr = %d\n",
 		return IRQ_HANDLED;
 	}
 
+	coda_stats_done(dev->jpeg_stats);
+
 	complete(&ctx->completion);
 
 	return IRQ_HANDLED;
diff --git a/drivers/media/platform/coda/coda.h b/drivers/media/platform/coda/coda.h
index e633e197aa9e..f99f7f7c4a39 100644
--- a/drivers/media/platform/coda/coda.h
+++ b/drivers/media/platform/coda/coda.h
@@ -16,6 +16,7 @@
 #include <linux/irqreturn.h>
 #include <linux/mutex.h>
 #include <linux/kfifo.h>
+#include <linux/timekeeping.h>
 #include <linux/videodev2.h>
 
 #include <media/v4l2-ctrls.h>
@@ -93,6 +94,9 @@ struct coda_dev {
 	struct v4l2_m2m_dev	*m2m_dev;
 	struct ida		ida;
 	struct dentry		*debugfs_root;
+
+	struct v4l2_stats	*bit_stats;
+	struct v4l2_stats	*jpeg_stats;
 };
 
 struct coda_codec {
@@ -385,4 +389,23 @@ extern const struct coda_context_ops coda9_jpeg_decode_ops;
 irqreturn_t coda_irq_handler(int irq, void *data);
 irqreturn_t coda9_jpeg_irq_handler(int irq, void *data);
 
+static inline void coda_stats_run(struct v4l2_stats *stats)
+{
+	__v4l2_stats_start(stats, ktime_get());
+}
+
+static inline void coda_stats_done(struct v4l2_stats *stats)
+{
+	unsigned long flags;
+	ktime_t now = ktime_get();
+
+	/*
+	 * Called both from dec_seq_init worker thread
+	 * with IRQs enabled, and from coda_irq_handler.
+	 */
+	spin_lock_irqsave(&stats->lock, flags);
+	__v4l2_stats_stop(stats, now);
+	spin_unlock_irqrestore(&stats->lock, flags);
+}
+
 #endif /* __CODA_H__ */
diff --git a/drivers/media/platform/coda/imx-vdoa.c b/drivers/media/platform/coda/imx-vdoa.c
index 8bc0d8371819..dea382dc35f7 100644
--- a/drivers/media/platform/coda/imx-vdoa.c
+++ b/drivers/media/platform/coda/imx-vdoa.c
@@ -16,6 +16,8 @@
 #include <linux/videodev2.h>
 #include <linux/slab.h>
 
+#include <media/v4l2-dev.h>
+
 #include "imx-vdoa.h"
 
 #define VDOA_NAME "imx-vdoa"
@@ -79,6 +81,7 @@ struct vdoa_data {
 	struct device		*dev;
 	struct clk		*vdoa_clk;
 	void __iomem		*regs;
+	struct v4l2_stats	*stats;
 };
 
 struct vdoa_q_data {
@@ -101,6 +104,7 @@ static irqreturn_t vdoa_irq_handler(int irq, void *data)
 {
 	struct vdoa_data *vdoa = data;
 	struct vdoa_ctx *curr_ctx;
+	unsigned long flags;
 	u32 val;
 
 	/* Disable interrupts */
@@ -122,6 +126,11 @@ static irqreturn_t vdoa_irq_handler(int irq, void *data)
 		dev_warn(vdoa->dev, "Spurious interrupt\n");
 	}
 	curr_ctx->completed_job++;
+
+	spin_lock_irqsave(&vdoa->stats->lock, flags);
+	__v4l2_stats_stop(vdoa->stats, ktime_get());
+	spin_unlock_irqrestore(&vdoa->stats->lock, flags);
+
 	complete(&curr_ctx->completion);
 
 	return IRQ_HANDLED;
@@ -149,6 +158,7 @@ void vdoa_device_run(struct vdoa_ctx *ctx, dma_addr_t dst, dma_addr_t src)
 {
 	struct vdoa_q_data *src_q_data, *dst_q_data;
 	struct vdoa_data *vdoa = ctx->vdoa;
+	unsigned long flags;
 	u32 val;
 
 	if (vdoa->curr_ctx)
@@ -190,6 +200,10 @@ void vdoa_device_run(struct vdoa_ctx *ctx, dma_addr_t dst, dma_addr_t src)
 	val = round_up(src_q_data->bytesperline * src_q_data->height, 4096);
 	writel(val, vdoa->regs + VDOAVUBO);
 
+	spin_lock_irqsave(&vdoa->stats->lock, flags);
+	__v4l2_stats_start(vdoa->stats, ktime_get());
+	spin_unlock_irqrestore(&vdoa->stats->lock, flags);
+
 	/* Enable interrupts and start transfer */
 	writel(VDOAIE_EITERR | VDOAIE_EIEOT, vdoa->regs + VDOAIE);
 	writel(VDOASRR_START, vdoa->regs + VDOASRR);
@@ -317,6 +331,10 @@ static int vdoa_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	vdoa->stats = v4l2_register_stats("vdoa");
+	if (IS_ERR(vdoa->stats))
+		return PTR_ERR(vdoa->stats);
+
 	platform_set_drvdata(pdev, vdoa);
 
 	return 0;
@@ -324,6 +342,10 @@ static int vdoa_probe(struct platform_device *pdev)
 
 static int vdoa_remove(struct platform_device *pdev)
 {
+	struct vdoa_data *vdoa = platform_get_drvdata(pdev);
+
+	v4l2_unregister_stats(vdoa->stats);
+
 	return 0;
 }
 
