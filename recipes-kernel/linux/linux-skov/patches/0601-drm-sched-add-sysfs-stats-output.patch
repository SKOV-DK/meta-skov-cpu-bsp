From: Lucas Stach <l.stach@pengutronix.de>
Date: Fri, 8 Jun 2018 18:42:59 +0200
Subject: [PATCH] drm/sched: add sysfs stats output

This adds a sysfs entry for the drm scheduler and exports the active times
of all scheduler instances.

Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
---
 drivers/gpu/drm/scheduler/Makefile      |   2 +-
 drivers/gpu/drm/scheduler/sched_fence.c |  29 +++++-
 drivers/gpu/drm/scheduler/sched_main.c  |   9 ++
 drivers/gpu/drm/scheduler/sched_stats.c | 176 ++++++++++++++++++++++++++++++++
 drivers/gpu/drm/scheduler/sched_stats.h |  36 +++++++
 include/drm/gpu_scheduler.h             |  12 +++
 6 files changed, 260 insertions(+), 4 deletions(-)
 create mode 100644 drivers/gpu/drm/scheduler/sched_stats.c
 create mode 100644 drivers/gpu/drm/scheduler/sched_stats.h

diff --git a/drivers/gpu/drm/scheduler/Makefile b/drivers/gpu/drm/scheduler/Makefile
index 53863621829f..3d46484a1546 100644
--- a/drivers/gpu/drm/scheduler/Makefile
+++ b/drivers/gpu/drm/scheduler/Makefile
@@ -20,6 +20,6 @@
 # OTHER DEALINGS IN THE SOFTWARE.
 #
 #
-gpu-sched-y := sched_main.o sched_fence.o sched_entity.o
+gpu-sched-y := sched_main.o sched_fence.o sched_entity.o sched_stats.o
 
 obj-$(CONFIG_DRM_SCHED) += gpu-sched.o
diff --git a/drivers/gpu/drm/scheduler/sched_fence.c b/drivers/gpu/drm/scheduler/sched_fence.c
index 7fd869520ef2..c4097c05a72f 100644
--- a/drivers/gpu/drm/scheduler/sched_fence.c
+++ b/drivers/gpu/drm/scheduler/sched_fence.c
@@ -29,6 +29,8 @@
 
 #include <drm/gpu_scheduler.h>
 
+#include "sched_stats.h"
+
 static struct kmem_cache *sched_fence_slab;
 
 static int __init drm_sched_fence_slab_init(void)
@@ -42,7 +44,7 @@ static int __init drm_sched_fence_slab_init(void)
 	return 0;
 }
 
-static void __exit drm_sched_fence_slab_fini(void)
+static void drm_sched_fence_slab_fini(void)
 {
 	rcu_barrier();
 	kmem_cache_destroy(sched_fence_slab);
@@ -175,8 +177,29 @@ void drm_sched_fence_init(struct drm_sched_fence *fence,
 		       &fence->lock, entity->fence_context + 1, seq);
 }
 
-module_init(drm_sched_fence_slab_init);
-module_exit(drm_sched_fence_slab_fini);
+static int __init drm_sched_modinit(void)
+{
+	int ret;
+
+	ret = drm_sched_fence_slab_init();
+	if (ret)
+		return ret;
+
+	ret = drm_sched_stats_class_init();
+	if (ret)
+		drm_sched_fence_slab_fini();
+
+	return ret;
+}
+
+static void __exit drm_sched_modexit(void)
+{
+	drm_sched_stats_class_fini();
+	drm_sched_fence_slab_fini();
+}
+
+module_init(drm_sched_modinit);
+module_exit(drm_sched_modexit);
 
 MODULE_DESCRIPTION("DRM GPU scheduler");
 MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/gpu/drm/scheduler/sched_main.c b/drivers/gpu/drm/scheduler/sched_main.c
index b81fceb0b8a2..17715f69e774 100644
--- a/drivers/gpu/drm/scheduler/sched_main.c
+++ b/drivers/gpu/drm/scheduler/sched_main.c
@@ -59,6 +59,8 @@
 #define CREATE_TRACE_POINTS
 #include "gpu_scheduler_trace.h"
 
+#include "sched_stats.h"
+
 #define to_drm_sched_job(sched_job)		\
 		container_of((sched_job), struct drm_sched_job, queue_node)
 
@@ -1014,12 +1016,17 @@ int drm_sched_init(struct drm_gpu_scheduler *sched,
 	atomic_set(&sched->_score, 0);
 	atomic64_set(&sched->job_id_count, 0);
 
+	ret = drm_sched_stats_init(sched);
+	if (ret)
+		return ret;
+
 	/* Each scheduler will run on a seperate kernel thread */
 	sched->thread = kthread_run(drm_sched_main, sched, sched->name);
 	if (IS_ERR(sched->thread)) {
 		ret = PTR_ERR(sched->thread);
 		sched->thread = NULL;
 		DRM_DEV_ERROR(sched->dev, "Failed to create scheduler for %s.\n", name);
+		drm_sched_stats_fini(sched);
 		return ret;
 	}
 
@@ -1040,6 +1047,8 @@ void drm_sched_fini(struct drm_gpu_scheduler *sched)
 	struct drm_sched_entity *s_entity;
 	int i;
 
+	drm_sched_stats_fini(sched);
+
 	if (sched->thread)
 		kthread_stop(sched->thread);
 
diff --git a/drivers/gpu/drm/scheduler/sched_stats.c b/drivers/gpu/drm/scheduler/sched_stats.c
new file mode 100644
index 000000000000..48409489deb1
--- /dev/null
+++ b/drivers/gpu/drm/scheduler/sched_stats.c
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2018 Pengutronix
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <drm/drm_sysfs.h>
+#include <drm/gpu_scheduler.h>
+
+#include "sched_stats.h"
+
+struct drm_sched_stats_engines {
+	struct kobject		kobj;
+};
+
+static struct device_type drm_sched_class_type = {
+	.name = "scheduler",
+};
+
+static struct device drm_sched_class_device = {
+	.type = &drm_sched_class_type,
+};
+
+static void drm_sched_stats_rings_kobj_release(struct kobject *kobj)
+{
+	struct drm_sched_stats_engines *engines =
+		container_of(kobj, struct drm_sched_stats_engines, kobj);
+
+	kfree(engines);
+}
+
+static struct kobj_type drm_sched_rings_class_type = {
+	.release = &drm_sched_stats_rings_kobj_release,
+};
+
+static struct drm_sched_stats_engines *rings;
+
+
+static struct attribute drm_sched_stats_active = {
+	.name = "active_us",
+	.mode = S_IRUGO
+};
+
+static void drm_sched_stats_kobj_release(struct kobject *kobj)
+{
+	struct drm_gpu_scheduler_stats *stats =
+		container_of(kobj, struct drm_gpu_scheduler_stats, kobj);
+
+	kfree(stats);
+}
+
+static ssize_t drm_sched_stats_show(struct kobject *kobj,
+				 struct attribute *attr,
+				 char *buffer)
+{
+	struct drm_gpu_scheduler_stats *stats =
+		container_of(kobj, struct drm_gpu_scheduler_stats, kobj);
+	uint64_t val = 0;
+
+	spin_lock_irq(&stats->lock);
+
+	val = stats->active_time_us;
+	if (stats->active)
+		val += ktime_to_us(ktime_sub(ktime_get(), stats->active_ts));
+
+	spin_unlock_irq(&stats->lock);
+
+	return snprintf(buffer, PAGE_SIZE, "%llu\n", val);
+}
+static struct attribute *drm_sched_stats_attrs[] = {
+	&drm_sched_stats_active,
+	NULL
+};
+ATTRIBUTE_GROUPS(drm_sched_stats);
+
+static const struct sysfs_ops drm_sched_stats_ops = {
+	.show = &drm_sched_stats_show,
+};
+
+static struct kobj_type drm_sched_stats_kobj_type = {
+	.release = drm_sched_stats_kobj_release,
+	.sysfs_ops = &drm_sched_stats_ops,
+	.default_groups = drm_sched_stats_groups,
+};
+
+int drm_sched_stats_init(struct drm_gpu_scheduler *sched)
+{
+	int ret;
+
+	sched->stats = kzalloc(sizeof(*sched->stats), GFP_KERNEL);
+	if (!sched->stats)
+		return -ENOMEM;
+
+	spin_lock_init(&sched->stats->lock);
+
+	ret = kobject_init_and_add(&sched->stats->kobj,
+				   &drm_sched_stats_kobj_type,
+				   &rings->kobj, "%s", sched->name);
+
+	if (ret) {
+		pr_warn("could not inititialize stats for drm scheduler %s\n",
+			sched->name);
+		kfree(sched->stats);
+		sched->stats = NULL;
+	}
+
+	return 0;
+}
+
+void drm_sched_stats_fini(struct drm_gpu_scheduler *sched)
+{
+	if (!sched->stats)
+		return;
+
+	kobject_put(&sched->stats->kobj);
+	sched->stats = NULL;
+}
+
+int __init drm_sched_stats_class_init(void)
+{
+	int ret;
+
+	ret = dev_set_name(&drm_sched_class_device, "scheduler");
+	if (ret)
+		return ret;
+
+	ret = drm_class_device_register(&drm_sched_class_device);
+	if (ret)
+		return ret;
+
+	rings = kzalloc(sizeof(*rings), GFP_KERNEL);
+	if (!rings) {
+		ret = -ENOMEM;
+		goto unregister_device;
+	}
+	ret = kobject_init_and_add(&rings->kobj,
+				   &drm_sched_rings_class_type,
+				   &drm_sched_class_device.kobj,
+				   "%s", "rings");
+	if (ret) {
+		kobject_put(&rings->kobj);
+		goto unregister_device;
+	}
+
+	return 0;
+
+unregister_device:
+	drm_class_device_unregister(&drm_sched_class_device);
+
+	return ret;
+}
+
+void __exit drm_sched_stats_class_fini(void)
+{
+	drm_class_device_unregister(&drm_sched_class_device);
+}
diff --git a/drivers/gpu/drm/scheduler/sched_stats.h b/drivers/gpu/drm/scheduler/sched_stats.h
new file mode 100644
index 000000000000..e3e3e73bf279
--- /dev/null
+++ b/drivers/gpu/drm/scheduler/sched_stats.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2018 Pengutronix
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _DRM_SCHED_STATS_H_
+#define _DRM_SCHED_STATS_H_
+
+#include <linux/init.h>
+#include <drm/gpu_scheduler.h>
+
+int drm_sched_stats_init(struct drm_gpu_scheduler *sched);
+void drm_sched_stats_fini(struct drm_gpu_scheduler *sched);
+
+int __init drm_sched_stats_class_init(void);
+void __exit drm_sched_stats_class_fini(void);
+
+#endif
diff --git a/include/drm/gpu_scheduler.h b/include/drm/gpu_scheduler.h
index dcd15e024976..f37e3e2435ae 100644
--- a/include/drm/gpu_scheduler.h
+++ b/include/drm/gpu_scheduler.h
@@ -27,6 +27,7 @@
 #include <drm/spsc_queue.h>
 #include <linux/dma-fence.h>
 #include <linux/completion.h>
+#include <linux/kobject.h>
 #include <linux/xarray.h>
 #include <linux/workqueue.h>
 
@@ -407,6 +408,16 @@ struct drm_sched_backend_ops {
 	void (*free_job)(struct drm_sched_job *sched_job);
 };
 
+struct drm_gpu_scheduler;
+
+struct drm_gpu_scheduler_stats {
+	struct kobject			kobj;
+	spinlock_t			lock;
+	uint64_t			active_time_us;
+	ktime_t				active_ts;
+	bool				active;
+};
+
 /**
  * struct drm_gpu_scheduler
  *
@@ -458,6 +469,7 @@ struct drm_gpu_scheduler {
 	bool				ready;
 	bool				free_guilty;
 	struct device			*dev;
+	struct drm_gpu_scheduler_stats	*stats;
 };
 
 int drm_sched_init(struct drm_gpu_scheduler *sched,
