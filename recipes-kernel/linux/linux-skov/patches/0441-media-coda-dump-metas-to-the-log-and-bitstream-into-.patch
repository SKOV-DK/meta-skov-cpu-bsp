From: Philipp Zabel <p.zabel@pengutronix.de>
Date: Mon, 18 Mar 2019 16:06:54 +0100
Subject: [PATCH] media: coda: dump metas to the log and bitstream into a
 device coredump on PIC_RUN timeout

If the BIT processor PIC_RUN command times out, dump the metas to
the log and write a devcoredump that contains the bitstream payload.

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 drivers/media/platform/coda/coda-common.c | 81 ++++++++++++++++++++-----------
 1 file changed, 52 insertions(+), 29 deletions(-)

diff --git a/drivers/media/platform/coda/coda-common.c b/drivers/media/platform/coda/coda-common.c
index a8bd92d0eef9..c610299cdecd 100644
--- a/drivers/media/platform/coda/coda-common.c
+++ b/drivers/media/platform/coda/coda-common.c
@@ -1394,6 +1394,54 @@ static void coda_device_run(void *m2m_priv)
 	queue_work(dev->workqueue, &ctx->pic_run_work);
 }
 
+static void coda_dump_metas(struct coda_ctx *ctx)
+{
+	struct v4l2_device *v4l2_dev = &ctx->dev->v4l2_dev;
+	struct coda_buffer_meta *meta;
+
+	list_for_each_entry(meta, &ctx->buffer_meta_list, list) {
+		unsigned int mask = ctx->bitstream_fifo.kfifo.mask;
+		unsigned int meta_start = meta->start & mask;
+		unsigned int meta_end = meta->end & mask;
+		char *buf = ctx->bitstream.vaddr + meta_start;
+
+		v4l2_err(v4l2_dev,
+			 "\tmeta %d: %u - %u (%02x %02x %02x %02x %02x)\n",
+			 meta->sequence, meta_start, meta_end,
+			 buf[0], buf[1], buf[2], buf[3], buf[4]);
+	}
+}
+
+static void coda_dump_payload(struct coda_ctx *ctx)
+{
+	struct v4l2_device *v4l2_dev = &ctx->dev->v4l2_dev;
+	unsigned int payload;
+	void *dump;
+
+	payload = coda_get_bitstream_payload(ctx);
+	if (!payload)
+		return;
+
+	dump = vmalloc(payload);
+	if (dump) {
+		unsigned int start = ctx->bitstream_fifo.kfifo.out &
+				     ctx->bitstream_fifo.kfifo.mask;
+		unsigned int count = min_t(unsigned int, payload,
+					   ctx->bitstream.size - start);
+
+		v4l2_err(v4l2_dev, "\tpayload %u-%u\n", start, start + count);
+		memcpy(dump, ctx->bitstream.vaddr + start, count);
+		if (count < payload) {
+			v4l2_err(v4l2_dev, "\tpayload 0-%u\n", payload - count);
+			memcpy(dump + count, ctx->bitstream.vaddr,
+			       payload - count);
+		}
+
+		dev_coredumpv(ctx->dev->v4l2_dev.dev, dump, payload,
+			      GFP_KERNEL);
+	}
+}
+
 static void coda_pic_run_work(struct work_struct *work)
 {
 	struct coda_ctx *ctx = container_of(work, struct coda_ctx, pic_run_work);
@@ -1416,6 +1464,8 @@ static void coda_pic_run_work(struct work_struct *work)
 		if (ctx->use_bit) {
 			dev_err(&dev->plat_dev->dev, "CODA PIC_RUN timeout\n");
 			coda_bit_debug_timeout(ctx);
+			coda_dump_metas(ctx);
+			coda_dump_payload(ctx);
 
 			ctx->hold = true;
 
@@ -1775,34 +1825,6 @@ void coda_free_aux_buf(struct coda_dev *dev,
 	}
 }
 
-static void coda_dump_metas(struct coda_ctx *ctx, unsigned int payload)
-{
-	struct v4l2_device *v4l2_dev = &ctx->dev->v4l2_dev;
-	struct coda_buffer_meta *meta;
-	void *dump;
-
-	list_for_each_entry(meta, &ctx->buffer_meta_list, list) {
-		unsigned int mask = ctx->bitstream_fifo.kfifo.mask;
-		unsigned int meta_start = meta->start & mask;
-		unsigned int meta_end = meta->end & mask;
-		char *buf = ctx->bitstream.vaddr + meta_start;
-
-		v4l2_err(v4l2_dev,
-			 "\tmeta %d: %u - %u (%02x %02x %02x %02x %02x)\n",
-			 meta->sequence, meta_start, meta_end,
-			 buf[0], buf[1], buf[2], buf[3], buf[4]);
-	}
-
-	if (payload) {
-		dump = vmalloc(payload);
-		if (dump) {
-			memcpy(dump, ctx->bitstream.vaddr, payload);
-			dev_coredumpv(ctx->dev->v4l2_dev.dev, dump, payload,
-				      GFP_KERNEL);
-		}
-	}
-}
-
 static int coda_start_streaming(struct vb2_queue *q, unsigned int count)
 {
 	struct coda_ctx *ctx = vb2_get_drv_priv(q);
@@ -1833,7 +1855,8 @@ static int coda_start_streaming(struct vb2_queue *q, unsigned int count)
 			if (payload < 512) {
 				v4l2_err(v4l2_dev, "start payload: %u < 512, count: %u\n",
 					 payload, count);
-				coda_dump_metas(ctx, payload);
+				coda_dump_metas(ctx);
+				coda_dump_payload(ctx);
 				ret = -EINVAL;
 				goto err;
 			}
