From: Philipp Zabel <p.zabel@pengutronix.de>
Date: Mon, 28 Oct 2019 10:33:54 +0100
Subject: [PATCH] media: coda: thread all interrupts other than pic run done

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 drivers/media/platform/coda/coda-bit.c    | 114 ++++++++++++++++--------------
 drivers/media/platform/coda/coda-common.c |   5 +-
 drivers/media/platform/coda/coda.h        |   2 +
 3 files changed, 67 insertions(+), 54 deletions(-)

diff --git a/drivers/media/platform/coda/coda-bit.c b/drivers/media/platform/coda/coda-bit.c
index 655c656f4f8a..d0bd93102f63 100644
--- a/drivers/media/platform/coda/coda-bit.c
+++ b/drivers/media/platform/coda/coda-bit.c
@@ -2788,77 +2788,87 @@ irqreturn_t coda_irq_handler(int irq, void *data)
 	status = coda_read(dev, CODA_REG_BIT_INT_STATUS);
 	reason = coda_read(dev, CODA_REG_BIT_INT_REASON);
 	coda_write(dev, 0, CODA_REG_BIT_INT_REASON);
-	coda_write(dev, CODA_REG_BIT_INT_CLEAR_SET,
-		      CODA_REG_BIT_INT_CLEAR);
+	coda_write(dev, CODA_REG_BIT_INT_CLEAR_SET, CODA_REG_BIT_INT_CLEAR);
 
 	if (status != 1)
 		pr_debug("coda: interrupt status 0x%x\n", status);
 
-	switch (reason) {
-	case CODA_INT_BIT_INIT:
-	case CODA_INT_BIT_SEQ_INIT:
-	case CODA_INT_BIT_SEQ_END:
-	case CODA_INT_BIT_PIC_RUN:
-	case CODA_INT_BIT_SET_FRAME_BUF:
-		break;
-	case CODA_INT_BIT_BUF_EMPTY:
-		pr_debug("coda: interrupt reason 0x%x (buf empty)\n", reason);
-
+	if (reason & CODA_INT_BIT_PIC_RUN) {
 		ctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);
-		if (ctx) {
-			struct __kfifo *kfifo = &ctx->bitstream_fifo.kfifo;
-
-			pr_debug("coda: before: rd = 0x%x, wr = 0x%x\n",
-				 kfifo->out & kfifo->mask,
-				 kfifo->in & kfifo->mask);
-			coda_kfifo_sync_from_device(ctx);
-			pr_debug("coda: after: rd = 0x%x, wr = 0x%x\n",
-				 kfifo->out & kfifo->mask,
-				 kfifo->in & kfifo->mask);
-
-			if (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264) {
-				mutex_lock(&ctx->bitstream_mutex);
-				/* Pad the bitstream */
-				coda_h264_bitstream_pad(ctx, 768);
-
-				pr_debug("coda: padded: rd = 0x%x, wr = 0x%x\n",
-					 kfifo->out & kfifo->mask,
-					 kfifo->in & kfifo->mask);
-
-				/* Sync read pointer to device */
-				coda_kfifo_sync_to_device_write(ctx);
-				mutex_unlock(&ctx->bitstream_mutex);
-			}
+		if (ctx == NULL) {
+			v4l2_err(&dev->v4l2_dev,
+				 "Instance released before the end of transaction\n");
+			return IRQ_HANDLED;
 		}
-		break;
-	default:
-		pr_debug("coda: interrupt reason 0x%x\n", reason);
-		break;
+
+		trace_coda_bit_done(ctx);
+		coda_stats_done(dev->bit_stats);
+
+		if (ctx->aborting) {
+			coda_dbg(1, ctx, "task has been aborted\n");
+		}
+
+		if (coda_isbusy(ctx->dev)) {
+			coda_dbg(1, ctx, "coda is still busy!!!!\n");
+			return IRQ_NONE;
+		}
+
+		complete(&ctx->completion);
+	}
+
+	reason &= ~CODA_INT_BIT_PIC_RUN;
+	if (reason) {
+		dev->bit_int_reason = reason;
+		return IRQ_WAKE_THREAD;
 	}
 
-	if (!(reason & CODA_INT_BIT_PIC_RUN))
+	return IRQ_HANDLED;
+}
+
+irqreturn_t coda_threaded_irq_handler(int irq, void *data)
+{
+	struct coda_dev *dev = data;
+	struct coda_ctx *ctx;
+	struct __kfifo *kfifo;
+
+	if (dev->bit_int_reason != CODA_INT_BIT_BUF_EMPTY) {
+		pr_debug("coda: interrupt reason 0x%x\n", dev->bit_int_reason);
 		return IRQ_HANDLED;
+	}
+
+	pr_debug("coda: interrupt reason 0x%x (buf empty)\n",
+		 dev->bit_int_reason);
 
 	ctx = v4l2_m2m_get_curr_priv(dev->m2m_dev);
 	if (ctx == NULL) {
 		v4l2_err(&dev->v4l2_dev,
-			 "Instance released before the end of transaction\n");
+			 "Buffer underrun on released instance\n");
 		return IRQ_HANDLED;
 	}
 
-	trace_coda_bit_done(ctx);
-	coda_stats_done(dev->bit_stats);
+	kfifo = &ctx->bitstream_fifo.kfifo;
 
-	if (ctx->aborting) {
-		coda_dbg(1, ctx, "task has been aborted\n");
-	}
+	pr_debug("coda: before: rd = 0x%x, wr = 0x%x\n",
+		 kfifo->out & kfifo->mask,
+		 kfifo->in & kfifo->mask);
+	coda_kfifo_sync_from_device(ctx);
+	pr_debug("coda: after: rd = 0x%x, wr = 0x%x\n",
+		 kfifo->out & kfifo->mask,
+		 kfifo->in & kfifo->mask);
 
-	if (coda_isbusy(ctx->dev)) {
-		coda_dbg(1, ctx, "coda is still busy!!!!\n");
-		return IRQ_NONE;
-	}
+	if (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264) {
+		mutex_lock(&ctx->bitstream_mutex);
+		/* Pad the bitstream */
+		coda_h264_bitstream_pad(ctx, 768);
+
+		pr_debug("coda: padded: rd = 0x%x, wr = 0x%x\n",
+			 kfifo->out & kfifo->mask,
+			 kfifo->in & kfifo->mask);
 
-	complete(&ctx->completion);
+		/* Sync read pointer to device */
+		coda_kfifo_sync_to_device_write(ctx);
+		mutex_unlock(&ctx->bitstream_mutex);
+	}
 
 	return IRQ_HANDLED;
 }
diff --git a/drivers/media/platform/coda/coda-common.c b/drivers/media/platform/coda/coda-common.c
index d43df6ba58b0..cad21f34d682 100644
--- a/drivers/media/platform/coda/coda-common.c
+++ b/drivers/media/platform/coda/coda-common.c
@@ -3547,8 +3547,9 @@ static int coda_probe(struct platform_device *pdev)
 	if (irq < 0)
 		return irq;
 
-	ret = devm_request_irq(&pdev->dev, irq, coda_irq_handler, 0,
-			       CODA_NAME "-video", dev);
+	ret = devm_request_threaded_irq(&pdev->dev, irq, coda_irq_handler,
+					coda_threaded_irq_handler, IRQF_ONESHOT,
+					CODA_NAME "-video", dev);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to request irq: %d\n", ret);
 		return ret;
diff --git a/drivers/media/platform/coda/coda.h b/drivers/media/platform/coda/coda.h
index 301175bd869f..774156d73691 100644
--- a/drivers/media/platform/coda/coda.h
+++ b/drivers/media/platform/coda/coda.h
@@ -109,6 +109,7 @@ struct coda_dev {
 	struct mutex		coda_mutex;
 	struct workqueue_struct	*workqueue;
 	struct v4l2_m2m_dev	*m2m_dev;
+	u32			bit_int_reason;
 	struct ida		ida;
 	struct dentry		*debugfs_root;
 	struct ratelimit_state	mb_err_rs;
@@ -425,6 +426,7 @@ extern const struct coda_context_ops coda9_jpeg_encode_ops;
 extern const struct coda_context_ops coda9_jpeg_decode_ops;
 
 irqreturn_t coda_irq_handler(int irq, void *data);
+irqreturn_t coda_threaded_irq_handler(int irq, void *data);
 irqreturn_t coda9_jpeg_irq_handler(int irq, void *data);
 
 static inline void coda_stats_run(struct v4l2_stats *stats)
