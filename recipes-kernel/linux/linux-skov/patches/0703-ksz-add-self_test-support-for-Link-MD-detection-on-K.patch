From: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date: Wed, 8 May 2019 17:33:44 +0200
Subject: [PATCH] ksz: add self_test support for Link-MD detection on KSZ8863

The KSZ8863/KSZ8873 is capable of testing the Link-Quality of the cable.
We implement a self_test to measure the results.

Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
---
 drivers/net/dsa/microchip/ksz8795.c     | 80 +++++++++++++++++++++++++++++++--
 drivers/net/dsa/microchip/ksz8795_reg.h |  3 ++
 2 files changed, 80 insertions(+), 3 deletions(-)

diff --git a/drivers/net/dsa/microchip/ksz8795.c b/drivers/net/dsa/microchip/ksz8795.c
index 040bb0cc51f8..537d3eb0e651 100644
--- a/drivers/net/dsa/microchip/ksz8795.c
+++ b/drivers/net/dsa/microchip/ksz8795.c
@@ -719,6 +719,7 @@ static void ksz8_r_phy(struct ksz_device *dev, u16 phy, u16 reg, u16 *val)
 	u16 data = 0;
 	u8 p = phy;
 
+	mutex_lock(&dev->dev_mutex);
 	switch (reg) {
 	case PHY_REG_CTRL:
 		ksz_pread8(dev, p, regs[P_NEG_RESTART_CTRL], &restart);
@@ -809,6 +810,7 @@ static void ksz8_r_phy(struct ksz_device *dev, u16 phy, u16 reg, u16 *val)
 	}
 	if (processed)
 		*val = data;
+	mutex_unlock(&dev->dev_mutex);
 }
 
 static void ksz8_w_phy(struct ksz_device *dev, u16 phy, u16 reg, u16 val)
@@ -818,6 +820,7 @@ static void ksz8_w_phy(struct ksz_device *dev, u16 phy, u16 reg, u16 val)
 	const u8 *regs = ksz8->regs;
 	u8 restart, speed, ctrl, data;
 
+	mutex_lock(&dev->dev_mutex);
 	switch (reg) {
 	case PHY_REG_CTRL:
 
@@ -916,6 +919,7 @@ static void ksz8_w_phy(struct ksz_device *dev, u16 phy, u16 reg, u16 val)
 	default:
 		break;
 	}
+	mutex_unlock(&dev->dev_mutex);
 }
 
 static enum dsa_tag_protocol ksz8_get_tag_protocol(struct dsa_switch *ds,
@@ -927,16 +931,84 @@ static enum dsa_tag_protocol ksz8_get_tag_protocol(struct dsa_switch *ds,
 		DSA_TAG_PROTO_KSZ8795 : DSA_TAG_PROTO_KSZ8863;
 }
 
+enum ksz8_ethtool_tests {
+	KSZ8_ETHTOOL_LINK_MD_QUALITY_TEST,
+	KSZ8_ETHTOOL_LINK_MD_ERROR_TEST,
+	KSZ8_ETHTOOL_TEST_MAX,
+};
+
+static const char ksz8_tests_str_arr[KSZ8_ETHTOOL_TEST_MAX][ETH_GSTRING_LEN] = {
+	"LinkMD Quality (online)",
+	"LinkMD Error Distance (online)",
+};
+
 static void ksz8_get_strings(struct dsa_switch *ds, int port,
 			     u32 stringset, uint8_t *buf)
 {
 	struct ksz_device *dev = ds->priv;
 	int i;
 
-	for (i = 0; i < dev->mib_cnt; i++) {
-		memcpy(buf + i * ETH_GSTRING_LEN,
-		       dev->mib_names[i].string, ETH_GSTRING_LEN);
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < dev->mib_cnt; i++) {
+			memcpy(buf + i * ETH_GSTRING_LEN,
+			       dev->mib_names[i].string, ETH_GSTRING_LEN);
+		}
+		break;
+	case ETH_SS_TEST:
+		memcpy(buf, ksz8_tests_str_arr,
+			ETH_GSTRING_LEN * KSZ8_ETHTOOL_TEST_MAX);
+		break;
 	}
+
+}
+
+static void ksz8_self_test(struct dsa_switch *ds, int port,
+                               struct ethtool_test *test, uint64_t *data)
+{
+	struct ksz_device *dev = ds->priv;
+	u8 mdctrl = 0;
+	u8 mdstat = 0;
+	int timeout = 500;
+
+	mutex_lock(&dev->dev_mutex);
+	memset(data, 0, test->len * sizeof(uint64_t));
+
+	/* Undocumented: disable all advertisement and flow control
+	 * before test. This makes the test much more stable
+	 */
+	ksz_write8(dev, PORT_CTRL_ADDR(port, REG_PORT_CTRL_12), 0x00);
+	ksz_port_cfg(dev, port, REG_PORT_CTRL_13, PORT_AUTO_MDIX_DISABLE, true);
+
+	ksz_port_cfg(dev, port, REG_PORT_LINK_MD_CTRL, PORT_START_CABLE_DIAG, true);
+
+	do {
+		ksz_pread8(dev, port, REG_PORT_LINK_MD_CTRL, &mdctrl);
+		timeout--;
+		if (!timeout)
+			break;
+	} while (mdctrl & PORT_START_CABLE_DIAG);
+
+	ksz_pread8(dev, port, REG_PORT_LINK_MD_RESULT, &mdstat);
+
+	ksz_write8(dev, PORT_CTRL_ADDR(port, REG_PORT_CTRL_12), 0xff);
+	ksz_port_cfg(dev, port, REG_PORT_CTRL_13, PORT_AUTO_MDIX_DISABLE, false);
+
+	if (!port || ((mdctrl & PORT_CABLE_DIAG_RESULT)
+		      == PORT_CABLE_DIAG_RESULT)) {
+		int i;
+		for (i = 0; i < test->len; i++)
+			data[i] = 1;
+		test->flags |= ETH_TEST_FL_FAILED;
+		mutex_unlock(&dev->dev_mutex);
+		return;
+	}
+
+	if (mdctrl & (PORT_CABLE_DIAG_RESULT | PORT_CABLE_10M_SHORT)) {
+		data[0] |= (mdctrl & (PORT_CABLE_DIAG_RESULT | PORT_CABLE_10M_SHORT));
+		data[1] = (((mdctrl & 0x1) << 8) | mdstat) * 2 / 5;
+	}
+	mutex_unlock(&dev->dev_mutex);
 }
 
 static void ksz8_cfg_port_member(struct ksz_device *dev, int port, u8 member)
@@ -1677,6 +1749,7 @@ static const struct dsa_switch_ops ksz8_switch_ops = {
 	.phylink_mac_link_state	= ksz_get_state,
 	.port_enable		= ksz_enable_port,
 	.port_disable		= ksz_disable_port,
+	.self_test		= ksz8_self_test,
 	.get_strings		= ksz8_get_strings,
 	.get_ethtool_stats	= ksz_get_ethtool_stats,
 	.get_sset_count		= ksz_sset_count,
@@ -1840,6 +1913,7 @@ static int ksz8_switch_init(struct ksz_device *dev)
 	dev->port_mask |= dev->host_mask;
 
 	dev->reg_mib_cnt = KSZ8795_COUNTER_NUM;
+	dev->test_cnt = KSZ8_ETHTOOL_TEST_MAX;
 
 	dev->phy_port_cnt = dev->port_cnt - 1;
 
diff --git a/drivers/net/dsa/microchip/ksz8795_reg.h b/drivers/net/dsa/microchip/ksz8795_reg.h
index 4786297d6b03..d754768100dd 100644
--- a/drivers/net/dsa/microchip/ksz8795_reg.h
+++ b/drivers/net/dsa/microchip/ksz8795_reg.h
@@ -248,6 +248,9 @@
 #define REG_PORT_3_LINK_MD_CTRL		0x3A
 #define REG_PORT_4_LINK_MD_CTRL		0x4A
 
+#define PORT_CABLE_DIAG_RESULT		(PORT_CABLE_DIAG_RESULT_M << \
+						PORT_CABLE_DIAG_RESULT_S)
+
 #define PORT_CABLE_10M_SHORT		BIT(7)
 #define PORT_CABLE_DIAG_RESULT_M	0x3
 #define PORT_CABLE_DIAG_RESULT_S	5
