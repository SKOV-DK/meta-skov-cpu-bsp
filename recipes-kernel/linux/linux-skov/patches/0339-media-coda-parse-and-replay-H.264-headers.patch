From: Philipp Zabel <p.zabel@pengutronix.de>
Date: Fri, 18 Oct 2019 14:38:01 +0200
Subject: [PATCH] media: coda: parse and replay H.264 headers

Store a copy of the H.264 SPS and PPS headers and reuse them if the
first buffer after a stream restart does not contain new headers.

This allows to support keyframe-only reverse playback as currently
implemented by GStreamer without having to enable SPS and PPS insertion
with every IDR frame.

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 drivers/media/platform/coda/coda-bit.c  | 33 +++++++++++++++++
 drivers/media/platform/coda/coda-h264.c | 64 +++++++++++++++++++++++++++++++++
 drivers/media/platform/coda/coda.h      | 11 ++++++
 3 files changed, 108 insertions(+)

diff --git a/drivers/media/platform/coda/coda-bit.c b/drivers/media/platform/coda/coda-bit.c
index ea9fd3523ccd..52158c19a0d8 100644
--- a/drivers/media/platform/coda/coda-bit.c
+++ b/drivers/media/platform/coda/coda-bit.c
@@ -405,6 +405,37 @@ void coda_fill_bitstream(struct coda_ctx *ctx, struct list_head *buffer_list)
 			continue;
 		}
 
+		if (ctx->codec->src_fourcc == V4L2_PIX_FMT_H264) {
+			u32 nalu_types;
+			bool sps_pps;
+
+			nalu_types = coda_h264_parse_headers(ctx,
+							     &src_buf->vb2_buf);
+
+			/* Does the buffer contain both SPS and PPS headers? */
+			sps_pps = (nalu_types &
+				   (BIT(NALU_TYPE_SPS) | BIT(NALU_TYPE_PPS))) ==
+				  (BIT(NALU_TYPE_SPS) | BIT(NALU_TYPE_PPS));
+
+			if (ctx->qsequence == 0 && !sps_pps &&
+			    ctx->vpu_header_size[0] &&
+			    ctx->vpu_header_size[1]) {
+				int i, ret;
+
+				coda_dbg(1, ctx, "queueing previously recorded SPS + PPS headers\n");
+
+				for (i = 0; i < 2; i++) {
+					ret = coda_bitstream_queue(ctx, ctx->vpu_header[i],
+								   ctx->vpu_header_size[i]);
+					if (ret < 0) {
+						v4l2_err(&ctx->dev->v4l2_dev,
+							 "failed to queue previously recorded SPS + PPS headers\n");
+						return;
+					}
+				}
+			}
+		}
+
 		/* Buffer start position */
 		start = ctx->bitstream_fifo.kfifo.in;
 
@@ -1891,6 +1922,8 @@ static int coda_decoder_reqbufs(struct coda_ctx *ctx,
 			return ret;
 		}
 	} else {
+		ctx->vpu_header_size[0] = 0;
+		ctx->vpu_header_size[1] = 0;
 		coda_free_bitstream_buffer(ctx);
 		coda_free_context_buffers(ctx);
 	}
diff --git a/drivers/media/platform/coda/coda-h264.c b/drivers/media/platform/coda/coda-h264.c
index 8bd0aa8af114..7652a5a613aa 100644
--- a/drivers/media/platform/coda/coda-h264.c
+++ b/drivers/media/platform/coda/coda-h264.c
@@ -46,6 +46,70 @@ int coda_sps_parse_profile(struct coda_ctx *ctx, struct vb2_buffer *vb)
 	return 0;
 }
 
+static void coda_h264_update_header(struct coda_ctx *ctx, int index,
+				    const u8 *buf, size_t len)
+{
+	size_t old_len = ctx->vpu_header_size[index];
+
+	if (len > sizeof(ctx->vpu_header[index])) {
+		coda_dbg(1, ctx, "ignoring %s parameter set > 64 bytes\n",
+			 index ? "picture" : "sequence");
+	} else if (old_len != len || memcmp(ctx->vpu_header[index], buf, len)) {
+		memcpy(ctx->vpu_header[index], buf, len);
+		ctx->vpu_header_size[index] = len;
+	}
+}
+
+/**
+ * coda_h264_parse_headers - collect prepended SPS/PPS headers
+ *
+ * This should be quick to run on all queued buffers. It is expected that most
+ * buffers directly start with a coded slice header, or with an access unit
+ * delimiter followed by a coded slice header. In both cases, this function
+ * will only look at a single cache line.
+ *
+ * Returns a bitfield of detected NAL types.
+ */
+u32 coda_h264_parse_headers(struct coda_ctx *ctx, struct vb2_buffer *vb)
+{
+	const u8 *buf = vb2_plane_vaddr(vb, 0);
+	const u8 *end = buf + vb2_get_plane_payload(vb, 0);
+	const u8 *nal, *next_nal;
+	u32 nalu_types = 0;
+
+	for (nal = coda_find_nal_header(buf, end); nal; nal = next_nal) {
+		u8 nal_unit_type = *nal++ & 0x1f;
+
+		nalu_types |= BIT(nal_unit_type);
+
+		/* stop at coded slice and end of sequence/stream NAL units */
+		if (nal_unit_type == NALU_TYPE_CODED_SLICE_NON_IDR ||
+		    nal_unit_type == NALU_TYPE_CODED_SLICE_IDR ||
+		    nal_unit_type == NALU_TYPE_END_OF_SEQ ||
+		    nal_unit_type == NALU_TYPE_END_OF_STREAM)
+			break;
+
+		next_nal = coda_find_nal_header(nal, end);
+
+		/* store SPS and PPS NAL units */
+		if (nal_unit_type == NALU_TYPE_SPS ||
+		    nal_unit_type == NALU_TYPE_PPS) {
+			int index = nal_unit_type - NALU_TYPE_SPS;
+			size_t len;
+
+			if (index == 0) {
+				ctx->params.h264_profile_idc = nal[0];
+				ctx->params.h264_level_idc = nal[2];
+			}
+			/* include start code prefix and NAL header byte */
+			len = next_nal ? (next_nal - nal + 1) : (end - nal + 5);
+			coda_h264_update_header(ctx, index, nal - 5, len);
+		}
+	}
+
+	return nalu_types;
+}
+
 int coda_h264_filler_nal(int size, char *p)
 {
 	if (size < 6)
diff --git a/drivers/media/platform/coda/coda.h b/drivers/media/platform/coda/coda.h
index cd1ade4681c2..a2c5c78d61ca 100644
--- a/drivers/media/platform/coda/coda.h
+++ b/drivers/media/platform/coda/coda.h
@@ -54,6 +54,16 @@ enum coda_product {
 	CODA_960 = 0xf020,
 };
 
+enum coda_h264_nal_unit_type {
+	NALU_TYPE_CODED_SLICE_NON_IDR = 1,
+	NALU_TYPE_CODED_SLICE_IDR = 5,
+	NALU_TYPE_SPS = 7,
+	NALU_TYPE_PPS = 8,
+	NALU_TYPE_END_OF_SEQ = 10,
+	NALU_TYPE_END_OF_STREAM = 11,
+	NALU_TYPE_FILLER_DATA = 12,
+};
+
 struct coda_video_device;
 
 struct coda_devtype {
@@ -390,6 +400,7 @@ int coda_h264_padding(int size, char *p);
 int coda_h264_profile(int profile_idc);
 int coda_h264_level(int level_idc);
 int coda_sps_parse_profile(struct coda_ctx *ctx, struct vb2_buffer *vb);
+u32 coda_h264_parse_headers(struct coda_ctx *ctx, struct vb2_buffer *vb);
 int coda_h264_sps_fixup(struct coda_ctx *ctx, int width, int height, char *buf,
 			int *size, int max_size);
 
