From: Philipp Zabel <p.zabel@pengutronix.de>
Date: Mon, 10 Sep 2018 17:53:23 +0200
Subject: [PATCH] media: add v4l2-stats to collect simple time based activity
 statistics

Add a dummy "stats" V4L2 class device that V4L2 drivers can hang
v4l2_stats sysfs entries off of. Those can be used to do simple
activity time tracking.

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 drivers/media/v4l2-core/v4l2-dev.c | 97 ++++++++++++++++++++++++++++++++++++++
 include/media/v4l2-dev.h           | 24 ++++++++++
 2 files changed, 121 insertions(+)

diff --git a/drivers/media/v4l2-core/v4l2-dev.c b/drivers/media/v4l2-core/v4l2-dev.c
index 4037689a945a..2fb9450f5a6f 100644
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@ -1055,6 +1055,88 @@ void video_unregister_device(struct video_device *vdev)
 }
 EXPORT_SYMBOL(video_unregister_device);
 
+static void v4l2_stats_kobj_release(struct kobject *kobj)
+{
+       struct v4l2_stats *stats = container_of(kobj, struct v4l2_stats, kobj);
+
+       kfree(stats);
+}
+
+static struct attribute v4l2_stats_active = {
+	.name = "active_us",
+	.mode = S_IRUGO
+};
+
+static struct attribute *v4l2_stats_attrs[] = {
+	&v4l2_stats_active,
+	NULL
+};
+
+static ssize_t v4l2_stats_show(struct kobject *kobj, struct attribute *attr,
+			       char *buffer)
+{
+	struct v4l2_stats *stats = container_of(kobj, struct v4l2_stats, kobj);
+	unsigned long flags;
+	uint64_t val = 0;
+
+	spin_lock_irqsave(&stats->lock, flags);
+
+	val = stats->active_time_us;
+	if (stats->active)
+		val += ktime_to_us(ktime_sub(ktime_get(), stats->active_ts));
+
+	spin_unlock_irqrestore(&stats->lock, flags);
+
+	return snprintf(buffer, PAGE_SIZE, "%llu\n", val);
+}
+
+static const struct sysfs_ops v4l2_stats_ops = {
+	.show = &v4l2_stats_show,
+};
+
+static struct kobj_type v4l2_stats_kobj_type = {
+	.release = v4l2_stats_kobj_release,
+	.sysfs_ops = &v4l2_stats_ops,
+	.default_attrs = v4l2_stats_attrs,
+};
+
+struct device_type v4l2_stats_type = {
+	.name = "stats",
+};
+
+static struct device v4l2_stats_device = {
+	.class = &video_class,
+	.type = &v4l2_stats_type,
+};
+
+struct v4l2_stats *v4l2_register_stats(const char *name)
+{
+	struct v4l2_stats *stats;
+	int err;
+
+	stats = kzalloc(sizeof(*stats), GFP_KERNEL);
+	if (!stats)
+		return ERR_PTR(-ENOMEM);
+
+	spin_lock_init(&stats->lock);
+	err = kobject_init_and_add(&stats->kobj, &v4l2_stats_kobj_type,
+				   &v4l2_stats_device.kobj, "%s", name);
+	if (err)
+		return ERR_PTR(err);
+
+	return stats;
+}
+EXPORT_SYMBOL_GPL(v4l2_register_stats);
+
+void v4l2_unregister_stats(struct v4l2_stats *stats)
+{
+	if (!stats)
+		return;
+
+	kobject_put(&stats->kobj);
+}
+EXPORT_SYMBOL_GPL(v4l2_unregister_stats);
+
 /*
  *	Initialise video for linux
  */
@@ -1078,6 +1160,20 @@ static int __init videodev_init(void)
 		return -EIO;
 	}
 
+	ret = dev_set_name(&v4l2_stats_device, "stats");
+	if (ret) {
+		class_unregister(&video_class);
+		unregister_chrdev_region(dev, VIDEO_NUM_DEVICES);
+		return ret;
+	}
+
+	ret = device_register(&v4l2_stats_device);
+	if (ret < 0) {
+		class_unregister(&video_class);
+		unregister_chrdev_region(dev, VIDEO_NUM_DEVICES);
+		return -EIO;
+	}
+
 	return 0;
 }
 
@@ -1085,6 +1181,7 @@ static void __exit videodev_exit(void)
 {
 	dev_t dev = MKDEV(VIDEO_MAJOR, 0);
 
+	device_unregister(&v4l2_stats_device);
 	class_unregister(&video_class);
 	unregister_chrdev_region(dev, VIDEO_NUM_DEVICES);
 }
diff --git a/include/media/v4l2-dev.h b/include/media/v4l2-dev.h
index 48531e57cc5a..ca224b8ee3fe 100644
--- a/include/media/v4l2-dev.h
+++ b/include/media/v4l2-dev.h
@@ -533,4 +533,28 @@ static inline int video_is_registered(struct video_device *vdev)
 	return test_bit(V4L2_FL_REGISTERED, &vdev->flags);
 }
 
+struct v4l2_stats {
+	struct kobject	kobj;
+	spinlock_t	lock;
+	uint64_t	active_time_us;
+	ktime_t		active_ts;
+	bool		active;
+};
+
+static inline void __v4l2_stats_start(struct v4l2_stats *stats, ktime_t now)
+{
+	stats->active_ts = now;
+	stats->active = true;
+}
+
+static inline void __v4l2_stats_stop(struct v4l2_stats *stats, ktime_t now)
+{
+	stats->active_time_us += ktime_to_us(ktime_sub(now, stats->active_ts));
+	stats->active_ts = now;
+	stats->active = false;
+}
+
+struct v4l2_stats *v4l2_register_stats(const char *name);
+void v4l2_unregister_stats(struct v4l2_stats *stats);
+
 #endif /* _V4L2_DEV_H */
