From: Philipp Zabel <p.zabel@pengutronix.de>
Date: Wed, 13 Oct 2021 12:16:38 +0200
Subject: [PATCH] media: coda: low latency mode

When using the VODA (Video Date Order Adapter) on i.MX6 to de-tile
decoded h.264 frames, the de-tiling step doesn't have to be run in
parallel with the next frame. Allow to run the VDOA de-tiler right
after decoding the current frame, to reduce latency at the expense
of maximum throughput. Further, run the decoder in stream end mode
to allow the VPU to read past the end of the bitstream. After each
decoding run, while the VDOA is running, the bitstream is flushed.

This reduces the latency from two frame intervals and the decoding
duration to just the decoding duration and the de-tiling duration.

Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
---
 drivers/media/platform/chips-media/coda-bit.c    | 67 ++++++++++++++++++++----
 drivers/media/platform/chips-media/coda-common.c | 25 +++++++--
 drivers/media/platform/chips-media/coda.h        |  1 +
 3 files changed, 80 insertions(+), 13 deletions(-)

diff --git a/drivers/media/platform/chips-media/coda-bit.c b/drivers/media/platform/chips-media/coda-bit.c
index 3d7c299650ac..98529ff64321 100644
--- a/drivers/media/platform/chips-media/coda-bit.c
+++ b/drivers/media/platform/chips-media/coda-bit.c
@@ -51,6 +51,10 @@ static int disable_decoder_cache = 0;
 module_param(disable_decoder_cache, int, 0644);
 MODULE_PARM_DESC(disable_decoder_cache, "Disable 2D cache for decoder");
 
+static int low_latency = 0;
+module_param(low_latency, int, 0644);
+MODULE_PARM_DESC(low_latency, "Use low latency mode if possible");
+
 static void coda_free_bitstream_buffer(struct coda_ctx *ctx);
 
 static inline int coda_is_initialized(struct coda_dev *dev)
@@ -356,6 +360,10 @@ void coda_fill_bitstream(struct coda_ctx *ctx, struct list_head *buffer_list)
 		    ctx->num_metas > 1)
 			break;
 
+		/* Only queue a single frame in low latency mode. */
+		if (ctx->low_latency && ctx->num_metas > 0)
+			break;
+
 		if (ctx->num_internal_frames &&
 		    ctx->num_metas >= ctx->num_internal_frames) {
 			meta = list_first_entry(&ctx->buffer_meta_list,
@@ -2293,10 +2301,29 @@ static int coda_prepare_decode(struct coda_ctx *ctx)
 	/* Try to copy source buffer contents into the bitstream ringbuffer */
 	mutex_lock(&ctx->bitstream_mutex);
 	coda_fill_bitstream(ctx, NULL);
+	/*
+	 * Enable low latency mode if decoding has started with just a single
+	 * h.264 frame queued, requires VDOA.
+	 */
+	if (ctx->qsequence == 1 && ctx->num_metas == 1 && low_latency &&
+	    ctx->use_vdoa && ctx->codec->src_fourcc == V4L2_PIX_FMT_H264) {
+		coda_dbg(1, ctx, "enabling low latency mode\n");
+		ctx->low_latency = true;
+	}
 	mutex_unlock(&ctx->bitstream_mutex);
 
+	/*
+	 * Allow to read past the end of the bitstream in low latency mode.
+	 * The bitstream will be flushed and the stream end flag cleared while
+	 * the VDOA is de-tiling the decoded frame.
+	 */
+	if (ctx->low_latency)
+		ctx->bit_stream_param |= CODA_BIT_STREAM_END_FLAG;
+
 	if (coda_get_bitstream_payload(ctx) < 512 &&
-	    (!(ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG))) {
+	    !(ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG) &&
+	    !(ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 &&
+	      ctx->qsequence == 1)) {
 		coda_dbg(1, ctx, "bitstream payload: %d, skipping\n",
 			 coda_get_bitstream_payload(ctx));
 		return -EAGAIN;
@@ -2317,12 +2344,14 @@ static int coda_prepare_decode(struct coda_ctx *ctx)
 	if (dev->devtype->product == CODA_960)
 		coda_set_gdi_regs(ctx);
 
-	if (ctx->use_vdoa &&
-	    ctx->display_idx >= 0 &&
-	    ctx->display_idx < ctx->num_internal_frames) {
-		vdoa_device_run(ctx->vdoa,
-				vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0),
-				ctx->internal_frames[ctx->display_idx].buf.paddr);
+	if (ctx->use_vdoa) {
+		if (!ctx->low_latency &&
+		    ctx->display_idx >= 0 &&
+		    ctx->display_idx < ctx->num_internal_frames) {
+			vdoa_device_run(ctx->vdoa,
+					vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0),
+					ctx->internal_frames[ctx->display_idx].buf.paddr);
+		}
 	} else {
 		if (dev->devtype->product == CODA_960) {
 			/*
@@ -2545,6 +2574,7 @@ static void coda_finish_decode(struct coda_ctx *ctx)
 
 	/* Wait until the VDOA finished writing the previous display frame */
 	if (ctx->use_vdoa &&
+	    !ctx->low_latency &&
 	    ctx->display_idx >= 0 &&
 	    ctx->display_idx < ctx->num_internal_frames) {
 		err_vdoa = vdoa_wait_for_completion(ctx->vdoa);
@@ -2644,7 +2674,25 @@ static void coda_finish_decode(struct coda_ctx *ctx)
 		ctx->hold = true;
 	} else if (display_idx == -3) {
 		/* possibly prescan failure */
-	} else if (display_idx < 0 || display_idx >= ctx->num_internal_frames) {
+	} else if (display_idx >= 0 && display_idx < ctx->num_internal_frames) {
+		/*
+		 * In low latency mode, run the VDOA immediately and wait for
+		 * its result. While the VDOA is running, flush the bitstream.
+		 */
+		if (ctx->use_vdoa && ctx->low_latency) {
+			dst_buf = v4l2_m2m_next_dst_buf(ctx->fh.m2m_ctx);
+
+			vdoa_device_run(ctx->vdoa,
+					vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0),
+					ctx->internal_frames[display_idx].buf.paddr);
+
+			coda_bitstream_flush(ctx);
+			ctx->bit_stream_param &= ~CODA_BIT_STREAM_END_FLAG;
+			ctx->display_idx = display_idx;
+
+			err_vdoa = vdoa_wait_for_completion(ctx->vdoa);
+		}
+	} else {
 		v4l2_err(&dev->v4l2_dev,
 			 "presentation frame index out of range: %d\n",
 			 display_idx);
@@ -2675,7 +2723,8 @@ static void coda_finish_decode(struct coda_ctx *ctx)
 			dst_buf->flags |= V4L2_BUF_FLAG_LAST;
 		} else if ((ctx->bit_stream_param & CODA_BIT_STREAM_END_FLAG ||
 			    mpeg2_eos) &&
-			   display_idx == -1) {
+			   display_idx == -1 &&
+			   !ctx->low_latency) {
 			/*
 			 * If there is no designated presentation frame anymore,
 			 * this frame has to be the last one.
diff --git a/drivers/media/platform/chips-media/coda-common.c b/drivers/media/platform/chips-media/coda-common.c
index 65dc76892ea3..1b7ee20d440b 100644
--- a/drivers/media/platform/chips-media/coda-common.c
+++ b/drivers/media/platform/chips-media/coda-common.c
@@ -1867,6 +1867,7 @@ static int coda_job_ready(void *m2m_priv)
 		struct coda_buffer_meta *meta;
 		unsigned int payload = coda_get_bitstream_payload(ctx);
 		unsigned int count;
+		int min_buffers;
 
 		count = hweight32(ctx->frm_dis_flg);
 		if (ctx->use_vdoa && count >= (ctx->num_internal_frames - 1)) {
@@ -1884,18 +1885,34 @@ static int coda_job_ready(void *m2m_priv)
 			return 0;
 		}
 
-		if (!stream_end && (num_metas + src_bufs) < 2) {
+		/*
+		 * The h.264 decoder can recover from bitstream ring buffer
+		 * underruns ("buf empty" interrupt) by padding the bitstream
+		 * with a filler NAL in the interrupt handler. This doesn't
+		 * work reliably all the time, but so far there have been no
+		 * problems doing this to the first queued frame. For all
+		 * other frames, and other codecs, make sure that enough enough
+		 * data is available in advance, to avoid buf empty interrupts.
+		 */
+		if ((ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 &&
+		     ctx->qsequence == 1) || ctx->low_latency)
+			min_buffers = 1;
+		else
+			min_buffers = 2;
+		if (!stream_end && (num_metas + src_bufs) < min_buffers) {
 			trace_coda_not_ready(ctx, stream_end, src_bufs, num_metas, payload);
 			coda_dbg(1, ctx,
-				 "not ready: need 2 buffers available (queue:%d + bitstream:%d)\n",
-				 num_metas, src_bufs);
+				 "not ready: need %d buffers available (queue:%d + bitstream:%d)\n",
+				 min_buffers, num_metas, src_bufs);
 			return 0;
 		}
 
 		meta = list_first_entry(&ctx->buffer_meta_list,
 					struct coda_buffer_meta, list);
 		if (!coda_bitstream_can_fetch_past(ctx, meta->end) &&
-		    !stream_end) {
+		    !(ctx->codec->src_fourcc == V4L2_PIX_FMT_H264 &&
+		      ctx->qsequence == 1) &&
+		    !ctx->low_latency && !stream_end) {
 			trace_coda_not_ready(ctx, stream_end, src_bufs, num_metas, payload);
 			coda_dbg(1, ctx,
 				 "not ready: not enough bitstream data to read past %u (%u)\n",
diff --git a/drivers/media/platform/chips-media/coda.h b/drivers/media/platform/chips-media/coda.h
index e6b96132a504..ead14bdb5d03 100644
--- a/drivers/media/platform/chips-media/coda.h
+++ b/drivers/media/platform/chips-media/coda.h
@@ -315,6 +315,7 @@ struct coda_ctx {
 	struct dentry			*debugfs_entry;
 	bool				use_bit;
 	bool				use_vdoa;
+	bool				low_latency;
 	struct vdoa_ctx			*vdoa;
 	/*
 	 * wakeup mutex used to serialize encoder stop command and finish_run,
