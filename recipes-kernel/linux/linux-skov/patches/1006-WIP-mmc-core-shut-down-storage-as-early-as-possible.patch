From: Oleksij Rempel <o.rempel@pengutronix.de>
Date: Tue, 14 Nov 2023 13:32:51 +0100
Subject: [PATCH] WIP: mmc: core: shut down storage as early as possible

WIP note: this implementation is probably not mainline-able. Investigate
a better way to do it.

In case of under-volate event, we make have not enough time to shutdown
the store in ordered way. We need to do it as early as possible.

Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
---
 drivers/mmc/core/bus.c   | 48 +++++++++++++++++++++++++++++++++++++++++++++++-
 drivers/mmc/core/mmc.c   |  2 ++
 drivers/mmc/core/sd.c    |  1 +
 include/linux/mmc/card.h |  1 +
 4 files changed, 51 insertions(+), 1 deletion(-)

diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index 0af96548e7da..e2448500630d 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -16,6 +16,7 @@
 #include <linux/of.h>
 #include <linux/pm_runtime.h>
 #include <linux/sysfs.h>
+#include <linux/reboot.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -123,12 +124,57 @@ mmc_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)
 	return retval;
 }
 
+static int mmc_power_off_prepare(struct notifier_block *nb,
+				       unsigned long action, void *data)
+{
+	struct mmc_card *card =
+			container_of(nb, struct mmc_card, reboot_notifier);
+	struct device *dev = &card->dev;
+	struct mmc_driver *drv = to_mmc_driver(dev->driver);
+	struct mmc_host *host = card->host;
+	int ret;
+
+	pr_emerg("%s: shuting down mmc card\n", mmc_hostname(host));
+	if (dev->driver && drv->shutdown)
+		drv->shutdown(card);
+
+	if (host->bus_ops->shutdown) {
+		ret = host->bus_ops->shutdown(host);
+		if (ret)
+			pr_warn("%s: error %d during shutdown\n",
+				mmc_hostname(host), ret);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int mmc_power_off_prepare_init(struct device *dev)
+{
+	struct mmc_card *card = mmc_dev_to_card(dev);
+	int err;
+
+	card->reboot_notifier.notifier_call = mmc_power_off_prepare;
+	err = devm_register_reboot_notifier(dev, &card->reboot_notifier);
+	if (err) {
+		dev_err(dev, "failed to register sys-off handler: %d\n",
+			err);
+		return err;
+	}
+
+	return 0;
+}
+
 static int mmc_bus_probe(struct device *dev)
 {
 	struct mmc_driver *drv = to_mmc_driver(dev->driver);
 	struct mmc_card *card = mmc_dev_to_card(dev);
+	int ret;
+
+	ret = drv->probe(card);
+	if (ret)
+		return ret;
 
-	return drv->probe(card);
+	return mmc_power_off_prepare_init(dev);
 }
 
 static void mmc_bus_remove(struct device *dev)
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 705942edacc6..505eaa9bc9d7 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -2013,6 +2013,7 @@ static int mmc_poweroff_notify(struct mmc_card *card, unsigned int notify_type)
 	unsigned int timeout = card->ext_csd.generic_cmd6_time;
 	int err;
 
+	pr_err("mmc: power off notify\n");
 	/* Use EXT_CSD_POWER_OFF_SHORT as default notification type. */
 	if (notify_type == EXT_CSD_POWER_OFF_LONG)
 		timeout = card->ext_csd.power_off_longtime;
@@ -2024,6 +2025,7 @@ static int mmc_poweroff_notify(struct mmc_card *card, unsigned int notify_type)
 		pr_err("%s: Power Off Notification timed out, %u\n",
 		       mmc_hostname(card->host), timeout);
 
+	pr_err("mmc: power off notify done\n");
 	/* Disable the power off notification after the switch operation. */
 	card->ext_csd.power_off_notification = EXT_CSD_NO_POWER_NOTIFICATION;
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c3e554344c99..85d2cb845057 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1668,6 +1668,7 @@ static int sd_poweroff_notify(struct mmc_card *card)
 	if (!reg_buf)
 		return -ENOMEM;
 
+	pr_emerg("sending SD power off notification");
 	/*
 	 * Set the Power Off Notification bit in the power management settings
 	 * register at 2 bytes offset.
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 7b12eebc5586..4fa5dba32d22 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -341,6 +341,7 @@ struct mmc_card {
 	unsigned int    nr_parts;
 
 	struct workqueue_struct *complete_wq;	/* Private workqueue */
+	struct notifier_block reboot_notifier;
 };
 
 static inline bool mmc_large_sector(struct mmc_card *card)
