From: Ahmad Fatoum <a.fatoum@pengutronix.de>
Date: Tue, 14 May 2024 13:22:15 +0200
Subject: [PATCH] reboot: reboot, not shutdown, on hw_protection_reboot timeout

hw_protection_shutdown() will kick off an orderly shutdown and if that
takes longer than a configurable amount of time, an emergency shutdown
will occur.

Recently, hw_protection_reboot() was added for those systems that don't
implement a proper shutdown and are better served by rebooting and
having the boot firmware worry about doing something about the critical
condition.

On timeout of the orderly reboot of hw_protection_reboot(), the system
would go into shutdown, instead of reboot. This is not a good idea, as
going into shutdown was explicitly not asked for.

Fix this by always doing an emergency reboot if hw_protection_reboot()
is called and the orderly reboot takes too long.

Fixes: 79fa723ba84c ("reboot: Introduce thermal_zone_device_critical_reboot()")
Signed-off-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
---
 kernel/reboot.c | 60 ++++++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 42 insertions(+), 18 deletions(-)

diff --git a/kernel/reboot.c b/kernel/reboot.c
index 49c88a9a68d4..9089d727bc59 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -925,6 +925,20 @@ void orderly_reboot(void)
 }
 EXPORT_SYMBOL_GPL(orderly_reboot);
 
+static const char *hw_protection_action_str(enum hw_protection_action action)
+{
+	switch (action) {
+	case HWPROT_ACT_SHUTDOWN:
+		return "shutdown";
+	case HWPROT_ACT_REBOOT:
+		return "reboot";
+	default:
+		return "undefined";
+	}
+}
+
+static enum hw_protection_action hw_failure_emergency_action;
+
 /**
  * hw_failure_emergency_poweroff_func - emergency poweroff work after a known delay
  * @work: work_struct associated with the emergency poweroff function
@@ -934,37 +948,47 @@ EXPORT_SYMBOL_GPL(orderly_reboot);
  */
 static void hw_failure_emergency_poweroff_func(struct work_struct *work)
 {
-	/*
-	 * We have reached here after the emergency shutdown waiting period has
-	 * expired. This means orderly_poweroff has not been able to shut off
-	 * the system for some reason.
-	 *
-	 * Try to shut down the system immediately using kernel_power_off
-	 * if populated
-	 */
-	pr_emerg("Hardware protection timed-out. Trying forced poweroff\n");
-	kernel_power_off();
+	pr_emerg("Hardware protection timed-out. Trying forced %s\n",
+		 hw_protection_action_str(hw_failure_emergency_action));
 
-	/*
-	 * Worst of the worst case trigger emergency restart
-	 */
-	pr_emerg("Hardware protection shutdown failed. Trying emergency restart\n");
-	emergency_restart();
+	switch (hw_failure_emergency_action) {
+	case HWPROT_ACT_SHUTDOWN:
+	default:
+		/*
+		 * We have reached here after the emergency shutdown waiting period has
+		 * expired. This means orderly_poweroff has not been able to shut off
+		 * the system for some reason.
+		 *
+		 * Try to shut down the system immediately using kernel_power_off
+		 * if populated
+		 */
+		kernel_power_off();
+
+		/*
+		 * Worst of the worst case trigger emergency restart
+		 */
+		pr_emerg("Hardware protection shutdown failed. Trying emergency restart\n");
+		fallthrough;
+	case HWPROT_ACT_REBOOT:
+		emergency_restart();
+	}
 }
 
 static DECLARE_DELAYED_WORK(hw_failure_emergency_poweroff_work,
 			    hw_failure_emergency_poweroff_func);
 
 /**
- * hw_failure_emergency_poweroff - Trigger an emergency system poweroff
+ * hw_failure_emergency_schedule - Schedule an emergency system shutdown or reboot
  *
  * This may be called from any critical situation to trigger a system shutdown
  * after a given period of time. If time is negative this is not scheduled.
  */
-static void hw_failure_emergency_poweroff(int poweroff_delay_ms)
+static void hw_failure_emergency_schedule(enum hw_protection_action action,
+					  int poweroff_delay_ms)
 {
 	if (poweroff_delay_ms <= 0)
 		return;
+	hw_failure_emergency_action = action;
 	schedule_delayed_work(&hw_failure_emergency_poweroff_work,
 			      msecs_to_jiffies(poweroff_delay_ms));
 }
@@ -1002,7 +1026,7 @@ void __hw_protection_shutdown(const char *reason, int ms_until_forced,
 	 * Queue a backup emergency shutdown in the event of
 	 * orderly_poweroff failure
 	 */
-	hw_failure_emergency_poweroff(ms_until_forced);
+	hw_failure_emergency_schedule(action, ms_until_forced);
 	if (action == HWPROT_ACT_REBOOT)
 		orderly_reboot();
 	else
