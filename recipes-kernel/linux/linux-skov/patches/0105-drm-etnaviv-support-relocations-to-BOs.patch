From: Lucas Stach <l.stach@pengutronix.de>
Date: Thu, 15 Feb 2018 10:49:52 +0100
Subject: [PATCH] drm/etnaviv: support relocations to BOs

This is needed to support the TX desc buffers on GC7000. The current form of
the patch opens up security hole by leaking GPU addresses to userspace.

Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
---
 drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c | 60 ++++++++++++++++++++++++++++
 include/uapi/drm/etnaviv_drm.h               | 11 ++++-
 2 files changed, 70 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c b/drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c
index 46ecd3e66ac9..9c85f1e58ba4 100644
--- a/drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c
+++ b/drivers/gpu/drm/etnaviv/etnaviv_gem_submit.c
@@ -308,6 +308,51 @@ static int submit_reloc(struct etnaviv_gem_submit *submit, void *stream,
 	return 0;
 }
 
+static int submit_ext_reloc(struct etnaviv_gem_submit *submit,
+	const struct drm_etnaviv_gem_submit_ext_reloc *relocs,
+	u32 nr_relocs)
+{
+	unsigned int i;
+	u32 *ptr;
+	int ret;
+
+
+	for (i = 0; i < nr_relocs; i++) {
+		const struct drm_etnaviv_gem_submit_ext_reloc *r = relocs + i;
+		struct etnaviv_gem_submit_bo *reloc_bo, *target_bo;
+		u32 off;
+
+		if (unlikely(r->pad[0] || r->pad[1])) {
+			DRM_ERROR("pad not zero filled\n");
+			return -EINVAL;
+		}
+
+		ret = submit_bo(submit, r->reloc_idx, &reloc_bo);
+		if (ret)
+			return ret;
+
+		ret = submit_bo(submit, r->target_idx, &target_bo);
+		if (ret)
+			return ret;
+
+		if (r->reloc_offset > reloc_bo->obj->base.size - sizeof(*ptr)) {
+			DRM_ERROR("relocation %u outside object\n", i);
+			return -EINVAL;
+		}
+
+		off = r->target_offset / 4;
+		if (off >= target_bo->obj->base.size) {
+			DRM_ERROR("invalid offset %u at reloc %u\n", off, i);
+			return -EINVAL;
+		}
+
+		ptr = etnaviv_gem_vmap(&target_bo->obj->base);
+		ptr[off] = reloc_bo->mapping->iova + r->reloc_offset;
+	}
+
+	return 0;
+}
+
 static int submit_perfmon_validate(struct etnaviv_gem_submit *submit,
 		u32 exec_state, const struct drm_etnaviv_gem_submit_pmr *pmrs)
 {
@@ -408,6 +453,7 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 	struct etnaviv_file_private *ctx = file->driver_priv;
 	struct etnaviv_drm_private *priv = dev->dev_private;
 	struct drm_etnaviv_gem_submit *args = data;
+	struct drm_etnaviv_gem_submit_ext_reloc *ext_relocs;
 	struct drm_etnaviv_gem_submit_reloc *relocs;
 	struct drm_etnaviv_gem_submit_pmr *pmrs;
 	struct drm_etnaviv_gem_submit_bo *bos;
@@ -450,6 +496,7 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 	 */
 	bos = kvmalloc_array(args->nr_bos, sizeof(*bos), GFP_KERNEL);
 	relocs = kvmalloc_array(args->nr_relocs, sizeof(*relocs), GFP_KERNEL);
+	ext_relocs = kvmalloc_array(args->nr_ext_relocs, sizeof(*ext_relocs), GFP_KERNEL);
 	pmrs = kvmalloc_array(args->nr_pmrs, sizeof(*pmrs), GFP_KERNEL);
 	stream = kvmalloc_array(1, args->stream_size, GFP_KERNEL);
 	if (!bos || !relocs || !pmrs || !stream) {
@@ -471,6 +518,13 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 		goto err_submit_cmds;
 	}
 
+	ret = copy_from_user(ext_relocs, u64_to_user_ptr(args->ext_relocs),
+			     args->nr_ext_relocs * sizeof(*ext_relocs));
+	if (ret) {
+		ret = -EFAULT;
+		goto err_submit_cmds;
+	}
+
 	ret = copy_from_user(pmrs, u64_to_user_ptr(args->pmrs),
 			     args->nr_pmrs * sizeof(*pmrs));
 	if (ret) {
@@ -537,6 +591,10 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 	if (ret)
 		goto err_submit_objects;
 
+	ret = submit_ext_reloc(submit, ext_relocs, args->nr_ext_relocs);
+	if (ret)
+		goto err_submit_objects;
+
 	ret = submit_perfmon_validate(submit, args->exec_state, pmrs);
 	if (ret)
 		goto err_submit_objects;
@@ -588,6 +646,8 @@ int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 		kvfree(stream);
 	if (bos)
 		kvfree(bos);
+	if (ext_relocs)
+		kvfree(ext_relocs);
 	if (relocs)
 		kvfree(relocs);
 	if (pmrs)
diff --git a/include/uapi/drm/etnaviv_drm.h b/include/uapi/drm/etnaviv_drm.h
index 0d5c49dc478c..70e85d2b52b8 100644
--- a/include/uapi/drm/etnaviv_drm.h
+++ b/include/uapi/drm/etnaviv_drm.h
@@ -138,6 +138,14 @@ struct drm_etnaviv_gem_submit_reloc {
 	__u32 flags;          /* in, placeholder for now, no defined values */
 };
 
+struct drm_etnaviv_gem_submit_ext_reloc {
+	__u32 reloc_idx;      /* in, index of reloc bo */
+	__u32 target_idx;     /* in, index of buffer to write reloc to */
+	__u64 reloc_offset;   /* in, offset from address of reloc_bo */
+	__u64 target_offset;  /* in, offset inside the target bo */
+	__u64 pad[2];         /* reserved for further expansion */
+};
+
 /* Each buffer referenced elsewhere in the cmdstream submit (ie. the
  * cmdstream buffer(s) themselves or reloc entries) has one (and only
  * one) entry in the submit->bos[] table.
@@ -197,7 +205,8 @@ struct drm_etnaviv_gem_submit {
 	__s32 fence_fd;       /* in/out, fence fd (see ETNA_SUBMIT_FENCE_FD_x) */
 	__u64 pmrs;           /* in, ptr to array of submit_pmr's */
 	__u32 nr_pmrs;        /* in, number of submit_pmr's */
-	__u32 pad;
+	__u32 nr_ext_relocs;  /* in, number of ext reloc's */
+	__u64 ext_relocs;     /* in, ptr to array of ext reloc's */
 };
 
 /* The normal way to synchronize with the GPU is just to CPU_PREP on
