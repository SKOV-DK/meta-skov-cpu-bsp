From: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date: Tue, 12 Apr 2016 17:28:29 +0200
Subject: [PATCH] micrel-smi: add driver for KSZ8873

Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
---
 drivers/net/phy/Kconfig      |   5 +
 drivers/net/phy/Makefile     |   1 +
 drivers/net/phy/micrel-smi.c | 171 ++++++++++++++++++++
 drivers/net/phy/micrel-smi.h | 370 +++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 547 insertions(+)
 create mode 100644 drivers/net/phy/micrel-smi.c
 create mode 100644 drivers/net/phy/micrel-smi.h

diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 60994a83a0d6..eaf73f156951 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -141,6 +141,11 @@ config MICREL_PHY
 	---help---
 	  Supports the KSZ9021, VSC8201, KS8001 PHYs.
 
+config MICREL_SMI
+	tristate "Driver for Micrel Switch KSW8873"
+	---help---
+	  Supports the KSZ8873 Switch.
+
 config DP83848_PHY
 	tristate "Driver for Texas Instruments DP83848 PHY"
 	---help---
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index f31a4e25cf15..a3f2fe4cc0d2 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_DP83848_PHY)	+= dp83848.o
 obj-$(CONFIG_DP83867_PHY)	+= dp83867.o
 obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+obj-$(CONFIG_MICREL_SMI)	+= micrel-smi.o
 obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
 obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
 obj-$(CONFIG_AT803X_PHY)	+= at803x.o
diff --git a/drivers/net/phy/micrel-smi.c b/drivers/net/phy/micrel-smi.c
new file mode 100644
index 000000000000..143a1ecb16b3
--- /dev/null
+++ b/drivers/net/phy/micrel-smi.c
@@ -0,0 +1,171 @@
+/*
+ * Micrel KSZ8873
+ *
+ * Copyright (c) 2016 Pengutronix, Michael Grzeschik <m.grzeschik@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/of_mdio.h>
+#include <linux/phy.h>
+
+#include "micrel-smi.h"
+
+/* Port1 WFQ offset */
+#define QOS_WFQ_ADDR(port, queue, addr)		\
+{														\
+	uchar regaddr;										\
+	regaddr = REG_PORT_1_WFQ0 + (port * 4);			\
+	(*addr = regaddr - (queue * (REG_PORT_1_WFQ0 - REG_PORT_1_WFQ1))); \
+}
+
+struct ksz8873_priv {
+	struct device *dev;
+	struct phy_device *phydev;
+	unsigned int nregs;
+};
+
+static int micrel_ksz8873_read(void *context, const void *reg, size_t reg_size,
+			  void *val, size_t val_size)
+{
+	struct ksz8873_priv *priv = context;
+	struct phy_device *phydev = priv->phydev;
+	unsigned int offset = *(u32 *)reg;
+	unsigned int phy;
+	int ret;
+
+	phy = (offset >> 5);
+	/* read needs first phy bit to be 1 */
+	phy |= 0x10;
+
+	offset &= 0x1f;
+	/* we flag the reg value with SMI0 to get opcode 0 */
+	offset |= MII_ADDR_SMI0;
+
+	ret = mdiobus_read(phydev->bus, phy, offset);
+	if (ret < 0)
+		return ret;
+
+	*(u8 *)val = ret;
+
+	return 0;
+}
+
+static int micrel_ksz8873_write(void *context, const void *data, size_t count)
+{
+	struct ksz8873_priv *priv = context;
+	struct phy_device *phydev = priv->phydev;
+	unsigned int phy;
+	int ret;
+	u16 *dout = (u16 *)data;
+	u16 reg = dout[0];
+	++dout;
+	--count;
+
+	phy = (reg >> 5);
+
+	reg &= 0x1f;
+	/* we flag the reg value with SMI0 to get opcode 0 */
+	reg |= MII_ADDR_SMI0;
+
+	ret = mdiobus_write(phydev->bus, phy, reg, *dout);
+	if (ret < 0)
+		return ret;
+
+	/* Not implemented */
+	return 0;
+}
+
+static struct regmap_bus micrel_ksz8873_bus = {
+	.read = micrel_ksz8873_read,
+	.write = micrel_ksz8873_write,
+	.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,
+	.val_format_endian_default = REGMAP_ENDIAN_NATIVE,
+};
+
+static bool micrel_ksz8873_writeable_reg(struct device *dev, unsigned int reg)
+{
+	return false;
+}
+
+static struct regmap_config micrel_ksz8873_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.reg_stride = 1,
+	.cache_type = REGCACHE_RBTREE,
+	.writeable_reg = micrel_ksz8873_writeable_reg,
+	.name = "micrel-ksz8873",
+};
+
+static const struct of_device_id micrel_ksz8873_dt_ids[] = {
+	{ .compatible = "micrel,ksz8873",  (void *)199 },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, micrel_ksz8873_dt_ids);
+
+static int micrel_ksz8873_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id;
+	struct device *dev = &pdev->dev;
+	struct regmap *regmap;
+	struct ksz8873_priv *priv;
+	struct device_node *phy_handle;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	phy_handle = of_parse_phandle(dev->of_node, "phy-handle", 0);
+	priv->phydev = of_phy_find_device(phy_handle);
+	if ((PTR_ERR(priv->phydev) == -EPROBE_DEFER))
+		return -EPROBE_DEFER;
+	else if (!priv->phydev)
+		return -ENODEV;
+
+	of_id = of_match_device(micrel_ksz8873_dt_ids, dev);
+	priv->nregs = (unsigned int)of_id->data;
+	micrel_ksz8873_regmap_config.max_register = priv->nregs - 1;
+
+	regmap = devm_regmap_init(dev, &micrel_ksz8873_bus, priv,
+				  &micrel_ksz8873_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "regmap init failed\n");
+		return PTR_ERR(regmap);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static int micrel_ksz8873_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver micrel_ksz8873_driver = {
+	.probe	= micrel_ksz8873_probe,
+	.remove	= micrel_ksz8873_remove,
+	.driver = {
+		.name	= "micrel_ksz8873",
+		.of_match_table = micrel_ksz8873_dt_ids,
+	},
+};
+module_platform_driver(micrel_ksz8873_driver);
+
+MODULE_AUTHOR("Michael Grzeschik <m.grzeschik@pengutronix.de>");
+MODULE_DESCRIPTION("Micrel KSZ8873 SMI Switch driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/phy/micrel-smi.h b/drivers/net/phy/micrel-smi.h
new file mode 100644
index 000000000000..92eedad648ba
--- /dev/null
+++ b/drivers/net/phy/micrel-smi.h
@@ -0,0 +1,370 @@
+/*
+ * ks8873Reg.h
+ *
+ * Micrel KSZ8873 3-port switch Registers definitions.
+ *
+ * Copyright (C) 2011 Micrel, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __KS8873REG_h
+#define __KS8873REG_h
+
+/* Switch Global Control registers  */
+
+#define REG_SWITCH_ID              0x00        /* Chip ID0 */
+#define   SWITCH_ID                  0x88         /* chip ID */
+
+#define REG_SWITCH_SIDER           0x01        /* Chip ID1 */
+#define   SWITCH_START               (1 << 0 )    /* Enable switch */
+
+#define REG_SWITCH_CTRL_0          0x02        /* Global Control 0 */
+#define   SWITCH_NEW_BACKOFF         (1 << 7 )    /* enable new back-off algorithm */
+#define   SWITCH_FLUSH_DYNA_MAC      (1 << 5 )    /* flush dynamic MAC table */
+#define   SWITCH_FLUSH_STATIC_MAC    (1 << 4 )    /* flush static MAC table */
+#define   SWITCH_PASS_PAUSE          (1 << 3 )    /* pass flow control pkts */
+#define   SWITCH_LINK_AUTO_AGING     (1 << 0 )    /* fast aging when from link up to down */
+
+#define REG_SWITCH_CTRL_1          0x03        /* Global Control 1 */
+#define   SWITCH_PASS_ALL            (1 << 7 )    /* pass all frames */
+#define   SWITCH_TAIL_TAG_ENABLE     (1 << 6 )    /* enable port 3 tail tag mode */
+#define   SWITCH_TX_FLOW_CTRL        (1 << 5 )    /* IEEE 802.3x tx flow control enable */
+#define   SWITCH_RX_FLOW_CTRL        (1 << 4 )    /* IEEE 802.3x rx flow control enable */
+#define   SWITCH_CHECK_LENGTH        (1 << 3 )    /* check frame length field in the IEEE pkts */
+#define   SWITCH_AGING_ENABLE        (1 << 2 )    /* enable Aging */
+#define   SWITCH_FAST_AGING          (1 << 1 )    /* enable fast aging (800us) */
+#define   SWITCH_AGGR_BACKOFF        (1 << 0 )    /* enable aggressive back off */
+
+#define REG_SWITCH_CTRL_2          0x04        /* Global Control 2 */
+#define   UNICAST_VLAN_BOUNDARY      (1 << 7 )    /* all pkts can't cross VLAN boundary */
+#define   MULTICAST_STORM_DISABLE    (1 << 6 )    /* broadcast storm protection not include multicast pkt */
+#define   SWITCH_BACK_PRESSURE       (1 << 5 )    /* select carrier sense based backpressure */
+#define   FAIR_FLOW_CTRL             (1 << 4 )    /* select fair mode */
+#define   NO_EXC_COLLISION_DROP      (1 << 3 )    /* switch not drop pkts when more than 16 collision happen */
+#define   SWITCH_HUGE_PACKET         (1 << 2 )    /* accept huge pkts - upto 1916 bytes */
+#define   SWITCH_LEGAL_PACKET        (1 << 1 )    /* accept legal max pkt - uptp 1536 bytes */
+
+#define REG_SWITCH_CTRL_3          0x05        /* Global Control 3 */
+#define   SWITCH_VLAN_ENABLE         (1 << 7 )    /* enable 802.1Q */
+#define   SWITCH_IGMP_ENABLE         (1 << 6 )    /* enable IGMP snoop */
+#define   PRIORITY_SCHEME_SELECT     (1 << 3 )    /* enable WFQ  */
+#define   CURRENT_PRIORITY_QUEUE     (1 << 2 )    /* current priority priority queue is depleted */
+#define   SWITCH_MIRROR_RX_TX        (1 << 0 )    /* select rx AND tx sniff mode */
+
+#define REG_SWITCH_CTRL_4          0x06        /* Global Control 4 */
+#define   SWITCH_HALF_DUPLEX         (1 << 6)     /* enable MII port in half duplex */
+#define   SWITCH_FLOW_CTRL           (1 << 5)     /* enable MII  port flow control */
+#define   SWITCH_10BR                (1 << 4)     /* enable MII port in 10BT mode */
+#define   SWITCH_REPLACE_VID         (1 << 3)     /* replace NULL VID with port VID */
+#define   BROADCAST_STORM_RATE       (0x07)       /* Broadcast storm protection rate bit[10:8] mask */
+
+#define REG_SWITCH_CTRL_5          0x07        /* Global Control 5 */
+#define   BROADCAST_STORM_RATE_LO    (0xFF)       /* Broadcast storm protection rate bit[7:0] mask */
+
+#define REG_SWITCH_CTRL_9          0x0B        /* Global Control 9 */
+#define   SWITCH_CPU_CLK_31          (0x00)       /* CPU Port interface clock is 31.25Mhz */
+#define   SWITCH_CPU_CLK_62          (0x40)       /* CPU Port interface clock is 62.5Mhz */
+#define   SWITCH_CPU_CLK_125         (0x80)       /* CPU Port interface clock is 125Mhz (default) */
+#define   SWITCH_SYS_CLK_31          (0x00)       /* Switch clock is 31.25Mhz (default) */
+#define   SWITCH_SYS_CLK_62          (0x10)       /* Switch clock is 62.5Mhz */
+
+#define REG_DOT1P_TAG_CTRL_1       0x0C        /* Global Control 10 */
+#define REG_DOT1P_TAG_CTRL_2       0x0D        /* Global Control 11 */
+
+#define REG_SWITCH_CTRL_12         0x0E        /* Global Control 12 */
+#define   SWITCH_UNKNOWN_DA_ENABLE   (1 << 7)     /* enable tx unknow DA pkts to specified port */
+#define   SWITCH_DRIVER_16MA         (1 << 6)     /* Set driver strength to 16mA */
+#define   SWITCH_UNKNOWN_DA_2_PORT3  (1 << 2)     /* tx unknow DA pkts to port3 */
+#define   SWITCH_UNKNOWN_DA_2_PORT2  (1 << 1)     /* tx unknow DA pkts to port2 */
+#define   SWITCH_UNKNOWN_DA_2_PORT1  (1 << 0)     /* tx unknow DA pkts to port1 */
+
+#define REG_SWITCH_CTRL_13         0x0F        /* Global Control 13 */
+
+/* Port registers  */
+
+#define REG_PORT1_CTRL0            0x10        /* Port Control 0 */
+#define   PORT_BROADCAST_STORM       (1 << 7 )    /* enable broadcast storm protection */
+#define   PORT_DIFFSERV_ENABLE       (1 << 6 )    /* enable Diffserv QoS */
+#define   PORT_802_1P_ENABLE         (1 << 5 )    /* enable 802.1p QoS */
+#define   PORT_BASED_PRIORITY_MASK   (0x18 )      /* port-base QoS mask */
+#define   PORT_BASED_PRIORITY_SHIFT   3
+#define   PORT_PORT_PRIORITY_0       (0x00 )      /* port-base priority queue 0 QoS */
+#define   PORT_PORT_PRIORITY_1       (0x08 )      /* port-base priority queue 1 QoS */
+#define   PORT_PORT_PRIORITY_2       (0x10 )      /* port-base priority queue 2 QoS */
+#define   PORT_PORT_PRIORITY_3       (0x18 )      /* port-base priority queue 3 QoS */
+#define   PORT_INSERT_TAG            (1 << 2 )    /* enable vlan tag insertion */
+#define   PORT_REMOVE_TAG            (1 << 1 )    /* enable vlan tag removal */
+#define   PORT_PRIORITY_ENABLE       (1 << 0 )    /* enable split port tx queue to four queues */
+
+#define REG_PORT1_CTRL1            0x11        /* Port Control 1 */
+#define   PORT_MIRROR_SNIFFER        (1 << 7 )    /* select this port as sniffer port */
+#define   PORT_MIRROR_RX             (1 << 6 )    /* select this port as monitored rx pkts */
+#define   PORT_MIRROR_TX             (1 << 5 )    /* select this port as monitored tx pkts */
+#define   PORT_DOUBLE_TAG            (1 << 4 )    /* enable 'double tag' mode */
+#define   PORT_802_1P_REMAPPING      (1 << 3 )    /* enable replace 802.1p priority field */
+#define   PORT_VLAN_MEMBERSHIP       (0x07   )    /* Port VLAN membership mask */
+
+#define REG_PORT1_CTRL2            0x12        /* Port Control 2 */
+#define   PORT_SPLIT_2QUEUE          (1 << 7 )    /* enable split port tx queue to two queues */
+#define   PORT_INGRESS_FILTER        (1 << 6 )    /* VLAN ingress filtering */
+#define   PORT_DISCARD_NON_VID       (1 << 5 )    /* discard pkts whose VID not match port default VID */
+#define   PORT_FORCE_FLOW_CTRL       (1 << 4 )    /* force flow control */
+#define   PORT_BACK_PRESSURE         (1 << 3 )    /* enable back pressure */
+#define   PORT_TX_ENABLE             (1 << 2 )    /* enable tx */
+#define   PORT_RX_ENABLE             (1 << 1 )    /* enable rx */
+#define   PORT_LEARN_DISABLE         (1 << 0 )    /* disable learning */
+
+#define REG_PORT_1_CTRL1_VID       0x13        /* Port Control 3 */
+#define REG_PORT_1_CTRL2_VID       0x14        /* Port Control 4 */
+
+#define REG_PORT1_CTRL5            0x15        /* Port Control 5 */
+#define   PORT_SA_MAC1               (1 << 6 )    /* enable SA MAC1 */
+#define   PORT_SA_MAC2               (1 << 5 )    /* enable SA MAC2 */
+#define   PORT_DROP_TAG_PKT          (1 << 4 )    /* enable drop tagged ingress pkts */
+#define   PORT_INGRESS_LIMIT_MODE    (0x0C  )     /* Ingress rate limit mode mask */
+#define   PORT_INGRESS_ALL           (0x00  )     /*  - limit all frames */
+#define   PORT_INGRESS_UNICAST       (0x04  )     /*  - limit broadcast, multicast, flooded unicast pkts */
+#define   PORT_INGRESS_MULTICAST     (0x08  )     /*  - limit broadcast, multicast pkts only */
+#define   PORT_INGRESS_BROADCAST     (0x0C  )     /*  - limit broadcast pkts only */
+#define   PORT_COUNT_IFG             (1 << 1)     /* rate limiting include IFG bytes */
+#define   PORT_COUNT_PREAMBLE        (1 << 0)     /* rate limiting include preamble bytes */
+
+#define REG_PORT_1_IN_RATE0        0x16        /* Port Q0 ingress data rate limit */
+#define   PORT_INGRESS_LIMIT_64K     (0x65)       /* port1-queue0 ingress rate as 64Kbps */
+#define   PORT_INGRESS_LIMIT_MASK    (0x7F)       /* port1-queue0 ingress rate configuration */
+
+#define REG_PORT_1_IN_RATE1        0x17        /* Port Q1 ingress data rate limit */
+
+/* Port1 QN Ingress data rate limit offset */
+#define QUEUE_INGRESS_RATE_ADDR(port, queue, addr)		\
+{														\
+	uchar regaddr;										\
+	regaddr = REG_PORT_1_IN_RATE0 + (port * 0x10);			\
+	(*addr = regaddr + (queue) *							\
+		(REG_PORT_1_IN_RATE1 - REG_PORT_1_IN_RATE0)); \
+}
+
+#define REG_PORT_1_LINK_MD_CTRL    0x1A        /* Port PHY Special Control */
+#define   PORT_CABLE_10M_SHORT       (1 << 7 )    /* cable less than 10 meter short */
+#define   PORT_CABLE_DIAG_RESULT     (0x60 )      /* cable test result mask */
+#define   PORT_CABLE_STAT_NORMAL     (0x00 )      /* cable is normal */
+#define   PORT_CABLE_STAT_OPEN       (0x20 )      /* cable is open */
+#define   PORT_CABLE_STAT_SHORT      (0x40 )      /* cable is short */
+#define   PORT_CABLE_STAT_FAILED     (0x60 )      /* cable test fail */
+#define   PORT_START_CABLE_DIAG      (1 << 4 )    /* enable cable diag test */
+#define   PORT_FORCE_LINK            (1 << 3 )    /* force link pass */
+#define   PORT_PHY_REMOTE_LOOPBACK   (1 << 1 )    /* phy remote loopback */
+#define   PORT_CABLE_FAULT_COUNTER_H (0x01 )      /* cable fail in distance count mask */
+
+#define REG_PORT_1_LINK_MD_STATUS  0x1B        /* Port LinkMD Result */
+#define   PORT_CABLE_FAULT_COUNTER_L (0xFF )      /* cable fail in distance count mask */
+
+#define REG_PORT_1_CTRL12          0x1C        /* Port Control 12 */
+#define   PORT_AUTO_NEG_ENABLE       (1 << 7 )    /* enable auto-nego */
+#define   PORT_FORCE_100_MBIT        (1 << 6 )    /* force link speed to 100bt */
+#define   PORT_FORCE_FULL_DUPLEX     (1 << 5 )    /* force link in full duplex mode */
+#define   PORT_AUTO_NEG_SYM_PAUSE    (1 << 4 )    /* advertise pause ability */
+#define   PORT_AUTO_NEG_100BTX_FD    (1 << 3 )    /* advertise 100 full */
+#define   PORT_AUTO_NEG_100BTX       (1 << 2 )    /* advertise 100 half */
+#define   PORT_AUTO_NEG_10BT_FD      (1 << 1 )    /* advertise 10 full */
+#define   PORT_AUTO_NEG_10BT         (1 << 0 )    /* advertise 10 half */
+
+#define REG_PORT_1_CTRL13          0x1D        /* Port Control 13 */
+#define   PORT_LED_OFF               (1 << 7 )    /* turn off all port's LEDs */
+#define   PORT_TX_DISABLE            (1 << 6 )    /* disable tx */
+#define   PORT_AUTO_NEG_RESTART      (1 << 5 )    /* restart auto-nego */
+#define   PORT_REMOTE_FAULT_DISABLE  (1 << 4 )    /* disable far end fail detection */
+#define   PORT_POWER_DOWN            (1 << 3 )    /* phy power down */
+#define   PORT_AUTO_MDIX_DISABLE     (1 << 2 )    /* disable auto MDIX mode */
+#define   PORT_FORCE_MDIX            (1 << 1 )    /* force MDIX mode */
+#define   PORT_LOOPBACK              (1 << 0 )    /* phy loopback */
+
+#define REG_PORT_1_STATUS1         0x1E        /* Port Status 0 */
+#define   PORT_MDIX_STATUS           (1 << 7 )    /* phy is in MDI mode */
+#define   PORT_AUTO_NEG_COMPLETE     (1 << 6 )    /* auto-nego complete */
+#define   PORT_STATUS_LINK_GOOD      (1 << 5 )    /* link is up */
+#define   PORT_REMOTE_SYM_PAUSE      (1 << 4 )    /* link partner pause capability */
+#define   PORT_REMOTE_100BTX_FD      (1 << 3 )    /* link partner 100 full capability */
+#define   PORT_REMOTE_100BTX         (1 << 2 )    /* link partner 100 half capability */
+#define   PORT_REMOTE_10BT_FD        (1 << 1 )    /* link partner 10 full capability */
+#define   PORT_REMOTE_10BT           (1 << 0 )    /* link partner 10 hal capability */
+
+#define REG_PORT_1_STATUS2         0x1F        /* Port Status 1 */
+#define   PORT_HP_MDIX               (1 << 7 )    /* enable HP auto MDIX mode */
+#define   PORT_REVERSED_POLARITY     (1 << 5 )    /* phy polarity reverse */
+#define   PORT_TX_FLOW_CTRL          (1 << 4 )    /* rx flow control is active */
+#define   PORT_RX_FLOW_CTRL          (1 << 3 )    /* tx flow control is active */
+#define   PORT_STAT_SPEED_100MBIT    (1 << 2 )    /* link speed is in 100BT */
+#define   PORT_STAT_FULL_DUPLEX      (1 << 1 )    /* Link is in full duplex */
+#define   PORT_REMOTE_FAULT          (1 << 0 )    /* far end fault detected */
+
+/* Port 2 Registers are Port 1 register + REG_PORT_CTRL_OFFSET */
+/* Port 3 Registers are Port 2 register + REG_PORT_CTRL_OFFSET */
+#define	  REG_PORT_CTRL_OFFSET       (0x10)
+
+#define REG_RESET_CTRL             0x43        /* Reset */
+#define   GLOBAL_SOFTWARE_RESET      (1 << 4)     /* Global software reset */
+#define   PCS_RESET                  (1 << 0)     /* PCS reset */
+
+#define REG_TOS_PRIORITY_CTRL_0    0x60       /* TOS Priority Control Register 0 */
+#define REG_TOS_PRIORITY_CTRL_1    0x61       /* TOS Priority Control Register 1 */
+#define REG_TOS_PRIORITY_CTRL_2    0x62       /* TOS Priority Control Register 2 */
+#define REG_TOS_PRIORITY_CTRL_3    0x63       /* TOS Priority Control Register 3 */
+#define REG_TOS_PRIORITY_CTRL_4    0x64       /* TOS Priority Control Register 4 */
+#define REG_TOS_PRIORITY_CTRL_5    0x65       /* TOS Priority Control Register 5 */
+#define REG_TOS_PRIORITY_CTRL_6    0x66       /* TOS Priority Control Register 6 */
+#define REG_TOS_PRIORITY_CTRL_7    0x67       /* TOS Priority Control Register 7 */
+#define REG_TOS_PRIORITY_CTRL_8    0x68       /* TOS Priority Control Register 8 */
+#define REG_TOS_PRIORITY_CTRL_9    0x69       /* TOS Priority Control Register 9 */
+#define REG_TOS_PRIORITY_CTRL_10   0x6A       /* TOS Priority Control Register 10 */
+#define REG_TOS_PRIORITY_CTRL_11   0x6B       /* TOS Priority Control Register 11 */
+#define REG_TOS_PRIORITY_CTRL_12   0x6C       /* TOS Priority Control Register 12 */
+#define REG_TOS_PRIORITY_CTRL_13   0x6D       /* TOS Priority Control Register 13 */
+#define REG_TOS_PRIORITY_CTRL_14   0x6E       /* TOS Priority Control Register 14 */
+#define REG_TOS_PRIORITY_CTRL_15   0x6F       /* TOS Priority Control Register 15 */
+
+/* Switch MAC address */
+
+#define REG_SWITCH_MAC_ADDR_0      0x70        /* MAC Address Register 0 */
+#define REG_SWITCH_MAC_ADDR_1      0x71        /* MAC Address Register 1 */
+#define REG_SWITCH_MAC_ADDR_2      0x72        /* MAC Address Register 2 */
+#define REG_SWITCH_MAC_ADDR_3      0x73        /* MAC Address Register 3 */
+#define REG_SWITCH_MAC_ADDR_4      0x74        /* MAC Address Register 4 */
+#define REG_SWITCH_MAC_ADDR_5      0x75        /* MAC Address Register 5 */
+
+#define REG_IND_IACR0              0x79       /* Indirect Access Control 0 */
+#define   TABLE_READ                 (1 << 4 )    /* read operation */
+#define   TABLE_STATIC_MAC           (0 << 2 )    /* access static MAC address table */
+#define   TABLE_VLAN                 (1 << 2 )    /* access VLAN table */
+#define   TABLE_DYNAMIC_MAC          (2 << 2 )    /* access dynamic MAC address table */
+#define   TABLE_MIB                  (3 << 2 )    /* access MIB count table */
+
+#define REG_IND_IACR1              0x7A       /* Indirect Access Control 1 */
+
+#define REG_IND_DATA_8             0x7B       /* Indirect Data Register 8 */
+#define   TABLE_READ_NOT_COMPLETE    (1 << 7)     /* read is still in progress */
+
+#define REG_IND_DATA_7             0x7C       /* Indirect Data Register 7 */
+#define REG_IND_DATA_6             0x7D       /* Indirect Data Register 6 */
+#define REG_IND_DATA_5             0x7E       /* Indirect Data Register 5 */
+#define REG_IND_DATA_4             0x7F       /* Indirect Data Register 4 */
+#define REG_IND_DATA_3             0x80       /* Indirect Data Register 3 */
+#define REG_IND_DATA_2             0x81       /* Indirect Data Register 2 */
+#define REG_IND_DATA_1             0x82       /* Indirect Data Register 1 */
+#define REG_IND_DATA_0             0x83       /* Indirect Data Register 0 */
+
+/* Station MAC1/MAC2 address */
+
+#define REG_MAC1_ADDR_0            0x8E       /* Station Address 1 Register 0 */
+#define REG_MAC1_ADDR_1            0x8F       /* Station Address 1 Register 1 */
+#define REG_MAC1_ADDR_2            0x90       /* Station Address 1 Register 2 */
+#define REG_MAC1_ADDR_3            0x91       /* Station Address 1 Register 3 */
+#define REG_MAC1_ADDR_4            0x92       /* Station Address 1 Register 4 */
+#define REG_MAC1_ADDR_5            0x93       /* Station Address 1 Register 5 */
+
+#define REG_MAC2_ADDR_0            0x94       /* Station Address 2 Register 0 */
+#define REG_MAC2_ADDR_1            0x95       /* Station Address 2 Register 1 */
+#define REG_MAC2_ADDR_2            0x96       /* Station Address 2 Register 2 */
+#define REG_MAC2_ADDR_3            0x97       /* Station Address 2 Register 3 */
+#define REG_MAC2_ADDR_4            0x98       /* Station Address 2 Register 4 */
+#define REG_MAC2_ADDR_5            0x99       /* Station Address 2 Register 5 */
+
+
+#define REG_PORT_1_OUT_RATE0       0x9A        /* Port Q0 Egress data rate limit */
+#define   PORT_EGRESS_RATE_EN       (1 << 7)     /* enable queue egress rate limit */
+#define   PORT_EGRESS_LIMIT_MASK    (0x7F)       /* port1-queue0 Egress rate configuration */
+
+#define REG_PORT_1_OUT_RATE1       0x9B        /* Port Q1 Egress data rate limit */
+
+/* Port1 QN Egress data rate limit offset */
+
+#define QUEUE_EGRESS_RATE_ADDR(port, queue, addr)		\
+{														\
+	uchar regaddr;										\
+	regaddr = REG_PORT_1_OUT_RATE0 + (port * 4);			\
+	(*addr = regaddr + (queue) *							\
+		(REG_PORT_1_OUT_RATE1 - REG_PORT_1_OUT_RATE0)); \
+}
+
+#define PORT_CTRL_ADDR(port, addr)		\
+	(addr = REG_PORT1_CTRL1 + (port) *	\
+		(REG_PORT2_CTRL1 - REG_PORT1_CTRL1))
+
+
+#define REG_SWITCH_MODE_STATUS     0xA6       /* KSZ8873 mode indicator  */
+
+/* interrupt register */
+
+#define REG_INT_MASK               0xBB       /* Interrupt enable register */
+#define REG_INT_STATUS             0xBC       /* Link change interrupt status */
+#define   INT_PHY_P1_AND_P2          (1 << 7 )   /* Port1 or Port2 link change */
+#define   INT_MII_PORT3              (1 << 2 )   /* Port3 MII link change */
+#define   INT_PHY_PORT2              (1 << 1 )   /* Port2 PHY link change */
+#define   INT_MII_PORT1              (1 << 1 )   /* Port1 MII link change */
+
+#define REG_PAUSE_OFF              0xBD       /* Force Pause off iteration limit */
+#define REG_FIBER_THRESHOLD        0xC0       /* Fiber Signal threshold */
+#define   FIBER_PORT2_2V             (1 << 7 )   /* Port 2 fiber signal Threshold is 2.0V */
+#define   FIBER_PORT1_2V             (1 << 6 )   /* Port 1 fiber signal Threshold is 2.0V */
+
+#define REG_INSERT_PVID            0xC2       /* Insert SRC PVID */
+#define   INS_TAG_AT2_FROM1          (1 << 5 )    /* insert SRC port 1 PVID for untagged frame at egress port 2 */
+#define   INS_TAG_AT3_FROM1          (1 << 4 )    /* insert SRC port 1 PVID for untagged frame at egress port 3 */
+#define   INS_TAG_AT1_FROM2          (1 << 3 )    /* insert SRC port 2 PVID for untagged frame at egress port 1 */
+#define   INS_TAG_AT3_FROM2          (1 << 2 )    /* insert SRC port 2 PVID for untagged frame at egress port 3 */
+#define   INS_TAG_AT1_FROM3          (1 << 1 )    /* insert SRC port 3 PVID for untagged frame at egress port 1 */
+#define   INS_TAG_AT2_FROM3          (1 << 0 )    /* insert SRC port 3 PVID for untagged frame at egress port 2 */
+
+#define REG_POWER_CTRL             0xC3       /* Power Management and LED mode */
+#define   HOST_POWER_DOWN            (1 << 7 )    /* enable host interface power down */
+#define   SWITCH_POWER_DOWN          (1 << 6 )    /* enable Switch power down */
+#define   LED_SELECT_MODE3           (3 << 4 )    /* LED0->link, LED1->duplex */
+#define   LED_SELECT_MODE2           (2 << 4 )    /* LED0->link/ACT, LED1->duplex */
+#define   LED_SELECT_MODE1           (1 << 4 )    /* LED0->link, LED1->ACT */
+#define   LED_SELECT_MODE0           (0 << 4 )    /* LED0->link/ACT, LED1->speed */
+#define   LED_OUTPUT_NEGATED         (1 << 3 )    /*  */
+#define   PLL_POWER_DOWN             (1 << 2 )    /* enable PLL power down */
+#define   POWER_SAVE                 (3 << 0 )    /* Power saving mode */
+#define   POWER_SOFTWARE             (2 << 0 )    /* Software Power down mode */
+#define   POWER_ENERGY_DETECT        (1 << 0 )    /* Energy detection mode */
+#define   POWER_NORMAL               (0 << 0 )    /* Normal mode */
+
+#define REG_PM_SLEEP_TIME          0xC4       /* Sleep mode */
+
+#define REG_FORWARD_INVALID_VID    0xC6       /* Forward invalid VID Frame and Host mode */
+#define   SWITCH_INVALID_VID_PORT3   (1 << 6 )    /* forwarding invalid VID frames to port 3 */
+#define   SWITCH_INVALID_VID_PORT2   (1 << 5 )    /* forwarding invalid VID frames to port 2 */
+#define   SWITCH_INVALID_VID_PORT1   (1 << 4 )    /* forwarding invalid VID frames to port 1 */
+#define   HOST_SMI                   (3 << 0 )    /* host interface is SMI mode */
+#define   HOST_SPI_SLAVE             (2 << 0 )    /* host interface is SPI slave mode */
+#define   HOST_I2C_SLAVE             (1 << 0 )    /* host interface is I2C slave mode */
+#define   HOST_I2C_MASTER            (0 << 0 )    /* host interface is I2C master mode */
+
+#define REG_PORT_1_WFQ3            0xAF        /* Port1 TXQ Split - Q3 */
+#define REG_PORT_1_WFQ2            0xB0        /* Port1 TXQ Split - Q2 */
+#define REG_PORT_1_WFQ1            0xB1        /* Port1 TXQ Split - Q1 */
+#define REG_PORT_1_WFQ0            0xB2        /* Port1 TXQ Split - Q0 */
+#define   PORT_QUEUE_WFQ             (1 << 7 )    /* enable queue WFQ */
+
+/* Port1 WFQ offset */
+#define QOS_WFQ_ADDR(port, queue, addr)		\
+{														\
+	uchar regaddr;										\
+	regaddr = REG_PORT_1_WFQ0 + (port * 4);			\
+	(*addr = regaddr - (queue * (REG_PORT_1_WFQ0 - REG_PORT_1_WFQ1))); \
+}
+
+#endif /* #ifndef __KS8873REG_h */
+
+/*      END */
+
